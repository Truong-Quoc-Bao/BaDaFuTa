
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>
/**
 * Model merchant
 * ============ merchant ============
 */
export type merchant = $Result.DefaultSelection<Prisma.$merchantPayload>
/**
 * Model category
 * ============ category ============
 */
export type category = $Result.DefaultSelection<Prisma.$categoryPayload>
/**
 * Model menu_item
 * ============ menu_item ============
 */
export type menu_item = $Result.DefaultSelection<Prisma.$menu_itemPayload>
/**
 * Model option
 * ============ option ============
 */
export type option = $Result.DefaultSelection<Prisma.$optionPayload>
/**
 * Model option_item
 * ============ option_item ============
 */
export type option_item = $Result.DefaultSelection<Prisma.$option_itemPayload>
/**
 * Model menu_item_option
 * ============ menu_item_option (N-N) ============
 */
export type menu_item_option = $Result.DefaultSelection<Prisma.$menu_item_optionPayload>
/**
 * Model order
 * 
 */
export type order = $Result.DefaultSelection<Prisma.$orderPayload>
/**
 * Model order_item
 * 
 */
export type order_item = $Result.DefaultSelection<Prisma.$order_itemPayload>
/**
 * Model order_item_option
 * 
 */
export type order_item_option = $Result.DefaultSelection<Prisma.$order_item_optionPayload>
/**
 * Model payment_transaction
 * 
 */
export type payment_transaction = $Result.DefaultSelection<Prisma.$payment_transactionPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const PaymentStatus: {
  PENDING: 'PENDING',
  SUCCESS: 'SUCCESS',
  FAILED: 'FAILED',
  CANCELED: 'CANCELED',
  REFUNDED: 'REFUNDED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const order_status: {
  PENDING: 'PENDING',
  CONFIRMED: 'CONFIRMED',
  PREPARING: 'PREPARING',
  DELIVERING: 'DELIVERING',
  COMPLETED: 'COMPLETED',
  CANCELED: 'CANCELED'
};

export type order_status = (typeof order_status)[keyof typeof order_status]


export const payment_method: {
  COD: 'COD',
  VNPAY: 'VNPAY',
  MOMO: 'MOMO',
  STRIPE: 'STRIPE'
};

export type payment_method = (typeof payment_method)[keyof typeof payment_method]

}

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type order_status = $Enums.order_status

export const order_status: typeof $Enums.order_status

export type payment_method = $Enums.payment_method

export const payment_method: typeof $Enums.payment_method

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.users.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.users.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.merchant`: Exposes CRUD operations for the **merchant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Merchants
    * const merchants = await prisma.merchant.findMany()
    * ```
    */
  get merchant(): Prisma.merchantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.categoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.menu_item`: Exposes CRUD operations for the **menu_item** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Menu_items
    * const menu_items = await prisma.menu_item.findMany()
    * ```
    */
  get menu_item(): Prisma.menu_itemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.option`: Exposes CRUD operations for the **option** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Options
    * const options = await prisma.option.findMany()
    * ```
    */
  get option(): Prisma.optionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.option_item`: Exposes CRUD operations for the **option_item** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Option_items
    * const option_items = await prisma.option_item.findMany()
    * ```
    */
  get option_item(): Prisma.option_itemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.menu_item_option`: Exposes CRUD operations for the **menu_item_option** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Menu_item_options
    * const menu_item_options = await prisma.menu_item_option.findMany()
    * ```
    */
  get menu_item_option(): Prisma.menu_item_optionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.orderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order_item`: Exposes CRUD operations for the **order_item** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Order_items
    * const order_items = await prisma.order_item.findMany()
    * ```
    */
  get order_item(): Prisma.order_itemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order_item_option`: Exposes CRUD operations for the **order_item_option** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Order_item_options
    * const order_item_options = await prisma.order_item_option.findMany()
    * ```
    */
  get order_item_option(): Prisma.order_item_optionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment_transaction`: Exposes CRUD operations for the **payment_transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payment_transactions
    * const payment_transactions = await prisma.payment_transaction.findMany()
    * ```
    */
  get payment_transaction(): Prisma.payment_transactionDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.18.0
   * Query Engine version: 34b5a692b7bd79939a9a2c3ef97d816e749cda2f
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    users: 'users',
    merchant: 'merchant',
    category: 'category',
    menu_item: 'menu_item',
    option: 'option',
    option_item: 'option_item',
    menu_item_option: 'menu_item_option',
    order: 'order',
    order_item: 'order_item',
    order_item_option: 'order_item_option',
    payment_transaction: 'payment_transaction'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "users" | "merchant" | "category" | "menu_item" | "option" | "option_item" | "menu_item_option" | "order" | "order_item" | "order_item_option" | "payment_transaction"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.usersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.usersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      merchant: {
        payload: Prisma.$merchantPayload<ExtArgs>
        fields: Prisma.merchantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.merchantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$merchantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.merchantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$merchantPayload>
          }
          findFirst: {
            args: Prisma.merchantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$merchantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.merchantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$merchantPayload>
          }
          findMany: {
            args: Prisma.merchantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$merchantPayload>[]
          }
          create: {
            args: Prisma.merchantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$merchantPayload>
          }
          createMany: {
            args: Prisma.merchantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.merchantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$merchantPayload>[]
          }
          delete: {
            args: Prisma.merchantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$merchantPayload>
          }
          update: {
            args: Prisma.merchantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$merchantPayload>
          }
          deleteMany: {
            args: Prisma.merchantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.merchantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.merchantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$merchantPayload>[]
          }
          upsert: {
            args: Prisma.merchantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$merchantPayload>
          }
          aggregate: {
            args: Prisma.MerchantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMerchant>
          }
          groupBy: {
            args: Prisma.merchantGroupByArgs<ExtArgs>
            result: $Utils.Optional<MerchantGroupByOutputType>[]
          }
          count: {
            args: Prisma.merchantCountArgs<ExtArgs>
            result: $Utils.Optional<MerchantCountAggregateOutputType> | number
          }
        }
      }
      category: {
        payload: Prisma.$categoryPayload<ExtArgs>
        fields: Prisma.categoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.categoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.categoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>
          }
          findFirst: {
            args: Prisma.categoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.categoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>
          }
          findMany: {
            args: Prisma.categoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>[]
          }
          create: {
            args: Prisma.categoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>
          }
          createMany: {
            args: Prisma.categoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.categoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>[]
          }
          delete: {
            args: Prisma.categoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>
          }
          update: {
            args: Prisma.categoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>
          }
          deleteMany: {
            args: Prisma.categoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.categoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.categoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>[]
          }
          upsert: {
            args: Prisma.categoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.categoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.categoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      menu_item: {
        payload: Prisma.$menu_itemPayload<ExtArgs>
        fields: Prisma.menu_itemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.menu_itemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$menu_itemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.menu_itemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$menu_itemPayload>
          }
          findFirst: {
            args: Prisma.menu_itemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$menu_itemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.menu_itemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$menu_itemPayload>
          }
          findMany: {
            args: Prisma.menu_itemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$menu_itemPayload>[]
          }
          create: {
            args: Prisma.menu_itemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$menu_itemPayload>
          }
          createMany: {
            args: Prisma.menu_itemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.menu_itemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$menu_itemPayload>[]
          }
          delete: {
            args: Prisma.menu_itemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$menu_itemPayload>
          }
          update: {
            args: Prisma.menu_itemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$menu_itemPayload>
          }
          deleteMany: {
            args: Prisma.menu_itemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.menu_itemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.menu_itemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$menu_itemPayload>[]
          }
          upsert: {
            args: Prisma.menu_itemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$menu_itemPayload>
          }
          aggregate: {
            args: Prisma.Menu_itemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMenu_item>
          }
          groupBy: {
            args: Prisma.menu_itemGroupByArgs<ExtArgs>
            result: $Utils.Optional<Menu_itemGroupByOutputType>[]
          }
          count: {
            args: Prisma.menu_itemCountArgs<ExtArgs>
            result: $Utils.Optional<Menu_itemCountAggregateOutputType> | number
          }
        }
      }
      option: {
        payload: Prisma.$optionPayload<ExtArgs>
        fields: Prisma.optionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.optionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$optionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.optionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$optionPayload>
          }
          findFirst: {
            args: Prisma.optionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$optionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.optionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$optionPayload>
          }
          findMany: {
            args: Prisma.optionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$optionPayload>[]
          }
          create: {
            args: Prisma.optionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$optionPayload>
          }
          createMany: {
            args: Prisma.optionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.optionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$optionPayload>[]
          }
          delete: {
            args: Prisma.optionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$optionPayload>
          }
          update: {
            args: Prisma.optionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$optionPayload>
          }
          deleteMany: {
            args: Prisma.optionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.optionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.optionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$optionPayload>[]
          }
          upsert: {
            args: Prisma.optionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$optionPayload>
          }
          aggregate: {
            args: Prisma.OptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOption>
          }
          groupBy: {
            args: Prisma.optionGroupByArgs<ExtArgs>
            result: $Utils.Optional<OptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.optionCountArgs<ExtArgs>
            result: $Utils.Optional<OptionCountAggregateOutputType> | number
          }
        }
      }
      option_item: {
        payload: Prisma.$option_itemPayload<ExtArgs>
        fields: Prisma.option_itemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.option_itemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$option_itemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.option_itemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$option_itemPayload>
          }
          findFirst: {
            args: Prisma.option_itemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$option_itemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.option_itemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$option_itemPayload>
          }
          findMany: {
            args: Prisma.option_itemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$option_itemPayload>[]
          }
          create: {
            args: Prisma.option_itemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$option_itemPayload>
          }
          createMany: {
            args: Prisma.option_itemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.option_itemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$option_itemPayload>[]
          }
          delete: {
            args: Prisma.option_itemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$option_itemPayload>
          }
          update: {
            args: Prisma.option_itemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$option_itemPayload>
          }
          deleteMany: {
            args: Prisma.option_itemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.option_itemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.option_itemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$option_itemPayload>[]
          }
          upsert: {
            args: Prisma.option_itemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$option_itemPayload>
          }
          aggregate: {
            args: Prisma.Option_itemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOption_item>
          }
          groupBy: {
            args: Prisma.option_itemGroupByArgs<ExtArgs>
            result: $Utils.Optional<Option_itemGroupByOutputType>[]
          }
          count: {
            args: Prisma.option_itemCountArgs<ExtArgs>
            result: $Utils.Optional<Option_itemCountAggregateOutputType> | number
          }
        }
      }
      menu_item_option: {
        payload: Prisma.$menu_item_optionPayload<ExtArgs>
        fields: Prisma.menu_item_optionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.menu_item_optionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$menu_item_optionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.menu_item_optionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$menu_item_optionPayload>
          }
          findFirst: {
            args: Prisma.menu_item_optionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$menu_item_optionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.menu_item_optionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$menu_item_optionPayload>
          }
          findMany: {
            args: Prisma.menu_item_optionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$menu_item_optionPayload>[]
          }
          create: {
            args: Prisma.menu_item_optionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$menu_item_optionPayload>
          }
          createMany: {
            args: Prisma.menu_item_optionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.menu_item_optionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$menu_item_optionPayload>[]
          }
          delete: {
            args: Prisma.menu_item_optionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$menu_item_optionPayload>
          }
          update: {
            args: Prisma.menu_item_optionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$menu_item_optionPayload>
          }
          deleteMany: {
            args: Prisma.menu_item_optionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.menu_item_optionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.menu_item_optionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$menu_item_optionPayload>[]
          }
          upsert: {
            args: Prisma.menu_item_optionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$menu_item_optionPayload>
          }
          aggregate: {
            args: Prisma.Menu_item_optionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMenu_item_option>
          }
          groupBy: {
            args: Prisma.menu_item_optionGroupByArgs<ExtArgs>
            result: $Utils.Optional<Menu_item_optionGroupByOutputType>[]
          }
          count: {
            args: Prisma.menu_item_optionCountArgs<ExtArgs>
            result: $Utils.Optional<Menu_item_optionCountAggregateOutputType> | number
          }
        }
      }
      order: {
        payload: Prisma.$orderPayload<ExtArgs>
        fields: Prisma.orderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.orderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$orderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.orderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$orderPayload>
          }
          findFirst: {
            args: Prisma.orderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$orderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.orderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$orderPayload>
          }
          findMany: {
            args: Prisma.orderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$orderPayload>[]
          }
          create: {
            args: Prisma.orderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$orderPayload>
          }
          createMany: {
            args: Prisma.orderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.orderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$orderPayload>[]
          }
          delete: {
            args: Prisma.orderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$orderPayload>
          }
          update: {
            args: Prisma.orderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$orderPayload>
          }
          deleteMany: {
            args: Prisma.orderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.orderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.orderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$orderPayload>[]
          }
          upsert: {
            args: Prisma.orderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$orderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.orderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.orderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      order_item: {
        payload: Prisma.$order_itemPayload<ExtArgs>
        fields: Prisma.order_itemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.order_itemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_itemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.order_itemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_itemPayload>
          }
          findFirst: {
            args: Prisma.order_itemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_itemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.order_itemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_itemPayload>
          }
          findMany: {
            args: Prisma.order_itemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_itemPayload>[]
          }
          create: {
            args: Prisma.order_itemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_itemPayload>
          }
          createMany: {
            args: Prisma.order_itemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.order_itemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_itemPayload>[]
          }
          delete: {
            args: Prisma.order_itemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_itemPayload>
          }
          update: {
            args: Prisma.order_itemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_itemPayload>
          }
          deleteMany: {
            args: Prisma.order_itemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.order_itemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.order_itemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_itemPayload>[]
          }
          upsert: {
            args: Prisma.order_itemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_itemPayload>
          }
          aggregate: {
            args: Prisma.Order_itemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder_item>
          }
          groupBy: {
            args: Prisma.order_itemGroupByArgs<ExtArgs>
            result: $Utils.Optional<Order_itemGroupByOutputType>[]
          }
          count: {
            args: Prisma.order_itemCountArgs<ExtArgs>
            result: $Utils.Optional<Order_itemCountAggregateOutputType> | number
          }
        }
      }
      order_item_option: {
        payload: Prisma.$order_item_optionPayload<ExtArgs>
        fields: Prisma.order_item_optionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.order_item_optionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_item_optionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.order_item_optionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_item_optionPayload>
          }
          findFirst: {
            args: Prisma.order_item_optionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_item_optionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.order_item_optionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_item_optionPayload>
          }
          findMany: {
            args: Prisma.order_item_optionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_item_optionPayload>[]
          }
          create: {
            args: Prisma.order_item_optionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_item_optionPayload>
          }
          createMany: {
            args: Prisma.order_item_optionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.order_item_optionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_item_optionPayload>[]
          }
          delete: {
            args: Prisma.order_item_optionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_item_optionPayload>
          }
          update: {
            args: Prisma.order_item_optionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_item_optionPayload>
          }
          deleteMany: {
            args: Prisma.order_item_optionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.order_item_optionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.order_item_optionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_item_optionPayload>[]
          }
          upsert: {
            args: Prisma.order_item_optionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_item_optionPayload>
          }
          aggregate: {
            args: Prisma.Order_item_optionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder_item_option>
          }
          groupBy: {
            args: Prisma.order_item_optionGroupByArgs<ExtArgs>
            result: $Utils.Optional<Order_item_optionGroupByOutputType>[]
          }
          count: {
            args: Prisma.order_item_optionCountArgs<ExtArgs>
            result: $Utils.Optional<Order_item_optionCountAggregateOutputType> | number
          }
        }
      }
      payment_transaction: {
        payload: Prisma.$payment_transactionPayload<ExtArgs>
        fields: Prisma.payment_transactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.payment_transactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_transactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.payment_transactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_transactionPayload>
          }
          findFirst: {
            args: Prisma.payment_transactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_transactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.payment_transactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_transactionPayload>
          }
          findMany: {
            args: Prisma.payment_transactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_transactionPayload>[]
          }
          create: {
            args: Prisma.payment_transactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_transactionPayload>
          }
          createMany: {
            args: Prisma.payment_transactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.payment_transactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_transactionPayload>[]
          }
          delete: {
            args: Prisma.payment_transactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_transactionPayload>
          }
          update: {
            args: Prisma.payment_transactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_transactionPayload>
          }
          deleteMany: {
            args: Prisma.payment_transactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.payment_transactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.payment_transactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_transactionPayload>[]
          }
          upsert: {
            args: Prisma.payment_transactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_transactionPayload>
          }
          aggregate: {
            args: Prisma.Payment_transactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment_transaction>
          }
          groupBy: {
            args: Prisma.payment_transactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<Payment_transactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.payment_transactionCountArgs<ExtArgs>
            result: $Utils.Optional<Payment_transactionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    users?: usersOmit
    merchant?: merchantOmit
    category?: categoryOmit
    menu_item?: menu_itemOmit
    option?: optionOmit
    option_item?: option_itemOmit
    menu_item_option?: menu_item_optionOmit
    order?: orderOmit
    order_item?: order_itemOmit
    order_item_option?: order_item_optionOmit
    payment_transaction?: payment_transactionOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    merchants: number
    orders: number
    payment_transactions: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    merchants?: boolean | UsersCountOutputTypeCountMerchantsArgs
    orders?: boolean | UsersCountOutputTypeCountOrdersArgs
    payment_transactions?: boolean | UsersCountOutputTypeCountPayment_transactionsArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountMerchantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: merchantWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: orderWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountPayment_transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: payment_transactionWhereInput
  }


  /**
   * Count Type MerchantCountOutputType
   */

  export type MerchantCountOutputType = {
    categories: number
    menu_item: number
    option: number
    orders: number
    payment_transactions: number
  }

  export type MerchantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | MerchantCountOutputTypeCountCategoriesArgs
    menu_item?: boolean | MerchantCountOutputTypeCountMenu_itemArgs
    option?: boolean | MerchantCountOutputTypeCountOptionArgs
    orders?: boolean | MerchantCountOutputTypeCountOrdersArgs
    payment_transactions?: boolean | MerchantCountOutputTypeCountPayment_transactionsArgs
  }

  // Custom InputTypes
  /**
   * MerchantCountOutputType without action
   */
  export type MerchantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantCountOutputType
     */
    select?: MerchantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MerchantCountOutputType without action
   */
  export type MerchantCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: categoryWhereInput
  }

  /**
   * MerchantCountOutputType without action
   */
  export type MerchantCountOutputTypeCountMenu_itemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: menu_itemWhereInput
  }

  /**
   * MerchantCountOutputType without action
   */
  export type MerchantCountOutputTypeCountOptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: optionWhereInput
  }

  /**
   * MerchantCountOutputType without action
   */
  export type MerchantCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: orderWhereInput
  }

  /**
   * MerchantCountOutputType without action
   */
  export type MerchantCountOutputTypeCountPayment_transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: payment_transactionWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    menu_item: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    menu_item?: boolean | CategoryCountOutputTypeCountMenu_itemArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountMenu_itemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: menu_itemWhereInput
  }


  /**
   * Count Type Menu_itemCountOutputType
   */

  export type Menu_itemCountOutputType = {
    menu_item_option: number
    order_items: number
  }

  export type Menu_itemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    menu_item_option?: boolean | Menu_itemCountOutputTypeCountMenu_item_optionArgs
    order_items?: boolean | Menu_itemCountOutputTypeCountOrder_itemsArgs
  }

  // Custom InputTypes
  /**
   * Menu_itemCountOutputType without action
   */
  export type Menu_itemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu_itemCountOutputType
     */
    select?: Menu_itemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Menu_itemCountOutputType without action
   */
  export type Menu_itemCountOutputTypeCountMenu_item_optionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: menu_item_optionWhereInput
  }

  /**
   * Menu_itemCountOutputType without action
   */
  export type Menu_itemCountOutputTypeCountOrder_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: order_itemWhereInput
  }


  /**
   * Count Type OptionCountOutputType
   */

  export type OptionCountOutputType = {
    menu_item_option: number
    option_item: number
  }

  export type OptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    menu_item_option?: boolean | OptionCountOutputTypeCountMenu_item_optionArgs
    option_item?: boolean | OptionCountOutputTypeCountOption_itemArgs
  }

  // Custom InputTypes
  /**
   * OptionCountOutputType without action
   */
  export type OptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionCountOutputType
     */
    select?: OptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OptionCountOutputType without action
   */
  export type OptionCountOutputTypeCountMenu_item_optionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: menu_item_optionWhereInput
  }

  /**
   * OptionCountOutputType without action
   */
  export type OptionCountOutputTypeCountOption_itemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: option_itemWhereInput
  }


  /**
   * Count Type Option_itemCountOutputType
   */

  export type Option_itemCountOutputType = {
    order_item_options: number
  }

  export type Option_itemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order_item_options?: boolean | Option_itemCountOutputTypeCountOrder_item_optionsArgs
  }

  // Custom InputTypes
  /**
   * Option_itemCountOutputType without action
   */
  export type Option_itemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Option_itemCountOutputType
     */
    select?: Option_itemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Option_itemCountOutputType without action
   */
  export type Option_itemCountOutputTypeCountOrder_item_optionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: order_item_optionWhereInput
  }


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    items: number
    payments: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | OrderCountOutputTypeCountItemsArgs
    payments?: boolean | OrderCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: order_itemWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: payment_transactionWhereInput
  }


  /**
   * Count Type Order_itemCountOutputType
   */

  export type Order_itemCountOutputType = {
    options: number
  }

  export type Order_itemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    options?: boolean | Order_itemCountOutputTypeCountOptionsArgs
  }

  // Custom InputTypes
  /**
   * Order_itemCountOutputType without action
   */
  export type Order_itemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order_itemCountOutputType
     */
    select?: Order_itemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Order_itemCountOutputType without action
   */
  export type Order_itemCountOutputTypeCountOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: order_item_optionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersMinAggregateOutputType = {
    id: string | null
    full_name: string | null
    role: string | null
    birth: Date | null
    password: string | null
    phone: string | null
    email: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UsersMaxAggregateOutputType = {
    id: string | null
    full_name: string | null
    role: string | null
    birth: Date | null
    password: string | null
    phone: string | null
    email: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    image: number
    full_name: number
    role: number
    birth: number
    password: number
    phone: number
    email: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type UsersMinAggregateInputType = {
    id?: true
    full_name?: true
    role?: true
    birth?: true
    password?: true
    phone?: true
    email?: true
    created_at?: true
    updated_at?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    full_name?: true
    role?: true
    birth?: true
    password?: true
    phone?: true
    email?: true
    created_at?: true
    updated_at?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    image?: true
    full_name?: true
    role?: true
    birth?: true
    password?: true
    phone?: true
    email?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: string
    image: JsonValue | null
    full_name: string
    role: string | null
    birth: Date | null
    password: string
    phone: string
    email: string
    created_at: Date | null
    updated_at: Date | null
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    image?: boolean
    full_name?: boolean
    role?: boolean
    birth?: boolean
    password?: boolean
    phone?: boolean
    email?: boolean
    created_at?: boolean
    updated_at?: boolean
    merchants?: boolean | users$merchantsArgs<ExtArgs>
    orders?: boolean | users$ordersArgs<ExtArgs>
    payment_transactions?: boolean | users$payment_transactionsArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    image?: boolean
    full_name?: boolean
    role?: boolean
    birth?: boolean
    password?: boolean
    phone?: boolean
    email?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    image?: boolean
    full_name?: boolean
    role?: boolean
    birth?: boolean
    password?: boolean
    phone?: boolean
    email?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectScalar = {
    id?: boolean
    image?: boolean
    full_name?: boolean
    role?: boolean
    birth?: boolean
    password?: boolean
    phone?: boolean
    email?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "image" | "full_name" | "role" | "birth" | "password" | "phone" | "email" | "created_at" | "updated_at", ExtArgs["result"]["users"]>
  export type usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    merchants?: boolean | users$merchantsArgs<ExtArgs>
    orders?: boolean | users$ordersArgs<ExtArgs>
    payment_transactions?: boolean | users$payment_transactionsArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type usersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type usersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {
      merchants: Prisma.$merchantPayload<ExtArgs>[]
      orders: Prisma.$orderPayload<ExtArgs>[]
      payment_transactions: Prisma.$payment_transactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      image: Prisma.JsonValue | null
      full_name: string
      role: string | null
      birth: Date | null
      password: string
      phone: string
      email: string
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {usersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends usersCreateManyAndReturnArgs>(args?: SelectSubset<T, usersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {usersUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends usersUpdateManyAndReturnArgs>(args: SelectSubset<T, usersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    merchants<T extends users$merchantsArgs<ExtArgs> = {}>(args?: Subset<T, users$merchantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$merchantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orders<T extends users$ordersArgs<ExtArgs> = {}>(args?: Subset<T, users$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payment_transactions<T extends users$payment_transactionsArgs<ExtArgs> = {}>(args?: Subset<T, users$payment_transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_transactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */
  interface usersFieldRefs {
    readonly id: FieldRef<"users", 'String'>
    readonly image: FieldRef<"users", 'Json'>
    readonly full_name: FieldRef<"users", 'String'>
    readonly role: FieldRef<"users", 'String'>
    readonly birth: FieldRef<"users", 'DateTime'>
    readonly password: FieldRef<"users", 'String'>
    readonly phone: FieldRef<"users", 'String'>
    readonly email: FieldRef<"users", 'String'>
    readonly created_at: FieldRef<"users", 'DateTime'>
    readonly updated_at: FieldRef<"users", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users createManyAndReturn
   */
  export type usersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users updateManyAndReturn
   */
  export type usersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * users.merchants
   */
  export type users$merchantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the merchant
     */
    select?: merchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the merchant
     */
    omit?: merchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: merchantInclude<ExtArgs> | null
    where?: merchantWhereInput
    orderBy?: merchantOrderByWithRelationInput | merchantOrderByWithRelationInput[]
    cursor?: merchantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MerchantScalarFieldEnum | MerchantScalarFieldEnum[]
  }

  /**
   * users.orders
   */
  export type users$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order
     */
    omit?: orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderInclude<ExtArgs> | null
    where?: orderWhereInput
    orderBy?: orderOrderByWithRelationInput | orderOrderByWithRelationInput[]
    cursor?: orderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * users.payment_transactions
   */
  export type users$payment_transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_transaction
     */
    select?: payment_transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_transaction
     */
    omit?: payment_transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_transactionInclude<ExtArgs> | null
    where?: payment_transactionWhereInput
    orderBy?: payment_transactionOrderByWithRelationInput | payment_transactionOrderByWithRelationInput[]
    cursor?: payment_transactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Payment_transactionScalarFieldEnum | Payment_transactionScalarFieldEnum[]
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
  }


  /**
   * Model merchant
   */

  export type AggregateMerchant = {
    _count: MerchantCountAggregateOutputType | null
    _min: MerchantMinAggregateOutputType | null
    _max: MerchantMaxAggregateOutputType | null
  }

  export type MerchantMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    merchant_name: string | null
    phone: string | null
    email: string | null
    cuisine: string | null
  }

  export type MerchantMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    merchant_name: string | null
    phone: string | null
    email: string | null
    cuisine: string | null
  }

  export type MerchantCountAggregateOutputType = {
    id: number
    user_id: number
    merchant_name: number
    location: number
    phone: number
    email: number
    profile_image: number
    cover_image: number
    time_open: number
    cuisine: number
    _all: number
  }


  export type MerchantMinAggregateInputType = {
    id?: true
    user_id?: true
    merchant_name?: true
    phone?: true
    email?: true
    cuisine?: true
  }

  export type MerchantMaxAggregateInputType = {
    id?: true
    user_id?: true
    merchant_name?: true
    phone?: true
    email?: true
    cuisine?: true
  }

  export type MerchantCountAggregateInputType = {
    id?: true
    user_id?: true
    merchant_name?: true
    location?: true
    phone?: true
    email?: true
    profile_image?: true
    cover_image?: true
    time_open?: true
    cuisine?: true
    _all?: true
  }

  export type MerchantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which merchant to aggregate.
     */
    where?: merchantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of merchants to fetch.
     */
    orderBy?: merchantOrderByWithRelationInput | merchantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: merchantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` merchants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` merchants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned merchants
    **/
    _count?: true | MerchantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MerchantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MerchantMaxAggregateInputType
  }

  export type GetMerchantAggregateType<T extends MerchantAggregateArgs> = {
        [P in keyof T & keyof AggregateMerchant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMerchant[P]>
      : GetScalarType<T[P], AggregateMerchant[P]>
  }




  export type merchantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: merchantWhereInput
    orderBy?: merchantOrderByWithAggregationInput | merchantOrderByWithAggregationInput[]
    by: MerchantScalarFieldEnum[] | MerchantScalarFieldEnum
    having?: merchantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MerchantCountAggregateInputType | true
    _min?: MerchantMinAggregateInputType
    _max?: MerchantMaxAggregateInputType
  }

  export type MerchantGroupByOutputType = {
    id: string
    user_id: string
    merchant_name: string
    location: JsonValue | null
    phone: string | null
    email: string | null
    profile_image: JsonValue | null
    cover_image: JsonValue | null
    time_open: JsonValue | null
    cuisine: string | null
    _count: MerchantCountAggregateOutputType | null
    _min: MerchantMinAggregateOutputType | null
    _max: MerchantMaxAggregateOutputType | null
  }

  type GetMerchantGroupByPayload<T extends merchantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MerchantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MerchantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MerchantGroupByOutputType[P]>
            : GetScalarType<T[P], MerchantGroupByOutputType[P]>
        }
      >
    >


  export type merchantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    merchant_name?: boolean
    location?: boolean
    phone?: boolean
    email?: boolean
    profile_image?: boolean
    cover_image?: boolean
    time_open?: boolean
    cuisine?: boolean
    categories?: boolean | merchant$categoriesArgs<ExtArgs>
    menu_item?: boolean | merchant$menu_itemArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
    option?: boolean | merchant$optionArgs<ExtArgs>
    orders?: boolean | merchant$ordersArgs<ExtArgs>
    payment_transactions?: boolean | merchant$payment_transactionsArgs<ExtArgs>
    _count?: boolean | MerchantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["merchant"]>

  export type merchantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    merchant_name?: boolean
    location?: boolean
    phone?: boolean
    email?: boolean
    profile_image?: boolean
    cover_image?: boolean
    time_open?: boolean
    cuisine?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["merchant"]>

  export type merchantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    merchant_name?: boolean
    location?: boolean
    phone?: boolean
    email?: boolean
    profile_image?: boolean
    cover_image?: boolean
    time_open?: boolean
    cuisine?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["merchant"]>

  export type merchantSelectScalar = {
    id?: boolean
    user_id?: boolean
    merchant_name?: boolean
    location?: boolean
    phone?: boolean
    email?: boolean
    profile_image?: boolean
    cover_image?: boolean
    time_open?: boolean
    cuisine?: boolean
  }

  export type merchantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "merchant_name" | "location" | "phone" | "email" | "profile_image" | "cover_image" | "time_open" | "cuisine", ExtArgs["result"]["merchant"]>
  export type merchantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | merchant$categoriesArgs<ExtArgs>
    menu_item?: boolean | merchant$menu_itemArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
    option?: boolean | merchant$optionArgs<ExtArgs>
    orders?: boolean | merchant$ordersArgs<ExtArgs>
    payment_transactions?: boolean | merchant$payment_transactionsArgs<ExtArgs>
    _count?: boolean | MerchantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type merchantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type merchantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $merchantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "merchant"
    objects: {
      categories: Prisma.$categoryPayload<ExtArgs>[]
      menu_item: Prisma.$menu_itemPayload<ExtArgs>[]
      user: Prisma.$usersPayload<ExtArgs>
      option: Prisma.$optionPayload<ExtArgs>[]
      orders: Prisma.$orderPayload<ExtArgs>[]
      payment_transactions: Prisma.$payment_transactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      merchant_name: string
      location: Prisma.JsonValue | null
      phone: string | null
      email: string | null
      profile_image: Prisma.JsonValue | null
      cover_image: Prisma.JsonValue | null
      time_open: Prisma.JsonValue | null
      cuisine: string | null
    }, ExtArgs["result"]["merchant"]>
    composites: {}
  }

  type merchantGetPayload<S extends boolean | null | undefined | merchantDefaultArgs> = $Result.GetResult<Prisma.$merchantPayload, S>

  type merchantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<merchantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MerchantCountAggregateInputType | true
    }

  export interface merchantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['merchant'], meta: { name: 'merchant' } }
    /**
     * Find zero or one Merchant that matches the filter.
     * @param {merchantFindUniqueArgs} args - Arguments to find a Merchant
     * @example
     * // Get one Merchant
     * const merchant = await prisma.merchant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends merchantFindUniqueArgs>(args: SelectSubset<T, merchantFindUniqueArgs<ExtArgs>>): Prisma__merchantClient<$Result.GetResult<Prisma.$merchantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Merchant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {merchantFindUniqueOrThrowArgs} args - Arguments to find a Merchant
     * @example
     * // Get one Merchant
     * const merchant = await prisma.merchant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends merchantFindUniqueOrThrowArgs>(args: SelectSubset<T, merchantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__merchantClient<$Result.GetResult<Prisma.$merchantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Merchant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {merchantFindFirstArgs} args - Arguments to find a Merchant
     * @example
     * // Get one Merchant
     * const merchant = await prisma.merchant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends merchantFindFirstArgs>(args?: SelectSubset<T, merchantFindFirstArgs<ExtArgs>>): Prisma__merchantClient<$Result.GetResult<Prisma.$merchantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Merchant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {merchantFindFirstOrThrowArgs} args - Arguments to find a Merchant
     * @example
     * // Get one Merchant
     * const merchant = await prisma.merchant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends merchantFindFirstOrThrowArgs>(args?: SelectSubset<T, merchantFindFirstOrThrowArgs<ExtArgs>>): Prisma__merchantClient<$Result.GetResult<Prisma.$merchantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Merchants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {merchantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Merchants
     * const merchants = await prisma.merchant.findMany()
     * 
     * // Get first 10 Merchants
     * const merchants = await prisma.merchant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const merchantWithIdOnly = await prisma.merchant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends merchantFindManyArgs>(args?: SelectSubset<T, merchantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$merchantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Merchant.
     * @param {merchantCreateArgs} args - Arguments to create a Merchant.
     * @example
     * // Create one Merchant
     * const Merchant = await prisma.merchant.create({
     *   data: {
     *     // ... data to create a Merchant
     *   }
     * })
     * 
     */
    create<T extends merchantCreateArgs>(args: SelectSubset<T, merchantCreateArgs<ExtArgs>>): Prisma__merchantClient<$Result.GetResult<Prisma.$merchantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Merchants.
     * @param {merchantCreateManyArgs} args - Arguments to create many Merchants.
     * @example
     * // Create many Merchants
     * const merchant = await prisma.merchant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends merchantCreateManyArgs>(args?: SelectSubset<T, merchantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Merchants and returns the data saved in the database.
     * @param {merchantCreateManyAndReturnArgs} args - Arguments to create many Merchants.
     * @example
     * // Create many Merchants
     * const merchant = await prisma.merchant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Merchants and only return the `id`
     * const merchantWithIdOnly = await prisma.merchant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends merchantCreateManyAndReturnArgs>(args?: SelectSubset<T, merchantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$merchantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Merchant.
     * @param {merchantDeleteArgs} args - Arguments to delete one Merchant.
     * @example
     * // Delete one Merchant
     * const Merchant = await prisma.merchant.delete({
     *   where: {
     *     // ... filter to delete one Merchant
     *   }
     * })
     * 
     */
    delete<T extends merchantDeleteArgs>(args: SelectSubset<T, merchantDeleteArgs<ExtArgs>>): Prisma__merchantClient<$Result.GetResult<Prisma.$merchantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Merchant.
     * @param {merchantUpdateArgs} args - Arguments to update one Merchant.
     * @example
     * // Update one Merchant
     * const merchant = await prisma.merchant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends merchantUpdateArgs>(args: SelectSubset<T, merchantUpdateArgs<ExtArgs>>): Prisma__merchantClient<$Result.GetResult<Prisma.$merchantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Merchants.
     * @param {merchantDeleteManyArgs} args - Arguments to filter Merchants to delete.
     * @example
     * // Delete a few Merchants
     * const { count } = await prisma.merchant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends merchantDeleteManyArgs>(args?: SelectSubset<T, merchantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Merchants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {merchantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Merchants
     * const merchant = await prisma.merchant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends merchantUpdateManyArgs>(args: SelectSubset<T, merchantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Merchants and returns the data updated in the database.
     * @param {merchantUpdateManyAndReturnArgs} args - Arguments to update many Merchants.
     * @example
     * // Update many Merchants
     * const merchant = await prisma.merchant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Merchants and only return the `id`
     * const merchantWithIdOnly = await prisma.merchant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends merchantUpdateManyAndReturnArgs>(args: SelectSubset<T, merchantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$merchantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Merchant.
     * @param {merchantUpsertArgs} args - Arguments to update or create a Merchant.
     * @example
     * // Update or create a Merchant
     * const merchant = await prisma.merchant.upsert({
     *   create: {
     *     // ... data to create a Merchant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Merchant we want to update
     *   }
     * })
     */
    upsert<T extends merchantUpsertArgs>(args: SelectSubset<T, merchantUpsertArgs<ExtArgs>>): Prisma__merchantClient<$Result.GetResult<Prisma.$merchantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Merchants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {merchantCountArgs} args - Arguments to filter Merchants to count.
     * @example
     * // Count the number of Merchants
     * const count = await prisma.merchant.count({
     *   where: {
     *     // ... the filter for the Merchants we want to count
     *   }
     * })
    **/
    count<T extends merchantCountArgs>(
      args?: Subset<T, merchantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MerchantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Merchant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MerchantAggregateArgs>(args: Subset<T, MerchantAggregateArgs>): Prisma.PrismaPromise<GetMerchantAggregateType<T>>

    /**
     * Group by Merchant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {merchantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends merchantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: merchantGroupByArgs['orderBy'] }
        : { orderBy?: merchantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, merchantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMerchantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the merchant model
   */
  readonly fields: merchantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for merchant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__merchantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    categories<T extends merchant$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, merchant$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    menu_item<T extends merchant$menu_itemArgs<ExtArgs> = {}>(args?: Subset<T, merchant$menu_itemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$menu_itemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    option<T extends merchant$optionArgs<ExtArgs> = {}>(args?: Subset<T, merchant$optionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$optionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orders<T extends merchant$ordersArgs<ExtArgs> = {}>(args?: Subset<T, merchant$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payment_transactions<T extends merchant$payment_transactionsArgs<ExtArgs> = {}>(args?: Subset<T, merchant$payment_transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_transactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the merchant model
   */
  interface merchantFieldRefs {
    readonly id: FieldRef<"merchant", 'String'>
    readonly user_id: FieldRef<"merchant", 'String'>
    readonly merchant_name: FieldRef<"merchant", 'String'>
    readonly location: FieldRef<"merchant", 'Json'>
    readonly phone: FieldRef<"merchant", 'String'>
    readonly email: FieldRef<"merchant", 'String'>
    readonly profile_image: FieldRef<"merchant", 'Json'>
    readonly cover_image: FieldRef<"merchant", 'Json'>
    readonly time_open: FieldRef<"merchant", 'Json'>
    readonly cuisine: FieldRef<"merchant", 'String'>
  }
    

  // Custom InputTypes
  /**
   * merchant findUnique
   */
  export type merchantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the merchant
     */
    select?: merchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the merchant
     */
    omit?: merchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: merchantInclude<ExtArgs> | null
    /**
     * Filter, which merchant to fetch.
     */
    where: merchantWhereUniqueInput
  }

  /**
   * merchant findUniqueOrThrow
   */
  export type merchantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the merchant
     */
    select?: merchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the merchant
     */
    omit?: merchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: merchantInclude<ExtArgs> | null
    /**
     * Filter, which merchant to fetch.
     */
    where: merchantWhereUniqueInput
  }

  /**
   * merchant findFirst
   */
  export type merchantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the merchant
     */
    select?: merchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the merchant
     */
    omit?: merchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: merchantInclude<ExtArgs> | null
    /**
     * Filter, which merchant to fetch.
     */
    where?: merchantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of merchants to fetch.
     */
    orderBy?: merchantOrderByWithRelationInput | merchantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for merchants.
     */
    cursor?: merchantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` merchants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` merchants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of merchants.
     */
    distinct?: MerchantScalarFieldEnum | MerchantScalarFieldEnum[]
  }

  /**
   * merchant findFirstOrThrow
   */
  export type merchantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the merchant
     */
    select?: merchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the merchant
     */
    omit?: merchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: merchantInclude<ExtArgs> | null
    /**
     * Filter, which merchant to fetch.
     */
    where?: merchantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of merchants to fetch.
     */
    orderBy?: merchantOrderByWithRelationInput | merchantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for merchants.
     */
    cursor?: merchantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` merchants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` merchants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of merchants.
     */
    distinct?: MerchantScalarFieldEnum | MerchantScalarFieldEnum[]
  }

  /**
   * merchant findMany
   */
  export type merchantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the merchant
     */
    select?: merchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the merchant
     */
    omit?: merchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: merchantInclude<ExtArgs> | null
    /**
     * Filter, which merchants to fetch.
     */
    where?: merchantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of merchants to fetch.
     */
    orderBy?: merchantOrderByWithRelationInput | merchantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing merchants.
     */
    cursor?: merchantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` merchants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` merchants.
     */
    skip?: number
    distinct?: MerchantScalarFieldEnum | MerchantScalarFieldEnum[]
  }

  /**
   * merchant create
   */
  export type merchantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the merchant
     */
    select?: merchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the merchant
     */
    omit?: merchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: merchantInclude<ExtArgs> | null
    /**
     * The data needed to create a merchant.
     */
    data: XOR<merchantCreateInput, merchantUncheckedCreateInput>
  }

  /**
   * merchant createMany
   */
  export type merchantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many merchants.
     */
    data: merchantCreateManyInput | merchantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * merchant createManyAndReturn
   */
  export type merchantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the merchant
     */
    select?: merchantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the merchant
     */
    omit?: merchantOmit<ExtArgs> | null
    /**
     * The data used to create many merchants.
     */
    data: merchantCreateManyInput | merchantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: merchantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * merchant update
   */
  export type merchantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the merchant
     */
    select?: merchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the merchant
     */
    omit?: merchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: merchantInclude<ExtArgs> | null
    /**
     * The data needed to update a merchant.
     */
    data: XOR<merchantUpdateInput, merchantUncheckedUpdateInput>
    /**
     * Choose, which merchant to update.
     */
    where: merchantWhereUniqueInput
  }

  /**
   * merchant updateMany
   */
  export type merchantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update merchants.
     */
    data: XOR<merchantUpdateManyMutationInput, merchantUncheckedUpdateManyInput>
    /**
     * Filter which merchants to update
     */
    where?: merchantWhereInput
    /**
     * Limit how many merchants to update.
     */
    limit?: number
  }

  /**
   * merchant updateManyAndReturn
   */
  export type merchantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the merchant
     */
    select?: merchantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the merchant
     */
    omit?: merchantOmit<ExtArgs> | null
    /**
     * The data used to update merchants.
     */
    data: XOR<merchantUpdateManyMutationInput, merchantUncheckedUpdateManyInput>
    /**
     * Filter which merchants to update
     */
    where?: merchantWhereInput
    /**
     * Limit how many merchants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: merchantIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * merchant upsert
   */
  export type merchantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the merchant
     */
    select?: merchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the merchant
     */
    omit?: merchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: merchantInclude<ExtArgs> | null
    /**
     * The filter to search for the merchant to update in case it exists.
     */
    where: merchantWhereUniqueInput
    /**
     * In case the merchant found by the `where` argument doesn't exist, create a new merchant with this data.
     */
    create: XOR<merchantCreateInput, merchantUncheckedCreateInput>
    /**
     * In case the merchant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<merchantUpdateInput, merchantUncheckedUpdateInput>
  }

  /**
   * merchant delete
   */
  export type merchantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the merchant
     */
    select?: merchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the merchant
     */
    omit?: merchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: merchantInclude<ExtArgs> | null
    /**
     * Filter which merchant to delete.
     */
    where: merchantWhereUniqueInput
  }

  /**
   * merchant deleteMany
   */
  export type merchantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which merchants to delete
     */
    where?: merchantWhereInput
    /**
     * Limit how many merchants to delete.
     */
    limit?: number
  }

  /**
   * merchant.categories
   */
  export type merchant$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    where?: categoryWhereInput
    orderBy?: categoryOrderByWithRelationInput | categoryOrderByWithRelationInput[]
    cursor?: categoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * merchant.menu_item
   */
  export type merchant$menu_itemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu_item
     */
    select?: menu_itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the menu_item
     */
    omit?: menu_itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: menu_itemInclude<ExtArgs> | null
    where?: menu_itemWhereInput
    orderBy?: menu_itemOrderByWithRelationInput | menu_itemOrderByWithRelationInput[]
    cursor?: menu_itemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Menu_itemScalarFieldEnum | Menu_itemScalarFieldEnum[]
  }

  /**
   * merchant.option
   */
  export type merchant$optionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the option
     */
    select?: optionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the option
     */
    omit?: optionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: optionInclude<ExtArgs> | null
    where?: optionWhereInput
    orderBy?: optionOrderByWithRelationInput | optionOrderByWithRelationInput[]
    cursor?: optionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OptionScalarFieldEnum | OptionScalarFieldEnum[]
  }

  /**
   * merchant.orders
   */
  export type merchant$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order
     */
    omit?: orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderInclude<ExtArgs> | null
    where?: orderWhereInput
    orderBy?: orderOrderByWithRelationInput | orderOrderByWithRelationInput[]
    cursor?: orderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * merchant.payment_transactions
   */
  export type merchant$payment_transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_transaction
     */
    select?: payment_transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_transaction
     */
    omit?: payment_transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_transactionInclude<ExtArgs> | null
    where?: payment_transactionWhereInput
    orderBy?: payment_transactionOrderByWithRelationInput | payment_transactionOrderByWithRelationInput[]
    cursor?: payment_transactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Payment_transactionScalarFieldEnum | Payment_transactionScalarFieldEnum[]
  }

  /**
   * merchant without action
   */
  export type merchantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the merchant
     */
    select?: merchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the merchant
     */
    omit?: merchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: merchantInclude<ExtArgs> | null
  }


  /**
   * Model category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    merchant_id: string | null
    category_name: string | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    merchant_id: string | null
    category_name: string | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    merchant_id: number
    category_name: number
    _all: number
  }


  export type CategoryMinAggregateInputType = {
    id?: true
    merchant_id?: true
    category_name?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    merchant_id?: true
    category_name?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    merchant_id?: true
    category_name?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which category to aggregate.
     */
    where?: categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoryOrderByWithRelationInput | categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type categoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: categoryWhereInput
    orderBy?: categoryOrderByWithAggregationInput | categoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: categoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    merchant_id: string
    category_name: string
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends categoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type categorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    merchant_id?: boolean
    category_name?: boolean
    merchant?: boolean | merchantDefaultArgs<ExtArgs>
    menu_item?: boolean | category$menu_itemArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type categorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    merchant_id?: boolean
    category_name?: boolean
    merchant?: boolean | merchantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type categorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    merchant_id?: boolean
    category_name?: boolean
    merchant?: boolean | merchantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type categorySelectScalar = {
    id?: boolean
    merchant_id?: boolean
    category_name?: boolean
  }

  export type categoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "merchant_id" | "category_name", ExtArgs["result"]["category"]>
  export type categoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    merchant?: boolean | merchantDefaultArgs<ExtArgs>
    menu_item?: boolean | category$menu_itemArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type categoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    merchant?: boolean | merchantDefaultArgs<ExtArgs>
  }
  export type categoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    merchant?: boolean | merchantDefaultArgs<ExtArgs>
  }

  export type $categoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "category"
    objects: {
      merchant: Prisma.$merchantPayload<ExtArgs>
      menu_item: Prisma.$menu_itemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      merchant_id: string
      category_name: string
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type categoryGetPayload<S extends boolean | null | undefined | categoryDefaultArgs> = $Result.GetResult<Prisma.$categoryPayload, S>

  type categoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<categoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface categoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['category'], meta: { name: 'category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {categoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends categoryFindUniqueArgs>(args: SelectSubset<T, categoryFindUniqueArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {categoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends categoryFindUniqueOrThrowArgs>(args: SelectSubset<T, categoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends categoryFindFirstArgs>(args?: SelectSubset<T, categoryFindFirstArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends categoryFindFirstOrThrowArgs>(args?: SelectSubset<T, categoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends categoryFindManyArgs>(args?: SelectSubset<T, categoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {categoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends categoryCreateArgs>(args: SelectSubset<T, categoryCreateArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {categoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends categoryCreateManyArgs>(args?: SelectSubset<T, categoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {categoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends categoryCreateManyAndReturnArgs>(args?: SelectSubset<T, categoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Category.
     * @param {categoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends categoryDeleteArgs>(args: SelectSubset<T, categoryDeleteArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {categoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends categoryUpdateArgs>(args: SelectSubset<T, categoryUpdateArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {categoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends categoryDeleteManyArgs>(args?: SelectSubset<T, categoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends categoryUpdateManyArgs>(args: SelectSubset<T, categoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {categoryUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends categoryUpdateManyAndReturnArgs>(args: SelectSubset<T, categoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Category.
     * @param {categoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends categoryUpsertArgs>(args: SelectSubset<T, categoryUpsertArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends categoryCountArgs>(
      args?: Subset<T, categoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends categoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: categoryGroupByArgs['orderBy'] }
        : { orderBy?: categoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, categoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the category model
   */
  readonly fields: categoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__categoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    merchant<T extends merchantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, merchantDefaultArgs<ExtArgs>>): Prisma__merchantClient<$Result.GetResult<Prisma.$merchantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    menu_item<T extends category$menu_itemArgs<ExtArgs> = {}>(args?: Subset<T, category$menu_itemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$menu_itemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the category model
   */
  interface categoryFieldRefs {
    readonly id: FieldRef<"category", 'String'>
    readonly merchant_id: FieldRef<"category", 'String'>
    readonly category_name: FieldRef<"category", 'String'>
  }
    

  // Custom InputTypes
  /**
   * category findUnique
   */
  export type categoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter, which category to fetch.
     */
    where: categoryWhereUniqueInput
  }

  /**
   * category findUniqueOrThrow
   */
  export type categoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter, which category to fetch.
     */
    where: categoryWhereUniqueInput
  }

  /**
   * category findFirst
   */
  export type categoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter, which category to fetch.
     */
    where?: categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoryOrderByWithRelationInput | categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categories.
     */
    cursor?: categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * category findFirstOrThrow
   */
  export type categoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter, which category to fetch.
     */
    where?: categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoryOrderByWithRelationInput | categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categories.
     */
    cursor?: categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * category findMany
   */
  export type categoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter, which categories to fetch.
     */
    where?: categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoryOrderByWithRelationInput | categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing categories.
     */
    cursor?: categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * category create
   */
  export type categoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * The data needed to create a category.
     */
    data: XOR<categoryCreateInput, categoryUncheckedCreateInput>
  }

  /**
   * category createMany
   */
  export type categoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many categories.
     */
    data: categoryCreateManyInput | categoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * category createManyAndReturn
   */
  export type categoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * The data used to create many categories.
     */
    data: categoryCreateManyInput | categoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * category update
   */
  export type categoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * The data needed to update a category.
     */
    data: XOR<categoryUpdateInput, categoryUncheckedUpdateInput>
    /**
     * Choose, which category to update.
     */
    where: categoryWhereUniqueInput
  }

  /**
   * category updateMany
   */
  export type categoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update categories.
     */
    data: XOR<categoryUpdateManyMutationInput, categoryUncheckedUpdateManyInput>
    /**
     * Filter which categories to update
     */
    where?: categoryWhereInput
    /**
     * Limit how many categories to update.
     */
    limit?: number
  }

  /**
   * category updateManyAndReturn
   */
  export type categoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * The data used to update categories.
     */
    data: XOR<categoryUpdateManyMutationInput, categoryUncheckedUpdateManyInput>
    /**
     * Filter which categories to update
     */
    where?: categoryWhereInput
    /**
     * Limit how many categories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * category upsert
   */
  export type categoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * The filter to search for the category to update in case it exists.
     */
    where: categoryWhereUniqueInput
    /**
     * In case the category found by the `where` argument doesn't exist, create a new category with this data.
     */
    create: XOR<categoryCreateInput, categoryUncheckedCreateInput>
    /**
     * In case the category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<categoryUpdateInput, categoryUncheckedUpdateInput>
  }

  /**
   * category delete
   */
  export type categoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter which category to delete.
     */
    where: categoryWhereUniqueInput
  }

  /**
   * category deleteMany
   */
  export type categoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which categories to delete
     */
    where?: categoryWhereInput
    /**
     * Limit how many categories to delete.
     */
    limit?: number
  }

  /**
   * category.menu_item
   */
  export type category$menu_itemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu_item
     */
    select?: menu_itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the menu_item
     */
    omit?: menu_itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: menu_itemInclude<ExtArgs> | null
    where?: menu_itemWhereInput
    orderBy?: menu_itemOrderByWithRelationInput | menu_itemOrderByWithRelationInput[]
    cursor?: menu_itemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Menu_itemScalarFieldEnum | Menu_itemScalarFieldEnum[]
  }

  /**
   * category without action
   */
  export type categoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
  }


  /**
   * Model menu_item
   */

  export type AggregateMenu_item = {
    _count: Menu_itemCountAggregateOutputType | null
    _avg: Menu_itemAvgAggregateOutputType | null
    _sum: Menu_itemSumAggregateOutputType | null
    _min: Menu_itemMinAggregateOutputType | null
    _max: Menu_itemMaxAggregateOutputType | null
  }

  export type Menu_itemAvgAggregateOutputType = {
    likes: number | null
    price: number | null
    sold_count: number | null
  }

  export type Menu_itemSumAggregateOutputType = {
    likes: bigint | null
    price: bigint | null
    sold_count: bigint | null
  }

  export type Menu_itemMinAggregateOutputType = {
    id: string | null
    merchant_id: string | null
    category_id: string | null
    name_item: string | null
    likes: bigint | null
    price: bigint | null
    description: string | null
    sold_count: bigint | null
    status: boolean | null
  }

  export type Menu_itemMaxAggregateOutputType = {
    id: string | null
    merchant_id: string | null
    category_id: string | null
    name_item: string | null
    likes: bigint | null
    price: bigint | null
    description: string | null
    sold_count: bigint | null
    status: boolean | null
  }

  export type Menu_itemCountAggregateOutputType = {
    id: number
    merchant_id: number
    category_id: number
    name_item: number
    likes: number
    price: number
    description: number
    sold_count: number
    image_item: number
    status: number
    _all: number
  }


  export type Menu_itemAvgAggregateInputType = {
    likes?: true
    price?: true
    sold_count?: true
  }

  export type Menu_itemSumAggregateInputType = {
    likes?: true
    price?: true
    sold_count?: true
  }

  export type Menu_itemMinAggregateInputType = {
    id?: true
    merchant_id?: true
    category_id?: true
    name_item?: true
    likes?: true
    price?: true
    description?: true
    sold_count?: true
    status?: true
  }

  export type Menu_itemMaxAggregateInputType = {
    id?: true
    merchant_id?: true
    category_id?: true
    name_item?: true
    likes?: true
    price?: true
    description?: true
    sold_count?: true
    status?: true
  }

  export type Menu_itemCountAggregateInputType = {
    id?: true
    merchant_id?: true
    category_id?: true
    name_item?: true
    likes?: true
    price?: true
    description?: true
    sold_count?: true
    image_item?: true
    status?: true
    _all?: true
  }

  export type Menu_itemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which menu_item to aggregate.
     */
    where?: menu_itemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of menu_items to fetch.
     */
    orderBy?: menu_itemOrderByWithRelationInput | menu_itemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: menu_itemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` menu_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` menu_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned menu_items
    **/
    _count?: true | Menu_itemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Menu_itemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Menu_itemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Menu_itemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Menu_itemMaxAggregateInputType
  }

  export type GetMenu_itemAggregateType<T extends Menu_itemAggregateArgs> = {
        [P in keyof T & keyof AggregateMenu_item]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMenu_item[P]>
      : GetScalarType<T[P], AggregateMenu_item[P]>
  }




  export type menu_itemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: menu_itemWhereInput
    orderBy?: menu_itemOrderByWithAggregationInput | menu_itemOrderByWithAggregationInput[]
    by: Menu_itemScalarFieldEnum[] | Menu_itemScalarFieldEnum
    having?: menu_itemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Menu_itemCountAggregateInputType | true
    _avg?: Menu_itemAvgAggregateInputType
    _sum?: Menu_itemSumAggregateInputType
    _min?: Menu_itemMinAggregateInputType
    _max?: Menu_itemMaxAggregateInputType
  }

  export type Menu_itemGroupByOutputType = {
    id: string
    merchant_id: string
    category_id: string | null
    name_item: string
    likes: bigint
    price: bigint
    description: string | null
    sold_count: bigint
    image_item: JsonValue | null
    status: boolean
    _count: Menu_itemCountAggregateOutputType | null
    _avg: Menu_itemAvgAggregateOutputType | null
    _sum: Menu_itemSumAggregateOutputType | null
    _min: Menu_itemMinAggregateOutputType | null
    _max: Menu_itemMaxAggregateOutputType | null
  }

  type GetMenu_itemGroupByPayload<T extends menu_itemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Menu_itemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Menu_itemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Menu_itemGroupByOutputType[P]>
            : GetScalarType<T[P], Menu_itemGroupByOutputType[P]>
        }
      >
    >


  export type menu_itemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    merchant_id?: boolean
    category_id?: boolean
    name_item?: boolean
    likes?: boolean
    price?: boolean
    description?: boolean
    sold_count?: boolean
    image_item?: boolean
    status?: boolean
    category?: boolean | menu_item$categoryArgs<ExtArgs>
    merchant?: boolean | merchantDefaultArgs<ExtArgs>
    menu_item_option?: boolean | menu_item$menu_item_optionArgs<ExtArgs>
    order_items?: boolean | menu_item$order_itemsArgs<ExtArgs>
    _count?: boolean | Menu_itemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menu_item"]>

  export type menu_itemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    merchant_id?: boolean
    category_id?: boolean
    name_item?: boolean
    likes?: boolean
    price?: boolean
    description?: boolean
    sold_count?: boolean
    image_item?: boolean
    status?: boolean
    category?: boolean | menu_item$categoryArgs<ExtArgs>
    merchant?: boolean | merchantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menu_item"]>

  export type menu_itemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    merchant_id?: boolean
    category_id?: boolean
    name_item?: boolean
    likes?: boolean
    price?: boolean
    description?: boolean
    sold_count?: boolean
    image_item?: boolean
    status?: boolean
    category?: boolean | menu_item$categoryArgs<ExtArgs>
    merchant?: boolean | merchantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menu_item"]>

  export type menu_itemSelectScalar = {
    id?: boolean
    merchant_id?: boolean
    category_id?: boolean
    name_item?: boolean
    likes?: boolean
    price?: boolean
    description?: boolean
    sold_count?: boolean
    image_item?: boolean
    status?: boolean
  }

  export type menu_itemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "merchant_id" | "category_id" | "name_item" | "likes" | "price" | "description" | "sold_count" | "image_item" | "status", ExtArgs["result"]["menu_item"]>
  export type menu_itemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | menu_item$categoryArgs<ExtArgs>
    merchant?: boolean | merchantDefaultArgs<ExtArgs>
    menu_item_option?: boolean | menu_item$menu_item_optionArgs<ExtArgs>
    order_items?: boolean | menu_item$order_itemsArgs<ExtArgs>
    _count?: boolean | Menu_itemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type menu_itemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | menu_item$categoryArgs<ExtArgs>
    merchant?: boolean | merchantDefaultArgs<ExtArgs>
  }
  export type menu_itemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | menu_item$categoryArgs<ExtArgs>
    merchant?: boolean | merchantDefaultArgs<ExtArgs>
  }

  export type $menu_itemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "menu_item"
    objects: {
      category: Prisma.$categoryPayload<ExtArgs> | null
      merchant: Prisma.$merchantPayload<ExtArgs>
      menu_item_option: Prisma.$menu_item_optionPayload<ExtArgs>[]
      order_items: Prisma.$order_itemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      merchant_id: string
      category_id: string | null
      name_item: string
      likes: bigint
      price: bigint
      description: string | null
      sold_count: bigint
      image_item: Prisma.JsonValue | null
      status: boolean
    }, ExtArgs["result"]["menu_item"]>
    composites: {}
  }

  type menu_itemGetPayload<S extends boolean | null | undefined | menu_itemDefaultArgs> = $Result.GetResult<Prisma.$menu_itemPayload, S>

  type menu_itemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<menu_itemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Menu_itemCountAggregateInputType | true
    }

  export interface menu_itemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['menu_item'], meta: { name: 'menu_item' } }
    /**
     * Find zero or one Menu_item that matches the filter.
     * @param {menu_itemFindUniqueArgs} args - Arguments to find a Menu_item
     * @example
     * // Get one Menu_item
     * const menu_item = await prisma.menu_item.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends menu_itemFindUniqueArgs>(args: SelectSubset<T, menu_itemFindUniqueArgs<ExtArgs>>): Prisma__menu_itemClient<$Result.GetResult<Prisma.$menu_itemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Menu_item that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {menu_itemFindUniqueOrThrowArgs} args - Arguments to find a Menu_item
     * @example
     * // Get one Menu_item
     * const menu_item = await prisma.menu_item.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends menu_itemFindUniqueOrThrowArgs>(args: SelectSubset<T, menu_itemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__menu_itemClient<$Result.GetResult<Prisma.$menu_itemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Menu_item that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {menu_itemFindFirstArgs} args - Arguments to find a Menu_item
     * @example
     * // Get one Menu_item
     * const menu_item = await prisma.menu_item.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends menu_itemFindFirstArgs>(args?: SelectSubset<T, menu_itemFindFirstArgs<ExtArgs>>): Prisma__menu_itemClient<$Result.GetResult<Prisma.$menu_itemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Menu_item that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {menu_itemFindFirstOrThrowArgs} args - Arguments to find a Menu_item
     * @example
     * // Get one Menu_item
     * const menu_item = await prisma.menu_item.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends menu_itemFindFirstOrThrowArgs>(args?: SelectSubset<T, menu_itemFindFirstOrThrowArgs<ExtArgs>>): Prisma__menu_itemClient<$Result.GetResult<Prisma.$menu_itemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Menu_items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {menu_itemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Menu_items
     * const menu_items = await prisma.menu_item.findMany()
     * 
     * // Get first 10 Menu_items
     * const menu_items = await prisma.menu_item.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const menu_itemWithIdOnly = await prisma.menu_item.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends menu_itemFindManyArgs>(args?: SelectSubset<T, menu_itemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$menu_itemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Menu_item.
     * @param {menu_itemCreateArgs} args - Arguments to create a Menu_item.
     * @example
     * // Create one Menu_item
     * const Menu_item = await prisma.menu_item.create({
     *   data: {
     *     // ... data to create a Menu_item
     *   }
     * })
     * 
     */
    create<T extends menu_itemCreateArgs>(args: SelectSubset<T, menu_itemCreateArgs<ExtArgs>>): Prisma__menu_itemClient<$Result.GetResult<Prisma.$menu_itemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Menu_items.
     * @param {menu_itemCreateManyArgs} args - Arguments to create many Menu_items.
     * @example
     * // Create many Menu_items
     * const menu_item = await prisma.menu_item.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends menu_itemCreateManyArgs>(args?: SelectSubset<T, menu_itemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Menu_items and returns the data saved in the database.
     * @param {menu_itemCreateManyAndReturnArgs} args - Arguments to create many Menu_items.
     * @example
     * // Create many Menu_items
     * const menu_item = await prisma.menu_item.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Menu_items and only return the `id`
     * const menu_itemWithIdOnly = await prisma.menu_item.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends menu_itemCreateManyAndReturnArgs>(args?: SelectSubset<T, menu_itemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$menu_itemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Menu_item.
     * @param {menu_itemDeleteArgs} args - Arguments to delete one Menu_item.
     * @example
     * // Delete one Menu_item
     * const Menu_item = await prisma.menu_item.delete({
     *   where: {
     *     // ... filter to delete one Menu_item
     *   }
     * })
     * 
     */
    delete<T extends menu_itemDeleteArgs>(args: SelectSubset<T, menu_itemDeleteArgs<ExtArgs>>): Prisma__menu_itemClient<$Result.GetResult<Prisma.$menu_itemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Menu_item.
     * @param {menu_itemUpdateArgs} args - Arguments to update one Menu_item.
     * @example
     * // Update one Menu_item
     * const menu_item = await prisma.menu_item.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends menu_itemUpdateArgs>(args: SelectSubset<T, menu_itemUpdateArgs<ExtArgs>>): Prisma__menu_itemClient<$Result.GetResult<Prisma.$menu_itemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Menu_items.
     * @param {menu_itemDeleteManyArgs} args - Arguments to filter Menu_items to delete.
     * @example
     * // Delete a few Menu_items
     * const { count } = await prisma.menu_item.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends menu_itemDeleteManyArgs>(args?: SelectSubset<T, menu_itemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Menu_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {menu_itemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Menu_items
     * const menu_item = await prisma.menu_item.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends menu_itemUpdateManyArgs>(args: SelectSubset<T, menu_itemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Menu_items and returns the data updated in the database.
     * @param {menu_itemUpdateManyAndReturnArgs} args - Arguments to update many Menu_items.
     * @example
     * // Update many Menu_items
     * const menu_item = await prisma.menu_item.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Menu_items and only return the `id`
     * const menu_itemWithIdOnly = await prisma.menu_item.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends menu_itemUpdateManyAndReturnArgs>(args: SelectSubset<T, menu_itemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$menu_itemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Menu_item.
     * @param {menu_itemUpsertArgs} args - Arguments to update or create a Menu_item.
     * @example
     * // Update or create a Menu_item
     * const menu_item = await prisma.menu_item.upsert({
     *   create: {
     *     // ... data to create a Menu_item
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Menu_item we want to update
     *   }
     * })
     */
    upsert<T extends menu_itemUpsertArgs>(args: SelectSubset<T, menu_itemUpsertArgs<ExtArgs>>): Prisma__menu_itemClient<$Result.GetResult<Prisma.$menu_itemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Menu_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {menu_itemCountArgs} args - Arguments to filter Menu_items to count.
     * @example
     * // Count the number of Menu_items
     * const count = await prisma.menu_item.count({
     *   where: {
     *     // ... the filter for the Menu_items we want to count
     *   }
     * })
    **/
    count<T extends menu_itemCountArgs>(
      args?: Subset<T, menu_itemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Menu_itemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Menu_item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Menu_itemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Menu_itemAggregateArgs>(args: Subset<T, Menu_itemAggregateArgs>): Prisma.PrismaPromise<GetMenu_itemAggregateType<T>>

    /**
     * Group by Menu_item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {menu_itemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends menu_itemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: menu_itemGroupByArgs['orderBy'] }
        : { orderBy?: menu_itemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, menu_itemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMenu_itemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the menu_item model
   */
  readonly fields: menu_itemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for menu_item.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__menu_itemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends menu_item$categoryArgs<ExtArgs> = {}>(args?: Subset<T, menu_item$categoryArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    merchant<T extends merchantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, merchantDefaultArgs<ExtArgs>>): Prisma__merchantClient<$Result.GetResult<Prisma.$merchantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    menu_item_option<T extends menu_item$menu_item_optionArgs<ExtArgs> = {}>(args?: Subset<T, menu_item$menu_item_optionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$menu_item_optionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    order_items<T extends menu_item$order_itemsArgs<ExtArgs> = {}>(args?: Subset<T, menu_item$order_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$order_itemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the menu_item model
   */
  interface menu_itemFieldRefs {
    readonly id: FieldRef<"menu_item", 'String'>
    readonly merchant_id: FieldRef<"menu_item", 'String'>
    readonly category_id: FieldRef<"menu_item", 'String'>
    readonly name_item: FieldRef<"menu_item", 'String'>
    readonly likes: FieldRef<"menu_item", 'BigInt'>
    readonly price: FieldRef<"menu_item", 'BigInt'>
    readonly description: FieldRef<"menu_item", 'String'>
    readonly sold_count: FieldRef<"menu_item", 'BigInt'>
    readonly image_item: FieldRef<"menu_item", 'Json'>
    readonly status: FieldRef<"menu_item", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * menu_item findUnique
   */
  export type menu_itemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu_item
     */
    select?: menu_itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the menu_item
     */
    omit?: menu_itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: menu_itemInclude<ExtArgs> | null
    /**
     * Filter, which menu_item to fetch.
     */
    where: menu_itemWhereUniqueInput
  }

  /**
   * menu_item findUniqueOrThrow
   */
  export type menu_itemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu_item
     */
    select?: menu_itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the menu_item
     */
    omit?: menu_itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: menu_itemInclude<ExtArgs> | null
    /**
     * Filter, which menu_item to fetch.
     */
    where: menu_itemWhereUniqueInput
  }

  /**
   * menu_item findFirst
   */
  export type menu_itemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu_item
     */
    select?: menu_itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the menu_item
     */
    omit?: menu_itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: menu_itemInclude<ExtArgs> | null
    /**
     * Filter, which menu_item to fetch.
     */
    where?: menu_itemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of menu_items to fetch.
     */
    orderBy?: menu_itemOrderByWithRelationInput | menu_itemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for menu_items.
     */
    cursor?: menu_itemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` menu_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` menu_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of menu_items.
     */
    distinct?: Menu_itemScalarFieldEnum | Menu_itemScalarFieldEnum[]
  }

  /**
   * menu_item findFirstOrThrow
   */
  export type menu_itemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu_item
     */
    select?: menu_itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the menu_item
     */
    omit?: menu_itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: menu_itemInclude<ExtArgs> | null
    /**
     * Filter, which menu_item to fetch.
     */
    where?: menu_itemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of menu_items to fetch.
     */
    orderBy?: menu_itemOrderByWithRelationInput | menu_itemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for menu_items.
     */
    cursor?: menu_itemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` menu_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` menu_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of menu_items.
     */
    distinct?: Menu_itemScalarFieldEnum | Menu_itemScalarFieldEnum[]
  }

  /**
   * menu_item findMany
   */
  export type menu_itemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu_item
     */
    select?: menu_itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the menu_item
     */
    omit?: menu_itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: menu_itemInclude<ExtArgs> | null
    /**
     * Filter, which menu_items to fetch.
     */
    where?: menu_itemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of menu_items to fetch.
     */
    orderBy?: menu_itemOrderByWithRelationInput | menu_itemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing menu_items.
     */
    cursor?: menu_itemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` menu_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` menu_items.
     */
    skip?: number
    distinct?: Menu_itemScalarFieldEnum | Menu_itemScalarFieldEnum[]
  }

  /**
   * menu_item create
   */
  export type menu_itemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu_item
     */
    select?: menu_itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the menu_item
     */
    omit?: menu_itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: menu_itemInclude<ExtArgs> | null
    /**
     * The data needed to create a menu_item.
     */
    data: XOR<menu_itemCreateInput, menu_itemUncheckedCreateInput>
  }

  /**
   * menu_item createMany
   */
  export type menu_itemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many menu_items.
     */
    data: menu_itemCreateManyInput | menu_itemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * menu_item createManyAndReturn
   */
  export type menu_itemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu_item
     */
    select?: menu_itemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the menu_item
     */
    omit?: menu_itemOmit<ExtArgs> | null
    /**
     * The data used to create many menu_items.
     */
    data: menu_itemCreateManyInput | menu_itemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: menu_itemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * menu_item update
   */
  export type menu_itemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu_item
     */
    select?: menu_itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the menu_item
     */
    omit?: menu_itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: menu_itemInclude<ExtArgs> | null
    /**
     * The data needed to update a menu_item.
     */
    data: XOR<menu_itemUpdateInput, menu_itemUncheckedUpdateInput>
    /**
     * Choose, which menu_item to update.
     */
    where: menu_itemWhereUniqueInput
  }

  /**
   * menu_item updateMany
   */
  export type menu_itemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update menu_items.
     */
    data: XOR<menu_itemUpdateManyMutationInput, menu_itemUncheckedUpdateManyInput>
    /**
     * Filter which menu_items to update
     */
    where?: menu_itemWhereInput
    /**
     * Limit how many menu_items to update.
     */
    limit?: number
  }

  /**
   * menu_item updateManyAndReturn
   */
  export type menu_itemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu_item
     */
    select?: menu_itemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the menu_item
     */
    omit?: menu_itemOmit<ExtArgs> | null
    /**
     * The data used to update menu_items.
     */
    data: XOR<menu_itemUpdateManyMutationInput, menu_itemUncheckedUpdateManyInput>
    /**
     * Filter which menu_items to update
     */
    where?: menu_itemWhereInput
    /**
     * Limit how many menu_items to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: menu_itemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * menu_item upsert
   */
  export type menu_itemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu_item
     */
    select?: menu_itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the menu_item
     */
    omit?: menu_itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: menu_itemInclude<ExtArgs> | null
    /**
     * The filter to search for the menu_item to update in case it exists.
     */
    where: menu_itemWhereUniqueInput
    /**
     * In case the menu_item found by the `where` argument doesn't exist, create a new menu_item with this data.
     */
    create: XOR<menu_itemCreateInput, menu_itemUncheckedCreateInput>
    /**
     * In case the menu_item was found with the provided `where` argument, update it with this data.
     */
    update: XOR<menu_itemUpdateInput, menu_itemUncheckedUpdateInput>
  }

  /**
   * menu_item delete
   */
  export type menu_itemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu_item
     */
    select?: menu_itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the menu_item
     */
    omit?: menu_itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: menu_itemInclude<ExtArgs> | null
    /**
     * Filter which menu_item to delete.
     */
    where: menu_itemWhereUniqueInput
  }

  /**
   * menu_item deleteMany
   */
  export type menu_itemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which menu_items to delete
     */
    where?: menu_itemWhereInput
    /**
     * Limit how many menu_items to delete.
     */
    limit?: number
  }

  /**
   * menu_item.category
   */
  export type menu_item$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    where?: categoryWhereInput
  }

  /**
   * menu_item.menu_item_option
   */
  export type menu_item$menu_item_optionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu_item_option
     */
    select?: menu_item_optionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the menu_item_option
     */
    omit?: menu_item_optionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: menu_item_optionInclude<ExtArgs> | null
    where?: menu_item_optionWhereInput
    orderBy?: menu_item_optionOrderByWithRelationInput | menu_item_optionOrderByWithRelationInput[]
    cursor?: menu_item_optionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Menu_item_optionScalarFieldEnum | Menu_item_optionScalarFieldEnum[]
  }

  /**
   * menu_item.order_items
   */
  export type menu_item$order_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_item
     */
    select?: order_itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_item
     */
    omit?: order_itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_itemInclude<ExtArgs> | null
    where?: order_itemWhereInput
    orderBy?: order_itemOrderByWithRelationInput | order_itemOrderByWithRelationInput[]
    cursor?: order_itemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Order_itemScalarFieldEnum | Order_itemScalarFieldEnum[]
  }

  /**
   * menu_item without action
   */
  export type menu_itemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu_item
     */
    select?: menu_itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the menu_item
     */
    omit?: menu_itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: menu_itemInclude<ExtArgs> | null
  }


  /**
   * Model option
   */

  export type AggregateOption = {
    _count: OptionCountAggregateOutputType | null
    _avg: OptionAvgAggregateOutputType | null
    _sum: OptionSumAggregateOutputType | null
    _min: OptionMinAggregateOutputType | null
    _max: OptionMaxAggregateOutputType | null
  }

  export type OptionAvgAggregateOutputType = {
    number_select: number | null
  }

  export type OptionSumAggregateOutputType = {
    number_select: bigint | null
  }

  export type OptionMinAggregateOutputType = {
    id: string | null
    merchant_id: string | null
    option_name: string | null
    multi_select: boolean | null
    require_select: boolean | null
    number_select: bigint | null
  }

  export type OptionMaxAggregateOutputType = {
    id: string | null
    merchant_id: string | null
    option_name: string | null
    multi_select: boolean | null
    require_select: boolean | null
    number_select: bigint | null
  }

  export type OptionCountAggregateOutputType = {
    id: number
    merchant_id: number
    option_name: number
    multi_select: number
    require_select: number
    number_select: number
    _all: number
  }


  export type OptionAvgAggregateInputType = {
    number_select?: true
  }

  export type OptionSumAggregateInputType = {
    number_select?: true
  }

  export type OptionMinAggregateInputType = {
    id?: true
    merchant_id?: true
    option_name?: true
    multi_select?: true
    require_select?: true
    number_select?: true
  }

  export type OptionMaxAggregateInputType = {
    id?: true
    merchant_id?: true
    option_name?: true
    multi_select?: true
    require_select?: true
    number_select?: true
  }

  export type OptionCountAggregateInputType = {
    id?: true
    merchant_id?: true
    option_name?: true
    multi_select?: true
    require_select?: true
    number_select?: true
    _all?: true
  }

  export type OptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which option to aggregate.
     */
    where?: optionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of options to fetch.
     */
    orderBy?: optionOrderByWithRelationInput | optionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: optionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` options from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` options.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned options
    **/
    _count?: true | OptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OptionMaxAggregateInputType
  }

  export type GetOptionAggregateType<T extends OptionAggregateArgs> = {
        [P in keyof T & keyof AggregateOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOption[P]>
      : GetScalarType<T[P], AggregateOption[P]>
  }




  export type optionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: optionWhereInput
    orderBy?: optionOrderByWithAggregationInput | optionOrderByWithAggregationInput[]
    by: OptionScalarFieldEnum[] | OptionScalarFieldEnum
    having?: optionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OptionCountAggregateInputType | true
    _avg?: OptionAvgAggregateInputType
    _sum?: OptionSumAggregateInputType
    _min?: OptionMinAggregateInputType
    _max?: OptionMaxAggregateInputType
  }

  export type OptionGroupByOutputType = {
    id: string
    merchant_id: string
    option_name: string
    multi_select: boolean
    require_select: boolean
    number_select: bigint
    _count: OptionCountAggregateOutputType | null
    _avg: OptionAvgAggregateOutputType | null
    _sum: OptionSumAggregateOutputType | null
    _min: OptionMinAggregateOutputType | null
    _max: OptionMaxAggregateOutputType | null
  }

  type GetOptionGroupByPayload<T extends optionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OptionGroupByOutputType[P]>
            : GetScalarType<T[P], OptionGroupByOutputType[P]>
        }
      >
    >


  export type optionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    merchant_id?: boolean
    option_name?: boolean
    multi_select?: boolean
    require_select?: boolean
    number_select?: boolean
    menu_item_option?: boolean | option$menu_item_optionArgs<ExtArgs>
    merchant?: boolean | merchantDefaultArgs<ExtArgs>
    option_item?: boolean | option$option_itemArgs<ExtArgs>
    _count?: boolean | OptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["option"]>

  export type optionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    merchant_id?: boolean
    option_name?: boolean
    multi_select?: boolean
    require_select?: boolean
    number_select?: boolean
    merchant?: boolean | merchantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["option"]>

  export type optionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    merchant_id?: boolean
    option_name?: boolean
    multi_select?: boolean
    require_select?: boolean
    number_select?: boolean
    merchant?: boolean | merchantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["option"]>

  export type optionSelectScalar = {
    id?: boolean
    merchant_id?: boolean
    option_name?: boolean
    multi_select?: boolean
    require_select?: boolean
    number_select?: boolean
  }

  export type optionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "merchant_id" | "option_name" | "multi_select" | "require_select" | "number_select", ExtArgs["result"]["option"]>
  export type optionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    menu_item_option?: boolean | option$menu_item_optionArgs<ExtArgs>
    merchant?: boolean | merchantDefaultArgs<ExtArgs>
    option_item?: boolean | option$option_itemArgs<ExtArgs>
    _count?: boolean | OptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type optionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    merchant?: boolean | merchantDefaultArgs<ExtArgs>
  }
  export type optionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    merchant?: boolean | merchantDefaultArgs<ExtArgs>
  }

  export type $optionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "option"
    objects: {
      menu_item_option: Prisma.$menu_item_optionPayload<ExtArgs>[]
      merchant: Prisma.$merchantPayload<ExtArgs>
      option_item: Prisma.$option_itemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      merchant_id: string
      option_name: string
      multi_select: boolean
      require_select: boolean
      number_select: bigint
    }, ExtArgs["result"]["option"]>
    composites: {}
  }

  type optionGetPayload<S extends boolean | null | undefined | optionDefaultArgs> = $Result.GetResult<Prisma.$optionPayload, S>

  type optionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<optionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OptionCountAggregateInputType | true
    }

  export interface optionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['option'], meta: { name: 'option' } }
    /**
     * Find zero or one Option that matches the filter.
     * @param {optionFindUniqueArgs} args - Arguments to find a Option
     * @example
     * // Get one Option
     * const option = await prisma.option.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends optionFindUniqueArgs>(args: SelectSubset<T, optionFindUniqueArgs<ExtArgs>>): Prisma__optionClient<$Result.GetResult<Prisma.$optionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Option that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {optionFindUniqueOrThrowArgs} args - Arguments to find a Option
     * @example
     * // Get one Option
     * const option = await prisma.option.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends optionFindUniqueOrThrowArgs>(args: SelectSubset<T, optionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__optionClient<$Result.GetResult<Prisma.$optionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Option that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {optionFindFirstArgs} args - Arguments to find a Option
     * @example
     * // Get one Option
     * const option = await prisma.option.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends optionFindFirstArgs>(args?: SelectSubset<T, optionFindFirstArgs<ExtArgs>>): Prisma__optionClient<$Result.GetResult<Prisma.$optionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Option that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {optionFindFirstOrThrowArgs} args - Arguments to find a Option
     * @example
     * // Get one Option
     * const option = await prisma.option.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends optionFindFirstOrThrowArgs>(args?: SelectSubset<T, optionFindFirstOrThrowArgs<ExtArgs>>): Prisma__optionClient<$Result.GetResult<Prisma.$optionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Options that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {optionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Options
     * const options = await prisma.option.findMany()
     * 
     * // Get first 10 Options
     * const options = await prisma.option.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const optionWithIdOnly = await prisma.option.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends optionFindManyArgs>(args?: SelectSubset<T, optionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$optionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Option.
     * @param {optionCreateArgs} args - Arguments to create a Option.
     * @example
     * // Create one Option
     * const Option = await prisma.option.create({
     *   data: {
     *     // ... data to create a Option
     *   }
     * })
     * 
     */
    create<T extends optionCreateArgs>(args: SelectSubset<T, optionCreateArgs<ExtArgs>>): Prisma__optionClient<$Result.GetResult<Prisma.$optionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Options.
     * @param {optionCreateManyArgs} args - Arguments to create many Options.
     * @example
     * // Create many Options
     * const option = await prisma.option.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends optionCreateManyArgs>(args?: SelectSubset<T, optionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Options and returns the data saved in the database.
     * @param {optionCreateManyAndReturnArgs} args - Arguments to create many Options.
     * @example
     * // Create many Options
     * const option = await prisma.option.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Options and only return the `id`
     * const optionWithIdOnly = await prisma.option.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends optionCreateManyAndReturnArgs>(args?: SelectSubset<T, optionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$optionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Option.
     * @param {optionDeleteArgs} args - Arguments to delete one Option.
     * @example
     * // Delete one Option
     * const Option = await prisma.option.delete({
     *   where: {
     *     // ... filter to delete one Option
     *   }
     * })
     * 
     */
    delete<T extends optionDeleteArgs>(args: SelectSubset<T, optionDeleteArgs<ExtArgs>>): Prisma__optionClient<$Result.GetResult<Prisma.$optionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Option.
     * @param {optionUpdateArgs} args - Arguments to update one Option.
     * @example
     * // Update one Option
     * const option = await prisma.option.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends optionUpdateArgs>(args: SelectSubset<T, optionUpdateArgs<ExtArgs>>): Prisma__optionClient<$Result.GetResult<Prisma.$optionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Options.
     * @param {optionDeleteManyArgs} args - Arguments to filter Options to delete.
     * @example
     * // Delete a few Options
     * const { count } = await prisma.option.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends optionDeleteManyArgs>(args?: SelectSubset<T, optionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Options.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {optionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Options
     * const option = await prisma.option.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends optionUpdateManyArgs>(args: SelectSubset<T, optionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Options and returns the data updated in the database.
     * @param {optionUpdateManyAndReturnArgs} args - Arguments to update many Options.
     * @example
     * // Update many Options
     * const option = await prisma.option.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Options and only return the `id`
     * const optionWithIdOnly = await prisma.option.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends optionUpdateManyAndReturnArgs>(args: SelectSubset<T, optionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$optionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Option.
     * @param {optionUpsertArgs} args - Arguments to update or create a Option.
     * @example
     * // Update or create a Option
     * const option = await prisma.option.upsert({
     *   create: {
     *     // ... data to create a Option
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Option we want to update
     *   }
     * })
     */
    upsert<T extends optionUpsertArgs>(args: SelectSubset<T, optionUpsertArgs<ExtArgs>>): Prisma__optionClient<$Result.GetResult<Prisma.$optionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Options.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {optionCountArgs} args - Arguments to filter Options to count.
     * @example
     * // Count the number of Options
     * const count = await prisma.option.count({
     *   where: {
     *     // ... the filter for the Options we want to count
     *   }
     * })
    **/
    count<T extends optionCountArgs>(
      args?: Subset<T, optionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Option.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OptionAggregateArgs>(args: Subset<T, OptionAggregateArgs>): Prisma.PrismaPromise<GetOptionAggregateType<T>>

    /**
     * Group by Option.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {optionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends optionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: optionGroupByArgs['orderBy'] }
        : { orderBy?: optionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, optionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the option model
   */
  readonly fields: optionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for option.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__optionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    menu_item_option<T extends option$menu_item_optionArgs<ExtArgs> = {}>(args?: Subset<T, option$menu_item_optionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$menu_item_optionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    merchant<T extends merchantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, merchantDefaultArgs<ExtArgs>>): Prisma__merchantClient<$Result.GetResult<Prisma.$merchantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    option_item<T extends option$option_itemArgs<ExtArgs> = {}>(args?: Subset<T, option$option_itemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$option_itemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the option model
   */
  interface optionFieldRefs {
    readonly id: FieldRef<"option", 'String'>
    readonly merchant_id: FieldRef<"option", 'String'>
    readonly option_name: FieldRef<"option", 'String'>
    readonly multi_select: FieldRef<"option", 'Boolean'>
    readonly require_select: FieldRef<"option", 'Boolean'>
    readonly number_select: FieldRef<"option", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * option findUnique
   */
  export type optionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the option
     */
    select?: optionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the option
     */
    omit?: optionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: optionInclude<ExtArgs> | null
    /**
     * Filter, which option to fetch.
     */
    where: optionWhereUniqueInput
  }

  /**
   * option findUniqueOrThrow
   */
  export type optionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the option
     */
    select?: optionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the option
     */
    omit?: optionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: optionInclude<ExtArgs> | null
    /**
     * Filter, which option to fetch.
     */
    where: optionWhereUniqueInput
  }

  /**
   * option findFirst
   */
  export type optionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the option
     */
    select?: optionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the option
     */
    omit?: optionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: optionInclude<ExtArgs> | null
    /**
     * Filter, which option to fetch.
     */
    where?: optionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of options to fetch.
     */
    orderBy?: optionOrderByWithRelationInput | optionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for options.
     */
    cursor?: optionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` options from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` options.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of options.
     */
    distinct?: OptionScalarFieldEnum | OptionScalarFieldEnum[]
  }

  /**
   * option findFirstOrThrow
   */
  export type optionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the option
     */
    select?: optionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the option
     */
    omit?: optionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: optionInclude<ExtArgs> | null
    /**
     * Filter, which option to fetch.
     */
    where?: optionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of options to fetch.
     */
    orderBy?: optionOrderByWithRelationInput | optionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for options.
     */
    cursor?: optionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` options from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` options.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of options.
     */
    distinct?: OptionScalarFieldEnum | OptionScalarFieldEnum[]
  }

  /**
   * option findMany
   */
  export type optionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the option
     */
    select?: optionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the option
     */
    omit?: optionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: optionInclude<ExtArgs> | null
    /**
     * Filter, which options to fetch.
     */
    where?: optionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of options to fetch.
     */
    orderBy?: optionOrderByWithRelationInput | optionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing options.
     */
    cursor?: optionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` options from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` options.
     */
    skip?: number
    distinct?: OptionScalarFieldEnum | OptionScalarFieldEnum[]
  }

  /**
   * option create
   */
  export type optionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the option
     */
    select?: optionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the option
     */
    omit?: optionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: optionInclude<ExtArgs> | null
    /**
     * The data needed to create a option.
     */
    data: XOR<optionCreateInput, optionUncheckedCreateInput>
  }

  /**
   * option createMany
   */
  export type optionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many options.
     */
    data: optionCreateManyInput | optionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * option createManyAndReturn
   */
  export type optionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the option
     */
    select?: optionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the option
     */
    omit?: optionOmit<ExtArgs> | null
    /**
     * The data used to create many options.
     */
    data: optionCreateManyInput | optionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: optionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * option update
   */
  export type optionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the option
     */
    select?: optionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the option
     */
    omit?: optionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: optionInclude<ExtArgs> | null
    /**
     * The data needed to update a option.
     */
    data: XOR<optionUpdateInput, optionUncheckedUpdateInput>
    /**
     * Choose, which option to update.
     */
    where: optionWhereUniqueInput
  }

  /**
   * option updateMany
   */
  export type optionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update options.
     */
    data: XOR<optionUpdateManyMutationInput, optionUncheckedUpdateManyInput>
    /**
     * Filter which options to update
     */
    where?: optionWhereInput
    /**
     * Limit how many options to update.
     */
    limit?: number
  }

  /**
   * option updateManyAndReturn
   */
  export type optionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the option
     */
    select?: optionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the option
     */
    omit?: optionOmit<ExtArgs> | null
    /**
     * The data used to update options.
     */
    data: XOR<optionUpdateManyMutationInput, optionUncheckedUpdateManyInput>
    /**
     * Filter which options to update
     */
    where?: optionWhereInput
    /**
     * Limit how many options to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: optionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * option upsert
   */
  export type optionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the option
     */
    select?: optionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the option
     */
    omit?: optionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: optionInclude<ExtArgs> | null
    /**
     * The filter to search for the option to update in case it exists.
     */
    where: optionWhereUniqueInput
    /**
     * In case the option found by the `where` argument doesn't exist, create a new option with this data.
     */
    create: XOR<optionCreateInput, optionUncheckedCreateInput>
    /**
     * In case the option was found with the provided `where` argument, update it with this data.
     */
    update: XOR<optionUpdateInput, optionUncheckedUpdateInput>
  }

  /**
   * option delete
   */
  export type optionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the option
     */
    select?: optionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the option
     */
    omit?: optionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: optionInclude<ExtArgs> | null
    /**
     * Filter which option to delete.
     */
    where: optionWhereUniqueInput
  }

  /**
   * option deleteMany
   */
  export type optionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which options to delete
     */
    where?: optionWhereInput
    /**
     * Limit how many options to delete.
     */
    limit?: number
  }

  /**
   * option.menu_item_option
   */
  export type option$menu_item_optionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu_item_option
     */
    select?: menu_item_optionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the menu_item_option
     */
    omit?: menu_item_optionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: menu_item_optionInclude<ExtArgs> | null
    where?: menu_item_optionWhereInput
    orderBy?: menu_item_optionOrderByWithRelationInput | menu_item_optionOrderByWithRelationInput[]
    cursor?: menu_item_optionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Menu_item_optionScalarFieldEnum | Menu_item_optionScalarFieldEnum[]
  }

  /**
   * option.option_item
   */
  export type option$option_itemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the option_item
     */
    select?: option_itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the option_item
     */
    omit?: option_itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: option_itemInclude<ExtArgs> | null
    where?: option_itemWhereInput
    orderBy?: option_itemOrderByWithRelationInput | option_itemOrderByWithRelationInput[]
    cursor?: option_itemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Option_itemScalarFieldEnum | Option_itemScalarFieldEnum[]
  }

  /**
   * option without action
   */
  export type optionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the option
     */
    select?: optionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the option
     */
    omit?: optionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: optionInclude<ExtArgs> | null
  }


  /**
   * Model option_item
   */

  export type AggregateOption_item = {
    _count: Option_itemCountAggregateOutputType | null
    _min: Option_itemMinAggregateOutputType | null
    _max: Option_itemMaxAggregateOutputType | null
  }

  export type Option_itemMinAggregateOutputType = {
    id: string | null
    option_id: string | null
    option_item_name: string | null
    status: boolean | null
    status_select: boolean | null
  }

  export type Option_itemMaxAggregateOutputType = {
    id: string | null
    option_id: string | null
    option_item_name: string | null
    status: boolean | null
    status_select: boolean | null
  }

  export type Option_itemCountAggregateOutputType = {
    id: number
    option_id: number
    option_item_name: number
    status: number
    status_select: number
    _all: number
  }


  export type Option_itemMinAggregateInputType = {
    id?: true
    option_id?: true
    option_item_name?: true
    status?: true
    status_select?: true
  }

  export type Option_itemMaxAggregateInputType = {
    id?: true
    option_id?: true
    option_item_name?: true
    status?: true
    status_select?: true
  }

  export type Option_itemCountAggregateInputType = {
    id?: true
    option_id?: true
    option_item_name?: true
    status?: true
    status_select?: true
    _all?: true
  }

  export type Option_itemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which option_item to aggregate.
     */
    where?: option_itemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of option_items to fetch.
     */
    orderBy?: option_itemOrderByWithRelationInput | option_itemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: option_itemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` option_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` option_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned option_items
    **/
    _count?: true | Option_itemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Option_itemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Option_itemMaxAggregateInputType
  }

  export type GetOption_itemAggregateType<T extends Option_itemAggregateArgs> = {
        [P in keyof T & keyof AggregateOption_item]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOption_item[P]>
      : GetScalarType<T[P], AggregateOption_item[P]>
  }




  export type option_itemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: option_itemWhereInput
    orderBy?: option_itemOrderByWithAggregationInput | option_itemOrderByWithAggregationInput[]
    by: Option_itemScalarFieldEnum[] | Option_itemScalarFieldEnum
    having?: option_itemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Option_itemCountAggregateInputType | true
    _min?: Option_itemMinAggregateInputType
    _max?: Option_itemMaxAggregateInputType
  }

  export type Option_itemGroupByOutputType = {
    id: string
    option_id: string
    option_item_name: string
    status: boolean
    status_select: boolean
    _count: Option_itemCountAggregateOutputType | null
    _min: Option_itemMinAggregateOutputType | null
    _max: Option_itemMaxAggregateOutputType | null
  }

  type GetOption_itemGroupByPayload<T extends option_itemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Option_itemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Option_itemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Option_itemGroupByOutputType[P]>
            : GetScalarType<T[P], Option_itemGroupByOutputType[P]>
        }
      >
    >


  export type option_itemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    option_id?: boolean
    option_item_name?: boolean
    status?: boolean
    status_select?: boolean
    option?: boolean | optionDefaultArgs<ExtArgs>
    order_item_options?: boolean | option_item$order_item_optionsArgs<ExtArgs>
    _count?: boolean | Option_itemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["option_item"]>

  export type option_itemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    option_id?: boolean
    option_item_name?: boolean
    status?: boolean
    status_select?: boolean
    option?: boolean | optionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["option_item"]>

  export type option_itemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    option_id?: boolean
    option_item_name?: boolean
    status?: boolean
    status_select?: boolean
    option?: boolean | optionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["option_item"]>

  export type option_itemSelectScalar = {
    id?: boolean
    option_id?: boolean
    option_item_name?: boolean
    status?: boolean
    status_select?: boolean
  }

  export type option_itemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "option_id" | "option_item_name" | "status" | "status_select", ExtArgs["result"]["option_item"]>
  export type option_itemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    option?: boolean | optionDefaultArgs<ExtArgs>
    order_item_options?: boolean | option_item$order_item_optionsArgs<ExtArgs>
    _count?: boolean | Option_itemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type option_itemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    option?: boolean | optionDefaultArgs<ExtArgs>
  }
  export type option_itemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    option?: boolean | optionDefaultArgs<ExtArgs>
  }

  export type $option_itemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "option_item"
    objects: {
      option: Prisma.$optionPayload<ExtArgs>
      order_item_options: Prisma.$order_item_optionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      option_id: string
      option_item_name: string
      status: boolean
      status_select: boolean
    }, ExtArgs["result"]["option_item"]>
    composites: {}
  }

  type option_itemGetPayload<S extends boolean | null | undefined | option_itemDefaultArgs> = $Result.GetResult<Prisma.$option_itemPayload, S>

  type option_itemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<option_itemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Option_itemCountAggregateInputType | true
    }

  export interface option_itemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['option_item'], meta: { name: 'option_item' } }
    /**
     * Find zero or one Option_item that matches the filter.
     * @param {option_itemFindUniqueArgs} args - Arguments to find a Option_item
     * @example
     * // Get one Option_item
     * const option_item = await prisma.option_item.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends option_itemFindUniqueArgs>(args: SelectSubset<T, option_itemFindUniqueArgs<ExtArgs>>): Prisma__option_itemClient<$Result.GetResult<Prisma.$option_itemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Option_item that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {option_itemFindUniqueOrThrowArgs} args - Arguments to find a Option_item
     * @example
     * // Get one Option_item
     * const option_item = await prisma.option_item.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends option_itemFindUniqueOrThrowArgs>(args: SelectSubset<T, option_itemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__option_itemClient<$Result.GetResult<Prisma.$option_itemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Option_item that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {option_itemFindFirstArgs} args - Arguments to find a Option_item
     * @example
     * // Get one Option_item
     * const option_item = await prisma.option_item.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends option_itemFindFirstArgs>(args?: SelectSubset<T, option_itemFindFirstArgs<ExtArgs>>): Prisma__option_itemClient<$Result.GetResult<Prisma.$option_itemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Option_item that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {option_itemFindFirstOrThrowArgs} args - Arguments to find a Option_item
     * @example
     * // Get one Option_item
     * const option_item = await prisma.option_item.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends option_itemFindFirstOrThrowArgs>(args?: SelectSubset<T, option_itemFindFirstOrThrowArgs<ExtArgs>>): Prisma__option_itemClient<$Result.GetResult<Prisma.$option_itemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Option_items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {option_itemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Option_items
     * const option_items = await prisma.option_item.findMany()
     * 
     * // Get first 10 Option_items
     * const option_items = await prisma.option_item.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const option_itemWithIdOnly = await prisma.option_item.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends option_itemFindManyArgs>(args?: SelectSubset<T, option_itemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$option_itemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Option_item.
     * @param {option_itemCreateArgs} args - Arguments to create a Option_item.
     * @example
     * // Create one Option_item
     * const Option_item = await prisma.option_item.create({
     *   data: {
     *     // ... data to create a Option_item
     *   }
     * })
     * 
     */
    create<T extends option_itemCreateArgs>(args: SelectSubset<T, option_itemCreateArgs<ExtArgs>>): Prisma__option_itemClient<$Result.GetResult<Prisma.$option_itemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Option_items.
     * @param {option_itemCreateManyArgs} args - Arguments to create many Option_items.
     * @example
     * // Create many Option_items
     * const option_item = await prisma.option_item.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends option_itemCreateManyArgs>(args?: SelectSubset<T, option_itemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Option_items and returns the data saved in the database.
     * @param {option_itemCreateManyAndReturnArgs} args - Arguments to create many Option_items.
     * @example
     * // Create many Option_items
     * const option_item = await prisma.option_item.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Option_items and only return the `id`
     * const option_itemWithIdOnly = await prisma.option_item.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends option_itemCreateManyAndReturnArgs>(args?: SelectSubset<T, option_itemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$option_itemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Option_item.
     * @param {option_itemDeleteArgs} args - Arguments to delete one Option_item.
     * @example
     * // Delete one Option_item
     * const Option_item = await prisma.option_item.delete({
     *   where: {
     *     // ... filter to delete one Option_item
     *   }
     * })
     * 
     */
    delete<T extends option_itemDeleteArgs>(args: SelectSubset<T, option_itemDeleteArgs<ExtArgs>>): Prisma__option_itemClient<$Result.GetResult<Prisma.$option_itemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Option_item.
     * @param {option_itemUpdateArgs} args - Arguments to update one Option_item.
     * @example
     * // Update one Option_item
     * const option_item = await prisma.option_item.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends option_itemUpdateArgs>(args: SelectSubset<T, option_itemUpdateArgs<ExtArgs>>): Prisma__option_itemClient<$Result.GetResult<Prisma.$option_itemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Option_items.
     * @param {option_itemDeleteManyArgs} args - Arguments to filter Option_items to delete.
     * @example
     * // Delete a few Option_items
     * const { count } = await prisma.option_item.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends option_itemDeleteManyArgs>(args?: SelectSubset<T, option_itemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Option_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {option_itemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Option_items
     * const option_item = await prisma.option_item.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends option_itemUpdateManyArgs>(args: SelectSubset<T, option_itemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Option_items and returns the data updated in the database.
     * @param {option_itemUpdateManyAndReturnArgs} args - Arguments to update many Option_items.
     * @example
     * // Update many Option_items
     * const option_item = await prisma.option_item.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Option_items and only return the `id`
     * const option_itemWithIdOnly = await prisma.option_item.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends option_itemUpdateManyAndReturnArgs>(args: SelectSubset<T, option_itemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$option_itemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Option_item.
     * @param {option_itemUpsertArgs} args - Arguments to update or create a Option_item.
     * @example
     * // Update or create a Option_item
     * const option_item = await prisma.option_item.upsert({
     *   create: {
     *     // ... data to create a Option_item
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Option_item we want to update
     *   }
     * })
     */
    upsert<T extends option_itemUpsertArgs>(args: SelectSubset<T, option_itemUpsertArgs<ExtArgs>>): Prisma__option_itemClient<$Result.GetResult<Prisma.$option_itemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Option_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {option_itemCountArgs} args - Arguments to filter Option_items to count.
     * @example
     * // Count the number of Option_items
     * const count = await prisma.option_item.count({
     *   where: {
     *     // ... the filter for the Option_items we want to count
     *   }
     * })
    **/
    count<T extends option_itemCountArgs>(
      args?: Subset<T, option_itemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Option_itemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Option_item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Option_itemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Option_itemAggregateArgs>(args: Subset<T, Option_itemAggregateArgs>): Prisma.PrismaPromise<GetOption_itemAggregateType<T>>

    /**
     * Group by Option_item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {option_itemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends option_itemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: option_itemGroupByArgs['orderBy'] }
        : { orderBy?: option_itemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, option_itemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOption_itemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the option_item model
   */
  readonly fields: option_itemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for option_item.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__option_itemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    option<T extends optionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, optionDefaultArgs<ExtArgs>>): Prisma__optionClient<$Result.GetResult<Prisma.$optionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    order_item_options<T extends option_item$order_item_optionsArgs<ExtArgs> = {}>(args?: Subset<T, option_item$order_item_optionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$order_item_optionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the option_item model
   */
  interface option_itemFieldRefs {
    readonly id: FieldRef<"option_item", 'String'>
    readonly option_id: FieldRef<"option_item", 'String'>
    readonly option_item_name: FieldRef<"option_item", 'String'>
    readonly status: FieldRef<"option_item", 'Boolean'>
    readonly status_select: FieldRef<"option_item", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * option_item findUnique
   */
  export type option_itemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the option_item
     */
    select?: option_itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the option_item
     */
    omit?: option_itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: option_itemInclude<ExtArgs> | null
    /**
     * Filter, which option_item to fetch.
     */
    where: option_itemWhereUniqueInput
  }

  /**
   * option_item findUniqueOrThrow
   */
  export type option_itemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the option_item
     */
    select?: option_itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the option_item
     */
    omit?: option_itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: option_itemInclude<ExtArgs> | null
    /**
     * Filter, which option_item to fetch.
     */
    where: option_itemWhereUniqueInput
  }

  /**
   * option_item findFirst
   */
  export type option_itemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the option_item
     */
    select?: option_itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the option_item
     */
    omit?: option_itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: option_itemInclude<ExtArgs> | null
    /**
     * Filter, which option_item to fetch.
     */
    where?: option_itemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of option_items to fetch.
     */
    orderBy?: option_itemOrderByWithRelationInput | option_itemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for option_items.
     */
    cursor?: option_itemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` option_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` option_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of option_items.
     */
    distinct?: Option_itemScalarFieldEnum | Option_itemScalarFieldEnum[]
  }

  /**
   * option_item findFirstOrThrow
   */
  export type option_itemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the option_item
     */
    select?: option_itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the option_item
     */
    omit?: option_itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: option_itemInclude<ExtArgs> | null
    /**
     * Filter, which option_item to fetch.
     */
    where?: option_itemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of option_items to fetch.
     */
    orderBy?: option_itemOrderByWithRelationInput | option_itemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for option_items.
     */
    cursor?: option_itemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` option_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` option_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of option_items.
     */
    distinct?: Option_itemScalarFieldEnum | Option_itemScalarFieldEnum[]
  }

  /**
   * option_item findMany
   */
  export type option_itemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the option_item
     */
    select?: option_itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the option_item
     */
    omit?: option_itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: option_itemInclude<ExtArgs> | null
    /**
     * Filter, which option_items to fetch.
     */
    where?: option_itemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of option_items to fetch.
     */
    orderBy?: option_itemOrderByWithRelationInput | option_itemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing option_items.
     */
    cursor?: option_itemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` option_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` option_items.
     */
    skip?: number
    distinct?: Option_itemScalarFieldEnum | Option_itemScalarFieldEnum[]
  }

  /**
   * option_item create
   */
  export type option_itemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the option_item
     */
    select?: option_itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the option_item
     */
    omit?: option_itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: option_itemInclude<ExtArgs> | null
    /**
     * The data needed to create a option_item.
     */
    data: XOR<option_itemCreateInput, option_itemUncheckedCreateInput>
  }

  /**
   * option_item createMany
   */
  export type option_itemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many option_items.
     */
    data: option_itemCreateManyInput | option_itemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * option_item createManyAndReturn
   */
  export type option_itemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the option_item
     */
    select?: option_itemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the option_item
     */
    omit?: option_itemOmit<ExtArgs> | null
    /**
     * The data used to create many option_items.
     */
    data: option_itemCreateManyInput | option_itemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: option_itemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * option_item update
   */
  export type option_itemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the option_item
     */
    select?: option_itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the option_item
     */
    omit?: option_itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: option_itemInclude<ExtArgs> | null
    /**
     * The data needed to update a option_item.
     */
    data: XOR<option_itemUpdateInput, option_itemUncheckedUpdateInput>
    /**
     * Choose, which option_item to update.
     */
    where: option_itemWhereUniqueInput
  }

  /**
   * option_item updateMany
   */
  export type option_itemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update option_items.
     */
    data: XOR<option_itemUpdateManyMutationInput, option_itemUncheckedUpdateManyInput>
    /**
     * Filter which option_items to update
     */
    where?: option_itemWhereInput
    /**
     * Limit how many option_items to update.
     */
    limit?: number
  }

  /**
   * option_item updateManyAndReturn
   */
  export type option_itemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the option_item
     */
    select?: option_itemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the option_item
     */
    omit?: option_itemOmit<ExtArgs> | null
    /**
     * The data used to update option_items.
     */
    data: XOR<option_itemUpdateManyMutationInput, option_itemUncheckedUpdateManyInput>
    /**
     * Filter which option_items to update
     */
    where?: option_itemWhereInput
    /**
     * Limit how many option_items to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: option_itemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * option_item upsert
   */
  export type option_itemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the option_item
     */
    select?: option_itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the option_item
     */
    omit?: option_itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: option_itemInclude<ExtArgs> | null
    /**
     * The filter to search for the option_item to update in case it exists.
     */
    where: option_itemWhereUniqueInput
    /**
     * In case the option_item found by the `where` argument doesn't exist, create a new option_item with this data.
     */
    create: XOR<option_itemCreateInput, option_itemUncheckedCreateInput>
    /**
     * In case the option_item was found with the provided `where` argument, update it with this data.
     */
    update: XOR<option_itemUpdateInput, option_itemUncheckedUpdateInput>
  }

  /**
   * option_item delete
   */
  export type option_itemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the option_item
     */
    select?: option_itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the option_item
     */
    omit?: option_itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: option_itemInclude<ExtArgs> | null
    /**
     * Filter which option_item to delete.
     */
    where: option_itemWhereUniqueInput
  }

  /**
   * option_item deleteMany
   */
  export type option_itemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which option_items to delete
     */
    where?: option_itemWhereInput
    /**
     * Limit how many option_items to delete.
     */
    limit?: number
  }

  /**
   * option_item.order_item_options
   */
  export type option_item$order_item_optionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_item_option
     */
    select?: order_item_optionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_item_option
     */
    omit?: order_item_optionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_item_optionInclude<ExtArgs> | null
    where?: order_item_optionWhereInput
    orderBy?: order_item_optionOrderByWithRelationInput | order_item_optionOrderByWithRelationInput[]
    cursor?: order_item_optionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Order_item_optionScalarFieldEnum | Order_item_optionScalarFieldEnum[]
  }

  /**
   * option_item without action
   */
  export type option_itemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the option_item
     */
    select?: option_itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the option_item
     */
    omit?: option_itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: option_itemInclude<ExtArgs> | null
  }


  /**
   * Model menu_item_option
   */

  export type AggregateMenu_item_option = {
    _count: Menu_item_optionCountAggregateOutputType | null
    _min: Menu_item_optionMinAggregateOutputType | null
    _max: Menu_item_optionMaxAggregateOutputType | null
  }

  export type Menu_item_optionMinAggregateOutputType = {
    option_id: string | null
    menu_item_id: string | null
  }

  export type Menu_item_optionMaxAggregateOutputType = {
    option_id: string | null
    menu_item_id: string | null
  }

  export type Menu_item_optionCountAggregateOutputType = {
    option_id: number
    menu_item_id: number
    _all: number
  }


  export type Menu_item_optionMinAggregateInputType = {
    option_id?: true
    menu_item_id?: true
  }

  export type Menu_item_optionMaxAggregateInputType = {
    option_id?: true
    menu_item_id?: true
  }

  export type Menu_item_optionCountAggregateInputType = {
    option_id?: true
    menu_item_id?: true
    _all?: true
  }

  export type Menu_item_optionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which menu_item_option to aggregate.
     */
    where?: menu_item_optionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of menu_item_options to fetch.
     */
    orderBy?: menu_item_optionOrderByWithRelationInput | menu_item_optionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: menu_item_optionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` menu_item_options from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` menu_item_options.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned menu_item_options
    **/
    _count?: true | Menu_item_optionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Menu_item_optionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Menu_item_optionMaxAggregateInputType
  }

  export type GetMenu_item_optionAggregateType<T extends Menu_item_optionAggregateArgs> = {
        [P in keyof T & keyof AggregateMenu_item_option]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMenu_item_option[P]>
      : GetScalarType<T[P], AggregateMenu_item_option[P]>
  }




  export type menu_item_optionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: menu_item_optionWhereInput
    orderBy?: menu_item_optionOrderByWithAggregationInput | menu_item_optionOrderByWithAggregationInput[]
    by: Menu_item_optionScalarFieldEnum[] | Menu_item_optionScalarFieldEnum
    having?: menu_item_optionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Menu_item_optionCountAggregateInputType | true
    _min?: Menu_item_optionMinAggregateInputType
    _max?: Menu_item_optionMaxAggregateInputType
  }

  export type Menu_item_optionGroupByOutputType = {
    option_id: string
    menu_item_id: string
    _count: Menu_item_optionCountAggregateOutputType | null
    _min: Menu_item_optionMinAggregateOutputType | null
    _max: Menu_item_optionMaxAggregateOutputType | null
  }

  type GetMenu_item_optionGroupByPayload<T extends menu_item_optionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Menu_item_optionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Menu_item_optionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Menu_item_optionGroupByOutputType[P]>
            : GetScalarType<T[P], Menu_item_optionGroupByOutputType[P]>
        }
      >
    >


  export type menu_item_optionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    option_id?: boolean
    menu_item_id?: boolean
    menu_item?: boolean | menu_itemDefaultArgs<ExtArgs>
    option?: boolean | optionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menu_item_option"]>

  export type menu_item_optionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    option_id?: boolean
    menu_item_id?: boolean
    menu_item?: boolean | menu_itemDefaultArgs<ExtArgs>
    option?: boolean | optionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menu_item_option"]>

  export type menu_item_optionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    option_id?: boolean
    menu_item_id?: boolean
    menu_item?: boolean | menu_itemDefaultArgs<ExtArgs>
    option?: boolean | optionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menu_item_option"]>

  export type menu_item_optionSelectScalar = {
    option_id?: boolean
    menu_item_id?: boolean
  }

  export type menu_item_optionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"option_id" | "menu_item_id", ExtArgs["result"]["menu_item_option"]>
  export type menu_item_optionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    menu_item?: boolean | menu_itemDefaultArgs<ExtArgs>
    option?: boolean | optionDefaultArgs<ExtArgs>
  }
  export type menu_item_optionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    menu_item?: boolean | menu_itemDefaultArgs<ExtArgs>
    option?: boolean | optionDefaultArgs<ExtArgs>
  }
  export type menu_item_optionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    menu_item?: boolean | menu_itemDefaultArgs<ExtArgs>
    option?: boolean | optionDefaultArgs<ExtArgs>
  }

  export type $menu_item_optionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "menu_item_option"
    objects: {
      menu_item: Prisma.$menu_itemPayload<ExtArgs>
      option: Prisma.$optionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      option_id: string
      menu_item_id: string
    }, ExtArgs["result"]["menu_item_option"]>
    composites: {}
  }

  type menu_item_optionGetPayload<S extends boolean | null | undefined | menu_item_optionDefaultArgs> = $Result.GetResult<Prisma.$menu_item_optionPayload, S>

  type menu_item_optionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<menu_item_optionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Menu_item_optionCountAggregateInputType | true
    }

  export interface menu_item_optionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['menu_item_option'], meta: { name: 'menu_item_option' } }
    /**
     * Find zero or one Menu_item_option that matches the filter.
     * @param {menu_item_optionFindUniqueArgs} args - Arguments to find a Menu_item_option
     * @example
     * // Get one Menu_item_option
     * const menu_item_option = await prisma.menu_item_option.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends menu_item_optionFindUniqueArgs>(args: SelectSubset<T, menu_item_optionFindUniqueArgs<ExtArgs>>): Prisma__menu_item_optionClient<$Result.GetResult<Prisma.$menu_item_optionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Menu_item_option that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {menu_item_optionFindUniqueOrThrowArgs} args - Arguments to find a Menu_item_option
     * @example
     * // Get one Menu_item_option
     * const menu_item_option = await prisma.menu_item_option.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends menu_item_optionFindUniqueOrThrowArgs>(args: SelectSubset<T, menu_item_optionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__menu_item_optionClient<$Result.GetResult<Prisma.$menu_item_optionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Menu_item_option that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {menu_item_optionFindFirstArgs} args - Arguments to find a Menu_item_option
     * @example
     * // Get one Menu_item_option
     * const menu_item_option = await prisma.menu_item_option.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends menu_item_optionFindFirstArgs>(args?: SelectSubset<T, menu_item_optionFindFirstArgs<ExtArgs>>): Prisma__menu_item_optionClient<$Result.GetResult<Prisma.$menu_item_optionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Menu_item_option that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {menu_item_optionFindFirstOrThrowArgs} args - Arguments to find a Menu_item_option
     * @example
     * // Get one Menu_item_option
     * const menu_item_option = await prisma.menu_item_option.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends menu_item_optionFindFirstOrThrowArgs>(args?: SelectSubset<T, menu_item_optionFindFirstOrThrowArgs<ExtArgs>>): Prisma__menu_item_optionClient<$Result.GetResult<Prisma.$menu_item_optionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Menu_item_options that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {menu_item_optionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Menu_item_options
     * const menu_item_options = await prisma.menu_item_option.findMany()
     * 
     * // Get first 10 Menu_item_options
     * const menu_item_options = await prisma.menu_item_option.findMany({ take: 10 })
     * 
     * // Only select the `option_id`
     * const menu_item_optionWithOption_idOnly = await prisma.menu_item_option.findMany({ select: { option_id: true } })
     * 
     */
    findMany<T extends menu_item_optionFindManyArgs>(args?: SelectSubset<T, menu_item_optionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$menu_item_optionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Menu_item_option.
     * @param {menu_item_optionCreateArgs} args - Arguments to create a Menu_item_option.
     * @example
     * // Create one Menu_item_option
     * const Menu_item_option = await prisma.menu_item_option.create({
     *   data: {
     *     // ... data to create a Menu_item_option
     *   }
     * })
     * 
     */
    create<T extends menu_item_optionCreateArgs>(args: SelectSubset<T, menu_item_optionCreateArgs<ExtArgs>>): Prisma__menu_item_optionClient<$Result.GetResult<Prisma.$menu_item_optionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Menu_item_options.
     * @param {menu_item_optionCreateManyArgs} args - Arguments to create many Menu_item_options.
     * @example
     * // Create many Menu_item_options
     * const menu_item_option = await prisma.menu_item_option.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends menu_item_optionCreateManyArgs>(args?: SelectSubset<T, menu_item_optionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Menu_item_options and returns the data saved in the database.
     * @param {menu_item_optionCreateManyAndReturnArgs} args - Arguments to create many Menu_item_options.
     * @example
     * // Create many Menu_item_options
     * const menu_item_option = await prisma.menu_item_option.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Menu_item_options and only return the `option_id`
     * const menu_item_optionWithOption_idOnly = await prisma.menu_item_option.createManyAndReturn({
     *   select: { option_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends menu_item_optionCreateManyAndReturnArgs>(args?: SelectSubset<T, menu_item_optionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$menu_item_optionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Menu_item_option.
     * @param {menu_item_optionDeleteArgs} args - Arguments to delete one Menu_item_option.
     * @example
     * // Delete one Menu_item_option
     * const Menu_item_option = await prisma.menu_item_option.delete({
     *   where: {
     *     // ... filter to delete one Menu_item_option
     *   }
     * })
     * 
     */
    delete<T extends menu_item_optionDeleteArgs>(args: SelectSubset<T, menu_item_optionDeleteArgs<ExtArgs>>): Prisma__menu_item_optionClient<$Result.GetResult<Prisma.$menu_item_optionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Menu_item_option.
     * @param {menu_item_optionUpdateArgs} args - Arguments to update one Menu_item_option.
     * @example
     * // Update one Menu_item_option
     * const menu_item_option = await prisma.menu_item_option.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends menu_item_optionUpdateArgs>(args: SelectSubset<T, menu_item_optionUpdateArgs<ExtArgs>>): Prisma__menu_item_optionClient<$Result.GetResult<Prisma.$menu_item_optionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Menu_item_options.
     * @param {menu_item_optionDeleteManyArgs} args - Arguments to filter Menu_item_options to delete.
     * @example
     * // Delete a few Menu_item_options
     * const { count } = await prisma.menu_item_option.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends menu_item_optionDeleteManyArgs>(args?: SelectSubset<T, menu_item_optionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Menu_item_options.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {menu_item_optionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Menu_item_options
     * const menu_item_option = await prisma.menu_item_option.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends menu_item_optionUpdateManyArgs>(args: SelectSubset<T, menu_item_optionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Menu_item_options and returns the data updated in the database.
     * @param {menu_item_optionUpdateManyAndReturnArgs} args - Arguments to update many Menu_item_options.
     * @example
     * // Update many Menu_item_options
     * const menu_item_option = await prisma.menu_item_option.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Menu_item_options and only return the `option_id`
     * const menu_item_optionWithOption_idOnly = await prisma.menu_item_option.updateManyAndReturn({
     *   select: { option_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends menu_item_optionUpdateManyAndReturnArgs>(args: SelectSubset<T, menu_item_optionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$menu_item_optionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Menu_item_option.
     * @param {menu_item_optionUpsertArgs} args - Arguments to update or create a Menu_item_option.
     * @example
     * // Update or create a Menu_item_option
     * const menu_item_option = await prisma.menu_item_option.upsert({
     *   create: {
     *     // ... data to create a Menu_item_option
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Menu_item_option we want to update
     *   }
     * })
     */
    upsert<T extends menu_item_optionUpsertArgs>(args: SelectSubset<T, menu_item_optionUpsertArgs<ExtArgs>>): Prisma__menu_item_optionClient<$Result.GetResult<Prisma.$menu_item_optionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Menu_item_options.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {menu_item_optionCountArgs} args - Arguments to filter Menu_item_options to count.
     * @example
     * // Count the number of Menu_item_options
     * const count = await prisma.menu_item_option.count({
     *   where: {
     *     // ... the filter for the Menu_item_options we want to count
     *   }
     * })
    **/
    count<T extends menu_item_optionCountArgs>(
      args?: Subset<T, menu_item_optionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Menu_item_optionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Menu_item_option.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Menu_item_optionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Menu_item_optionAggregateArgs>(args: Subset<T, Menu_item_optionAggregateArgs>): Prisma.PrismaPromise<GetMenu_item_optionAggregateType<T>>

    /**
     * Group by Menu_item_option.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {menu_item_optionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends menu_item_optionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: menu_item_optionGroupByArgs['orderBy'] }
        : { orderBy?: menu_item_optionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, menu_item_optionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMenu_item_optionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the menu_item_option model
   */
  readonly fields: menu_item_optionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for menu_item_option.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__menu_item_optionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    menu_item<T extends menu_itemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, menu_itemDefaultArgs<ExtArgs>>): Prisma__menu_itemClient<$Result.GetResult<Prisma.$menu_itemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    option<T extends optionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, optionDefaultArgs<ExtArgs>>): Prisma__optionClient<$Result.GetResult<Prisma.$optionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the menu_item_option model
   */
  interface menu_item_optionFieldRefs {
    readonly option_id: FieldRef<"menu_item_option", 'String'>
    readonly menu_item_id: FieldRef<"menu_item_option", 'String'>
  }
    

  // Custom InputTypes
  /**
   * menu_item_option findUnique
   */
  export type menu_item_optionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu_item_option
     */
    select?: menu_item_optionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the menu_item_option
     */
    omit?: menu_item_optionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: menu_item_optionInclude<ExtArgs> | null
    /**
     * Filter, which menu_item_option to fetch.
     */
    where: menu_item_optionWhereUniqueInput
  }

  /**
   * menu_item_option findUniqueOrThrow
   */
  export type menu_item_optionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu_item_option
     */
    select?: menu_item_optionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the menu_item_option
     */
    omit?: menu_item_optionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: menu_item_optionInclude<ExtArgs> | null
    /**
     * Filter, which menu_item_option to fetch.
     */
    where: menu_item_optionWhereUniqueInput
  }

  /**
   * menu_item_option findFirst
   */
  export type menu_item_optionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu_item_option
     */
    select?: menu_item_optionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the menu_item_option
     */
    omit?: menu_item_optionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: menu_item_optionInclude<ExtArgs> | null
    /**
     * Filter, which menu_item_option to fetch.
     */
    where?: menu_item_optionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of menu_item_options to fetch.
     */
    orderBy?: menu_item_optionOrderByWithRelationInput | menu_item_optionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for menu_item_options.
     */
    cursor?: menu_item_optionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` menu_item_options from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` menu_item_options.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of menu_item_options.
     */
    distinct?: Menu_item_optionScalarFieldEnum | Menu_item_optionScalarFieldEnum[]
  }

  /**
   * menu_item_option findFirstOrThrow
   */
  export type menu_item_optionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu_item_option
     */
    select?: menu_item_optionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the menu_item_option
     */
    omit?: menu_item_optionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: menu_item_optionInclude<ExtArgs> | null
    /**
     * Filter, which menu_item_option to fetch.
     */
    where?: menu_item_optionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of menu_item_options to fetch.
     */
    orderBy?: menu_item_optionOrderByWithRelationInput | menu_item_optionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for menu_item_options.
     */
    cursor?: menu_item_optionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` menu_item_options from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` menu_item_options.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of menu_item_options.
     */
    distinct?: Menu_item_optionScalarFieldEnum | Menu_item_optionScalarFieldEnum[]
  }

  /**
   * menu_item_option findMany
   */
  export type menu_item_optionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu_item_option
     */
    select?: menu_item_optionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the menu_item_option
     */
    omit?: menu_item_optionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: menu_item_optionInclude<ExtArgs> | null
    /**
     * Filter, which menu_item_options to fetch.
     */
    where?: menu_item_optionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of menu_item_options to fetch.
     */
    orderBy?: menu_item_optionOrderByWithRelationInput | menu_item_optionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing menu_item_options.
     */
    cursor?: menu_item_optionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` menu_item_options from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` menu_item_options.
     */
    skip?: number
    distinct?: Menu_item_optionScalarFieldEnum | Menu_item_optionScalarFieldEnum[]
  }

  /**
   * menu_item_option create
   */
  export type menu_item_optionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu_item_option
     */
    select?: menu_item_optionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the menu_item_option
     */
    omit?: menu_item_optionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: menu_item_optionInclude<ExtArgs> | null
    /**
     * The data needed to create a menu_item_option.
     */
    data: XOR<menu_item_optionCreateInput, menu_item_optionUncheckedCreateInput>
  }

  /**
   * menu_item_option createMany
   */
  export type menu_item_optionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many menu_item_options.
     */
    data: menu_item_optionCreateManyInput | menu_item_optionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * menu_item_option createManyAndReturn
   */
  export type menu_item_optionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu_item_option
     */
    select?: menu_item_optionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the menu_item_option
     */
    omit?: menu_item_optionOmit<ExtArgs> | null
    /**
     * The data used to create many menu_item_options.
     */
    data: menu_item_optionCreateManyInput | menu_item_optionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: menu_item_optionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * menu_item_option update
   */
  export type menu_item_optionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu_item_option
     */
    select?: menu_item_optionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the menu_item_option
     */
    omit?: menu_item_optionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: menu_item_optionInclude<ExtArgs> | null
    /**
     * The data needed to update a menu_item_option.
     */
    data: XOR<menu_item_optionUpdateInput, menu_item_optionUncheckedUpdateInput>
    /**
     * Choose, which menu_item_option to update.
     */
    where: menu_item_optionWhereUniqueInput
  }

  /**
   * menu_item_option updateMany
   */
  export type menu_item_optionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update menu_item_options.
     */
    data: XOR<menu_item_optionUpdateManyMutationInput, menu_item_optionUncheckedUpdateManyInput>
    /**
     * Filter which menu_item_options to update
     */
    where?: menu_item_optionWhereInput
    /**
     * Limit how many menu_item_options to update.
     */
    limit?: number
  }

  /**
   * menu_item_option updateManyAndReturn
   */
  export type menu_item_optionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu_item_option
     */
    select?: menu_item_optionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the menu_item_option
     */
    omit?: menu_item_optionOmit<ExtArgs> | null
    /**
     * The data used to update menu_item_options.
     */
    data: XOR<menu_item_optionUpdateManyMutationInput, menu_item_optionUncheckedUpdateManyInput>
    /**
     * Filter which menu_item_options to update
     */
    where?: menu_item_optionWhereInput
    /**
     * Limit how many menu_item_options to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: menu_item_optionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * menu_item_option upsert
   */
  export type menu_item_optionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu_item_option
     */
    select?: menu_item_optionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the menu_item_option
     */
    omit?: menu_item_optionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: menu_item_optionInclude<ExtArgs> | null
    /**
     * The filter to search for the menu_item_option to update in case it exists.
     */
    where: menu_item_optionWhereUniqueInput
    /**
     * In case the menu_item_option found by the `where` argument doesn't exist, create a new menu_item_option with this data.
     */
    create: XOR<menu_item_optionCreateInput, menu_item_optionUncheckedCreateInput>
    /**
     * In case the menu_item_option was found with the provided `where` argument, update it with this data.
     */
    update: XOR<menu_item_optionUpdateInput, menu_item_optionUncheckedUpdateInput>
  }

  /**
   * menu_item_option delete
   */
  export type menu_item_optionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu_item_option
     */
    select?: menu_item_optionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the menu_item_option
     */
    omit?: menu_item_optionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: menu_item_optionInclude<ExtArgs> | null
    /**
     * Filter which menu_item_option to delete.
     */
    where: menu_item_optionWhereUniqueInput
  }

  /**
   * menu_item_option deleteMany
   */
  export type menu_item_optionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which menu_item_options to delete
     */
    where?: menu_item_optionWhereInput
    /**
     * Limit how many menu_item_options to delete.
     */
    limit?: number
  }

  /**
   * menu_item_option without action
   */
  export type menu_item_optionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu_item_option
     */
    select?: menu_item_optionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the menu_item_option
     */
    omit?: menu_item_optionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: menu_item_optionInclude<ExtArgs> | null
  }


  /**
   * Model order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    delivery_fee: number | null
    total_amount: number | null
  }

  export type OrderSumAggregateOutputType = {
    delivery_fee: bigint | null
    total_amount: bigint | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    merchant_id: string | null
    user_id: string | null
    full_name: string | null
    phone: string | null
    delivery_address: string | null
    delivery_fee: bigint | null
    note: string | null
    total_amount: bigint | null
    created_at: Date | null
    updated_at: Date | null
    status: string | null
    status_payment: string | null
    payment_method: string | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    merchant_id: string | null
    user_id: string | null
    full_name: string | null
    phone: string | null
    delivery_address: string | null
    delivery_fee: bigint | null
    note: string | null
    total_amount: bigint | null
    created_at: Date | null
    updated_at: Date | null
    status: string | null
    status_payment: string | null
    payment_method: string | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    merchant_id: number
    user_id: number
    full_name: number
    phone: number
    delivery_address: number
    delivery_fee: number
    note: number
    total_amount: number
    created_at: number
    updated_at: number
    status: number
    status_payment: number
    payment_method: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    delivery_fee?: true
    total_amount?: true
  }

  export type OrderSumAggregateInputType = {
    delivery_fee?: true
    total_amount?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    merchant_id?: true
    user_id?: true
    full_name?: true
    phone?: true
    delivery_address?: true
    delivery_fee?: true
    note?: true
    total_amount?: true
    created_at?: true
    updated_at?: true
    status?: true
    status_payment?: true
    payment_method?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    merchant_id?: true
    user_id?: true
    full_name?: true
    phone?: true
    delivery_address?: true
    delivery_fee?: true
    note?: true
    total_amount?: true
    created_at?: true
    updated_at?: true
    status?: true
    status_payment?: true
    payment_method?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    merchant_id?: true
    user_id?: true
    full_name?: true
    phone?: true
    delivery_address?: true
    delivery_fee?: true
    note?: true
    total_amount?: true
    created_at?: true
    updated_at?: true
    status?: true
    status_payment?: true
    payment_method?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which order to aggregate.
     */
    where?: orderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orders to fetch.
     */
    orderBy?: orderOrderByWithRelationInput | orderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: orderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type orderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: orderWhereInput
    orderBy?: orderOrderByWithAggregationInput | orderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: orderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: string
    merchant_id: string
    user_id: string
    full_name: string
    phone: string | null
    delivery_address: string | null
    delivery_fee: bigint | null
    note: string | null
    total_amount: bigint
    created_at: Date | null
    updated_at: Date | null
    status: string | null
    status_payment: string | null
    payment_method: string | null
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends orderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type orderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    merchant_id?: boolean
    user_id?: boolean
    full_name?: boolean
    phone?: boolean
    delivery_address?: boolean
    delivery_fee?: boolean
    note?: boolean
    total_amount?: boolean
    created_at?: boolean
    updated_at?: boolean
    status?: boolean
    status_payment?: boolean
    payment_method?: boolean
    merchant?: boolean | merchantDefaultArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
    items?: boolean | order$itemsArgs<ExtArgs>
    payments?: boolean | order$paymentsArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type orderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    merchant_id?: boolean
    user_id?: boolean
    full_name?: boolean
    phone?: boolean
    delivery_address?: boolean
    delivery_fee?: boolean
    note?: boolean
    total_amount?: boolean
    created_at?: boolean
    updated_at?: boolean
    status?: boolean
    status_payment?: boolean
    payment_method?: boolean
    merchant?: boolean | merchantDefaultArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type orderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    merchant_id?: boolean
    user_id?: boolean
    full_name?: boolean
    phone?: boolean
    delivery_address?: boolean
    delivery_fee?: boolean
    note?: boolean
    total_amount?: boolean
    created_at?: boolean
    updated_at?: boolean
    status?: boolean
    status_payment?: boolean
    payment_method?: boolean
    merchant?: boolean | merchantDefaultArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type orderSelectScalar = {
    id?: boolean
    merchant_id?: boolean
    user_id?: boolean
    full_name?: boolean
    phone?: boolean
    delivery_address?: boolean
    delivery_fee?: boolean
    note?: boolean
    total_amount?: boolean
    created_at?: boolean
    updated_at?: boolean
    status?: boolean
    status_payment?: boolean
    payment_method?: boolean
  }

  export type orderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "merchant_id" | "user_id" | "full_name" | "phone" | "delivery_address" | "delivery_fee" | "note" | "total_amount" | "created_at" | "updated_at" | "status" | "status_payment" | "payment_method", ExtArgs["result"]["order"]>
  export type orderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    merchant?: boolean | merchantDefaultArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
    items?: boolean | order$itemsArgs<ExtArgs>
    payments?: boolean | order$paymentsArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type orderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    merchant?: boolean | merchantDefaultArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type orderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    merchant?: boolean | merchantDefaultArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $orderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "order"
    objects: {
      merchant: Prisma.$merchantPayload<ExtArgs>
      user: Prisma.$usersPayload<ExtArgs>
      items: Prisma.$order_itemPayload<ExtArgs>[]
      payments: Prisma.$payment_transactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      merchant_id: string
      user_id: string
      full_name: string
      phone: string | null
      delivery_address: string | null
      delivery_fee: bigint | null
      note: string | null
      total_amount: bigint
      created_at: Date | null
      updated_at: Date | null
      status: string | null
      status_payment: string | null
      payment_method: string | null
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type orderGetPayload<S extends boolean | null | undefined | orderDefaultArgs> = $Result.GetResult<Prisma.$orderPayload, S>

  type orderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<orderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface orderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['order'], meta: { name: 'order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {orderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends orderFindUniqueArgs>(args: SelectSubset<T, orderFindUniqueArgs<ExtArgs>>): Prisma__orderClient<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {orderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends orderFindUniqueOrThrowArgs>(args: SelectSubset<T, orderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__orderClient<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends orderFindFirstArgs>(args?: SelectSubset<T, orderFindFirstArgs<ExtArgs>>): Prisma__orderClient<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends orderFindFirstOrThrowArgs>(args?: SelectSubset<T, orderFindFirstOrThrowArgs<ExtArgs>>): Prisma__orderClient<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends orderFindManyArgs>(args?: SelectSubset<T, orderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Order.
     * @param {orderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends orderCreateArgs>(args: SelectSubset<T, orderCreateArgs<ExtArgs>>): Prisma__orderClient<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orders.
     * @param {orderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends orderCreateManyArgs>(args?: SelectSubset<T, orderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {orderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends orderCreateManyAndReturnArgs>(args?: SelectSubset<T, orderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Order.
     * @param {orderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends orderDeleteArgs>(args: SelectSubset<T, orderDeleteArgs<ExtArgs>>): Prisma__orderClient<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Order.
     * @param {orderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends orderUpdateArgs>(args: SelectSubset<T, orderUpdateArgs<ExtArgs>>): Prisma__orderClient<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orders.
     * @param {orderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends orderDeleteManyArgs>(args?: SelectSubset<T, orderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends orderUpdateManyArgs>(args: SelectSubset<T, orderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders and returns the data updated in the database.
     * @param {orderUpdateManyAndReturnArgs} args - Arguments to update many Orders.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends orderUpdateManyAndReturnArgs>(args: SelectSubset<T, orderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Order.
     * @param {orderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends orderUpsertArgs>(args: SelectSubset<T, orderUpsertArgs<ExtArgs>>): Prisma__orderClient<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends orderCountArgs>(
      args?: Subset<T, orderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends orderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: orderGroupByArgs['orderBy'] }
        : { orderBy?: orderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, orderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the order model
   */
  readonly fields: orderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__orderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    merchant<T extends merchantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, merchantDefaultArgs<ExtArgs>>): Prisma__merchantClient<$Result.GetResult<Prisma.$merchantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends order$itemsArgs<ExtArgs> = {}>(args?: Subset<T, order$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$order_itemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends order$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, order$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_transactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the order model
   */
  interface orderFieldRefs {
    readonly id: FieldRef<"order", 'String'>
    readonly merchant_id: FieldRef<"order", 'String'>
    readonly user_id: FieldRef<"order", 'String'>
    readonly full_name: FieldRef<"order", 'String'>
    readonly phone: FieldRef<"order", 'String'>
    readonly delivery_address: FieldRef<"order", 'String'>
    readonly delivery_fee: FieldRef<"order", 'BigInt'>
    readonly note: FieldRef<"order", 'String'>
    readonly total_amount: FieldRef<"order", 'BigInt'>
    readonly created_at: FieldRef<"order", 'DateTime'>
    readonly updated_at: FieldRef<"order", 'DateTime'>
    readonly status: FieldRef<"order", 'String'>
    readonly status_payment: FieldRef<"order", 'String'>
    readonly payment_method: FieldRef<"order", 'String'>
  }
    

  // Custom InputTypes
  /**
   * order findUnique
   */
  export type orderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order
     */
    omit?: orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderInclude<ExtArgs> | null
    /**
     * Filter, which order to fetch.
     */
    where: orderWhereUniqueInput
  }

  /**
   * order findUniqueOrThrow
   */
  export type orderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order
     */
    omit?: orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderInclude<ExtArgs> | null
    /**
     * Filter, which order to fetch.
     */
    where: orderWhereUniqueInput
  }

  /**
   * order findFirst
   */
  export type orderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order
     */
    omit?: orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderInclude<ExtArgs> | null
    /**
     * Filter, which order to fetch.
     */
    where?: orderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orders to fetch.
     */
    orderBy?: orderOrderByWithRelationInput | orderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for orders.
     */
    cursor?: orderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * order findFirstOrThrow
   */
  export type orderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order
     */
    omit?: orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderInclude<ExtArgs> | null
    /**
     * Filter, which order to fetch.
     */
    where?: orderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orders to fetch.
     */
    orderBy?: orderOrderByWithRelationInput | orderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for orders.
     */
    cursor?: orderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * order findMany
   */
  export type orderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order
     */
    omit?: orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderInclude<ExtArgs> | null
    /**
     * Filter, which orders to fetch.
     */
    where?: orderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orders to fetch.
     */
    orderBy?: orderOrderByWithRelationInput | orderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing orders.
     */
    cursor?: orderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * order create
   */
  export type orderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order
     */
    omit?: orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderInclude<ExtArgs> | null
    /**
     * The data needed to create a order.
     */
    data: XOR<orderCreateInput, orderUncheckedCreateInput>
  }

  /**
   * order createMany
   */
  export type orderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many orders.
     */
    data: orderCreateManyInput | orderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * order createManyAndReturn
   */
  export type orderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the order
     */
    omit?: orderOmit<ExtArgs> | null
    /**
     * The data used to create many orders.
     */
    data: orderCreateManyInput | orderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * order update
   */
  export type orderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order
     */
    omit?: orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderInclude<ExtArgs> | null
    /**
     * The data needed to update a order.
     */
    data: XOR<orderUpdateInput, orderUncheckedUpdateInput>
    /**
     * Choose, which order to update.
     */
    where: orderWhereUniqueInput
  }

  /**
   * order updateMany
   */
  export type orderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update orders.
     */
    data: XOR<orderUpdateManyMutationInput, orderUncheckedUpdateManyInput>
    /**
     * Filter which orders to update
     */
    where?: orderWhereInput
    /**
     * Limit how many orders to update.
     */
    limit?: number
  }

  /**
   * order updateManyAndReturn
   */
  export type orderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the order
     */
    omit?: orderOmit<ExtArgs> | null
    /**
     * The data used to update orders.
     */
    data: XOR<orderUpdateManyMutationInput, orderUncheckedUpdateManyInput>
    /**
     * Filter which orders to update
     */
    where?: orderWhereInput
    /**
     * Limit how many orders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * order upsert
   */
  export type orderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order
     */
    omit?: orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderInclude<ExtArgs> | null
    /**
     * The filter to search for the order to update in case it exists.
     */
    where: orderWhereUniqueInput
    /**
     * In case the order found by the `where` argument doesn't exist, create a new order with this data.
     */
    create: XOR<orderCreateInput, orderUncheckedCreateInput>
    /**
     * In case the order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<orderUpdateInput, orderUncheckedUpdateInput>
  }

  /**
   * order delete
   */
  export type orderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order
     */
    omit?: orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderInclude<ExtArgs> | null
    /**
     * Filter which order to delete.
     */
    where: orderWhereUniqueInput
  }

  /**
   * order deleteMany
   */
  export type orderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which orders to delete
     */
    where?: orderWhereInput
    /**
     * Limit how many orders to delete.
     */
    limit?: number
  }

  /**
   * order.items
   */
  export type order$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_item
     */
    select?: order_itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_item
     */
    omit?: order_itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_itemInclude<ExtArgs> | null
    where?: order_itemWhereInput
    orderBy?: order_itemOrderByWithRelationInput | order_itemOrderByWithRelationInput[]
    cursor?: order_itemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Order_itemScalarFieldEnum | Order_itemScalarFieldEnum[]
  }

  /**
   * order.payments
   */
  export type order$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_transaction
     */
    select?: payment_transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_transaction
     */
    omit?: payment_transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_transactionInclude<ExtArgs> | null
    where?: payment_transactionWhereInput
    orderBy?: payment_transactionOrderByWithRelationInput | payment_transactionOrderByWithRelationInput[]
    cursor?: payment_transactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Payment_transactionScalarFieldEnum | Payment_transactionScalarFieldEnum[]
  }

  /**
   * order without action
   */
  export type orderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order
     */
    omit?: orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderInclude<ExtArgs> | null
  }


  /**
   * Model order_item
   */

  export type AggregateOrder_item = {
    _count: Order_itemCountAggregateOutputType | null
    _avg: Order_itemAvgAggregateOutputType | null
    _sum: Order_itemSumAggregateOutputType | null
    _min: Order_itemMinAggregateOutputType | null
    _max: Order_itemMaxAggregateOutputType | null
  }

  export type Order_itemAvgAggregateOutputType = {
    quantity: number | null
    price: number | null
  }

  export type Order_itemSumAggregateOutputType = {
    quantity: bigint | null
    price: bigint | null
  }

  export type Order_itemMinAggregateOutputType = {
    id: string | null
    order_id: string | null
    menu_item_id: string | null
    note: string | null
    quantity: bigint | null
    price: bigint | null
  }

  export type Order_itemMaxAggregateOutputType = {
    id: string | null
    order_id: string | null
    menu_item_id: string | null
    note: string | null
    quantity: bigint | null
    price: bigint | null
  }

  export type Order_itemCountAggregateOutputType = {
    id: number
    order_id: number
    menu_item_id: number
    note: number
    quantity: number
    price: number
    _all: number
  }


  export type Order_itemAvgAggregateInputType = {
    quantity?: true
    price?: true
  }

  export type Order_itemSumAggregateInputType = {
    quantity?: true
    price?: true
  }

  export type Order_itemMinAggregateInputType = {
    id?: true
    order_id?: true
    menu_item_id?: true
    note?: true
    quantity?: true
    price?: true
  }

  export type Order_itemMaxAggregateInputType = {
    id?: true
    order_id?: true
    menu_item_id?: true
    note?: true
    quantity?: true
    price?: true
  }

  export type Order_itemCountAggregateInputType = {
    id?: true
    order_id?: true
    menu_item_id?: true
    note?: true
    quantity?: true
    price?: true
    _all?: true
  }

  export type Order_itemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which order_item to aggregate.
     */
    where?: order_itemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_items to fetch.
     */
    orderBy?: order_itemOrderByWithRelationInput | order_itemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: order_itemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned order_items
    **/
    _count?: true | Order_itemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Order_itemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Order_itemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Order_itemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Order_itemMaxAggregateInputType
  }

  export type GetOrder_itemAggregateType<T extends Order_itemAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder_item]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder_item[P]>
      : GetScalarType<T[P], AggregateOrder_item[P]>
  }




  export type order_itemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: order_itemWhereInput
    orderBy?: order_itemOrderByWithAggregationInput | order_itemOrderByWithAggregationInput[]
    by: Order_itemScalarFieldEnum[] | Order_itemScalarFieldEnum
    having?: order_itemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Order_itemCountAggregateInputType | true
    _avg?: Order_itemAvgAggregateInputType
    _sum?: Order_itemSumAggregateInputType
    _min?: Order_itemMinAggregateInputType
    _max?: Order_itemMaxAggregateInputType
  }

  export type Order_itemGroupByOutputType = {
    id: string
    order_id: string
    menu_item_id: string
    note: string | null
    quantity: bigint
    price: bigint
    _count: Order_itemCountAggregateOutputType | null
    _avg: Order_itemAvgAggregateOutputType | null
    _sum: Order_itemSumAggregateOutputType | null
    _min: Order_itemMinAggregateOutputType | null
    _max: Order_itemMaxAggregateOutputType | null
  }

  type GetOrder_itemGroupByPayload<T extends order_itemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Order_itemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Order_itemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Order_itemGroupByOutputType[P]>
            : GetScalarType<T[P], Order_itemGroupByOutputType[P]>
        }
      >
    >


  export type order_itemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    order_id?: boolean
    menu_item_id?: boolean
    note?: boolean
    quantity?: boolean
    price?: boolean
    menu_item?: boolean | menu_itemDefaultArgs<ExtArgs>
    order?: boolean | orderDefaultArgs<ExtArgs>
    options?: boolean | order_item$optionsArgs<ExtArgs>
    _count?: boolean | Order_itemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order_item"]>

  export type order_itemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    order_id?: boolean
    menu_item_id?: boolean
    note?: boolean
    quantity?: boolean
    price?: boolean
    menu_item?: boolean | menu_itemDefaultArgs<ExtArgs>
    order?: boolean | orderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order_item"]>

  export type order_itemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    order_id?: boolean
    menu_item_id?: boolean
    note?: boolean
    quantity?: boolean
    price?: boolean
    menu_item?: boolean | menu_itemDefaultArgs<ExtArgs>
    order?: boolean | orderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order_item"]>

  export type order_itemSelectScalar = {
    id?: boolean
    order_id?: boolean
    menu_item_id?: boolean
    note?: boolean
    quantity?: boolean
    price?: boolean
  }

  export type order_itemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "order_id" | "menu_item_id" | "note" | "quantity" | "price", ExtArgs["result"]["order_item"]>
  export type order_itemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    menu_item?: boolean | menu_itemDefaultArgs<ExtArgs>
    order?: boolean | orderDefaultArgs<ExtArgs>
    options?: boolean | order_item$optionsArgs<ExtArgs>
    _count?: boolean | Order_itemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type order_itemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    menu_item?: boolean | menu_itemDefaultArgs<ExtArgs>
    order?: boolean | orderDefaultArgs<ExtArgs>
  }
  export type order_itemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    menu_item?: boolean | menu_itemDefaultArgs<ExtArgs>
    order?: boolean | orderDefaultArgs<ExtArgs>
  }

  export type $order_itemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "order_item"
    objects: {
      menu_item: Prisma.$menu_itemPayload<ExtArgs>
      order: Prisma.$orderPayload<ExtArgs>
      options: Prisma.$order_item_optionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      order_id: string
      menu_item_id: string
      note: string | null
      quantity: bigint
      price: bigint
    }, ExtArgs["result"]["order_item"]>
    composites: {}
  }

  type order_itemGetPayload<S extends boolean | null | undefined | order_itemDefaultArgs> = $Result.GetResult<Prisma.$order_itemPayload, S>

  type order_itemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<order_itemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Order_itemCountAggregateInputType | true
    }

  export interface order_itemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['order_item'], meta: { name: 'order_item' } }
    /**
     * Find zero or one Order_item that matches the filter.
     * @param {order_itemFindUniqueArgs} args - Arguments to find a Order_item
     * @example
     * // Get one Order_item
     * const order_item = await prisma.order_item.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends order_itemFindUniqueArgs>(args: SelectSubset<T, order_itemFindUniqueArgs<ExtArgs>>): Prisma__order_itemClient<$Result.GetResult<Prisma.$order_itemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Order_item that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {order_itemFindUniqueOrThrowArgs} args - Arguments to find a Order_item
     * @example
     * // Get one Order_item
     * const order_item = await prisma.order_item.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends order_itemFindUniqueOrThrowArgs>(args: SelectSubset<T, order_itemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__order_itemClient<$Result.GetResult<Prisma.$order_itemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order_item that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_itemFindFirstArgs} args - Arguments to find a Order_item
     * @example
     * // Get one Order_item
     * const order_item = await prisma.order_item.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends order_itemFindFirstArgs>(args?: SelectSubset<T, order_itemFindFirstArgs<ExtArgs>>): Prisma__order_itemClient<$Result.GetResult<Prisma.$order_itemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order_item that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_itemFindFirstOrThrowArgs} args - Arguments to find a Order_item
     * @example
     * // Get one Order_item
     * const order_item = await prisma.order_item.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends order_itemFindFirstOrThrowArgs>(args?: SelectSubset<T, order_itemFindFirstOrThrowArgs<ExtArgs>>): Prisma__order_itemClient<$Result.GetResult<Prisma.$order_itemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Order_items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_itemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Order_items
     * const order_items = await prisma.order_item.findMany()
     * 
     * // Get first 10 Order_items
     * const order_items = await prisma.order_item.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const order_itemWithIdOnly = await prisma.order_item.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends order_itemFindManyArgs>(args?: SelectSubset<T, order_itemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$order_itemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Order_item.
     * @param {order_itemCreateArgs} args - Arguments to create a Order_item.
     * @example
     * // Create one Order_item
     * const Order_item = await prisma.order_item.create({
     *   data: {
     *     // ... data to create a Order_item
     *   }
     * })
     * 
     */
    create<T extends order_itemCreateArgs>(args: SelectSubset<T, order_itemCreateArgs<ExtArgs>>): Prisma__order_itemClient<$Result.GetResult<Prisma.$order_itemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Order_items.
     * @param {order_itemCreateManyArgs} args - Arguments to create many Order_items.
     * @example
     * // Create many Order_items
     * const order_item = await prisma.order_item.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends order_itemCreateManyArgs>(args?: SelectSubset<T, order_itemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Order_items and returns the data saved in the database.
     * @param {order_itemCreateManyAndReturnArgs} args - Arguments to create many Order_items.
     * @example
     * // Create many Order_items
     * const order_item = await prisma.order_item.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Order_items and only return the `id`
     * const order_itemWithIdOnly = await prisma.order_item.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends order_itemCreateManyAndReturnArgs>(args?: SelectSubset<T, order_itemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$order_itemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Order_item.
     * @param {order_itemDeleteArgs} args - Arguments to delete one Order_item.
     * @example
     * // Delete one Order_item
     * const Order_item = await prisma.order_item.delete({
     *   where: {
     *     // ... filter to delete one Order_item
     *   }
     * })
     * 
     */
    delete<T extends order_itemDeleteArgs>(args: SelectSubset<T, order_itemDeleteArgs<ExtArgs>>): Prisma__order_itemClient<$Result.GetResult<Prisma.$order_itemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Order_item.
     * @param {order_itemUpdateArgs} args - Arguments to update one Order_item.
     * @example
     * // Update one Order_item
     * const order_item = await prisma.order_item.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends order_itemUpdateArgs>(args: SelectSubset<T, order_itemUpdateArgs<ExtArgs>>): Prisma__order_itemClient<$Result.GetResult<Prisma.$order_itemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Order_items.
     * @param {order_itemDeleteManyArgs} args - Arguments to filter Order_items to delete.
     * @example
     * // Delete a few Order_items
     * const { count } = await prisma.order_item.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends order_itemDeleteManyArgs>(args?: SelectSubset<T, order_itemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Order_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_itemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Order_items
     * const order_item = await prisma.order_item.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends order_itemUpdateManyArgs>(args: SelectSubset<T, order_itemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Order_items and returns the data updated in the database.
     * @param {order_itemUpdateManyAndReturnArgs} args - Arguments to update many Order_items.
     * @example
     * // Update many Order_items
     * const order_item = await prisma.order_item.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Order_items and only return the `id`
     * const order_itemWithIdOnly = await prisma.order_item.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends order_itemUpdateManyAndReturnArgs>(args: SelectSubset<T, order_itemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$order_itemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Order_item.
     * @param {order_itemUpsertArgs} args - Arguments to update or create a Order_item.
     * @example
     * // Update or create a Order_item
     * const order_item = await prisma.order_item.upsert({
     *   create: {
     *     // ... data to create a Order_item
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order_item we want to update
     *   }
     * })
     */
    upsert<T extends order_itemUpsertArgs>(args: SelectSubset<T, order_itemUpsertArgs<ExtArgs>>): Prisma__order_itemClient<$Result.GetResult<Prisma.$order_itemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Order_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_itemCountArgs} args - Arguments to filter Order_items to count.
     * @example
     * // Count the number of Order_items
     * const count = await prisma.order_item.count({
     *   where: {
     *     // ... the filter for the Order_items we want to count
     *   }
     * })
    **/
    count<T extends order_itemCountArgs>(
      args?: Subset<T, order_itemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Order_itemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order_item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Order_itemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Order_itemAggregateArgs>(args: Subset<T, Order_itemAggregateArgs>): Prisma.PrismaPromise<GetOrder_itemAggregateType<T>>

    /**
     * Group by Order_item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_itemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends order_itemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: order_itemGroupByArgs['orderBy'] }
        : { orderBy?: order_itemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, order_itemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrder_itemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the order_item model
   */
  readonly fields: order_itemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for order_item.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__order_itemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    menu_item<T extends menu_itemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, menu_itemDefaultArgs<ExtArgs>>): Prisma__menu_itemClient<$Result.GetResult<Prisma.$menu_itemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    order<T extends orderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, orderDefaultArgs<ExtArgs>>): Prisma__orderClient<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    options<T extends order_item$optionsArgs<ExtArgs> = {}>(args?: Subset<T, order_item$optionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$order_item_optionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the order_item model
   */
  interface order_itemFieldRefs {
    readonly id: FieldRef<"order_item", 'String'>
    readonly order_id: FieldRef<"order_item", 'String'>
    readonly menu_item_id: FieldRef<"order_item", 'String'>
    readonly note: FieldRef<"order_item", 'String'>
    readonly quantity: FieldRef<"order_item", 'BigInt'>
    readonly price: FieldRef<"order_item", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * order_item findUnique
   */
  export type order_itemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_item
     */
    select?: order_itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_item
     */
    omit?: order_itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_itemInclude<ExtArgs> | null
    /**
     * Filter, which order_item to fetch.
     */
    where: order_itemWhereUniqueInput
  }

  /**
   * order_item findUniqueOrThrow
   */
  export type order_itemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_item
     */
    select?: order_itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_item
     */
    omit?: order_itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_itemInclude<ExtArgs> | null
    /**
     * Filter, which order_item to fetch.
     */
    where: order_itemWhereUniqueInput
  }

  /**
   * order_item findFirst
   */
  export type order_itemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_item
     */
    select?: order_itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_item
     */
    omit?: order_itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_itemInclude<ExtArgs> | null
    /**
     * Filter, which order_item to fetch.
     */
    where?: order_itemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_items to fetch.
     */
    orderBy?: order_itemOrderByWithRelationInput | order_itemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for order_items.
     */
    cursor?: order_itemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of order_items.
     */
    distinct?: Order_itemScalarFieldEnum | Order_itemScalarFieldEnum[]
  }

  /**
   * order_item findFirstOrThrow
   */
  export type order_itemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_item
     */
    select?: order_itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_item
     */
    omit?: order_itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_itemInclude<ExtArgs> | null
    /**
     * Filter, which order_item to fetch.
     */
    where?: order_itemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_items to fetch.
     */
    orderBy?: order_itemOrderByWithRelationInput | order_itemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for order_items.
     */
    cursor?: order_itemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of order_items.
     */
    distinct?: Order_itemScalarFieldEnum | Order_itemScalarFieldEnum[]
  }

  /**
   * order_item findMany
   */
  export type order_itemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_item
     */
    select?: order_itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_item
     */
    omit?: order_itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_itemInclude<ExtArgs> | null
    /**
     * Filter, which order_items to fetch.
     */
    where?: order_itemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_items to fetch.
     */
    orderBy?: order_itemOrderByWithRelationInput | order_itemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing order_items.
     */
    cursor?: order_itemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_items.
     */
    skip?: number
    distinct?: Order_itemScalarFieldEnum | Order_itemScalarFieldEnum[]
  }

  /**
   * order_item create
   */
  export type order_itemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_item
     */
    select?: order_itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_item
     */
    omit?: order_itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_itemInclude<ExtArgs> | null
    /**
     * The data needed to create a order_item.
     */
    data: XOR<order_itemCreateInput, order_itemUncheckedCreateInput>
  }

  /**
   * order_item createMany
   */
  export type order_itemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many order_items.
     */
    data: order_itemCreateManyInput | order_itemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * order_item createManyAndReturn
   */
  export type order_itemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_item
     */
    select?: order_itemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the order_item
     */
    omit?: order_itemOmit<ExtArgs> | null
    /**
     * The data used to create many order_items.
     */
    data: order_itemCreateManyInput | order_itemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_itemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * order_item update
   */
  export type order_itemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_item
     */
    select?: order_itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_item
     */
    omit?: order_itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_itemInclude<ExtArgs> | null
    /**
     * The data needed to update a order_item.
     */
    data: XOR<order_itemUpdateInput, order_itemUncheckedUpdateInput>
    /**
     * Choose, which order_item to update.
     */
    where: order_itemWhereUniqueInput
  }

  /**
   * order_item updateMany
   */
  export type order_itemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update order_items.
     */
    data: XOR<order_itemUpdateManyMutationInput, order_itemUncheckedUpdateManyInput>
    /**
     * Filter which order_items to update
     */
    where?: order_itemWhereInput
    /**
     * Limit how many order_items to update.
     */
    limit?: number
  }

  /**
   * order_item updateManyAndReturn
   */
  export type order_itemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_item
     */
    select?: order_itemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the order_item
     */
    omit?: order_itemOmit<ExtArgs> | null
    /**
     * The data used to update order_items.
     */
    data: XOR<order_itemUpdateManyMutationInput, order_itemUncheckedUpdateManyInput>
    /**
     * Filter which order_items to update
     */
    where?: order_itemWhereInput
    /**
     * Limit how many order_items to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_itemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * order_item upsert
   */
  export type order_itemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_item
     */
    select?: order_itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_item
     */
    omit?: order_itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_itemInclude<ExtArgs> | null
    /**
     * The filter to search for the order_item to update in case it exists.
     */
    where: order_itemWhereUniqueInput
    /**
     * In case the order_item found by the `where` argument doesn't exist, create a new order_item with this data.
     */
    create: XOR<order_itemCreateInput, order_itemUncheckedCreateInput>
    /**
     * In case the order_item was found with the provided `where` argument, update it with this data.
     */
    update: XOR<order_itemUpdateInput, order_itemUncheckedUpdateInput>
  }

  /**
   * order_item delete
   */
  export type order_itemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_item
     */
    select?: order_itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_item
     */
    omit?: order_itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_itemInclude<ExtArgs> | null
    /**
     * Filter which order_item to delete.
     */
    where: order_itemWhereUniqueInput
  }

  /**
   * order_item deleteMany
   */
  export type order_itemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which order_items to delete
     */
    where?: order_itemWhereInput
    /**
     * Limit how many order_items to delete.
     */
    limit?: number
  }

  /**
   * order_item.options
   */
  export type order_item$optionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_item_option
     */
    select?: order_item_optionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_item_option
     */
    omit?: order_item_optionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_item_optionInclude<ExtArgs> | null
    where?: order_item_optionWhereInput
    orderBy?: order_item_optionOrderByWithRelationInput | order_item_optionOrderByWithRelationInput[]
    cursor?: order_item_optionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Order_item_optionScalarFieldEnum | Order_item_optionScalarFieldEnum[]
  }

  /**
   * order_item without action
   */
  export type order_itemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_item
     */
    select?: order_itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_item
     */
    omit?: order_itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_itemInclude<ExtArgs> | null
  }


  /**
   * Model order_item_option
   */

  export type AggregateOrder_item_option = {
    _count: Order_item_optionCountAggregateOutputType | null
    _min: Order_item_optionMinAggregateOutputType | null
    _max: Order_item_optionMaxAggregateOutputType | null
  }

  export type Order_item_optionMinAggregateOutputType = {
    order_item_id: string | null
    option_item_id: string | null
  }

  export type Order_item_optionMaxAggregateOutputType = {
    order_item_id: string | null
    option_item_id: string | null
  }

  export type Order_item_optionCountAggregateOutputType = {
    order_item_id: number
    option_item_id: number
    _all: number
  }


  export type Order_item_optionMinAggregateInputType = {
    order_item_id?: true
    option_item_id?: true
  }

  export type Order_item_optionMaxAggregateInputType = {
    order_item_id?: true
    option_item_id?: true
  }

  export type Order_item_optionCountAggregateInputType = {
    order_item_id?: true
    option_item_id?: true
    _all?: true
  }

  export type Order_item_optionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which order_item_option to aggregate.
     */
    where?: order_item_optionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_item_options to fetch.
     */
    orderBy?: order_item_optionOrderByWithRelationInput | order_item_optionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: order_item_optionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_item_options from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_item_options.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned order_item_options
    **/
    _count?: true | Order_item_optionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Order_item_optionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Order_item_optionMaxAggregateInputType
  }

  export type GetOrder_item_optionAggregateType<T extends Order_item_optionAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder_item_option]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder_item_option[P]>
      : GetScalarType<T[P], AggregateOrder_item_option[P]>
  }




  export type order_item_optionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: order_item_optionWhereInput
    orderBy?: order_item_optionOrderByWithAggregationInput | order_item_optionOrderByWithAggregationInput[]
    by: Order_item_optionScalarFieldEnum[] | Order_item_optionScalarFieldEnum
    having?: order_item_optionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Order_item_optionCountAggregateInputType | true
    _min?: Order_item_optionMinAggregateInputType
    _max?: Order_item_optionMaxAggregateInputType
  }

  export type Order_item_optionGroupByOutputType = {
    order_item_id: string
    option_item_id: string
    _count: Order_item_optionCountAggregateOutputType | null
    _min: Order_item_optionMinAggregateOutputType | null
    _max: Order_item_optionMaxAggregateOutputType | null
  }

  type GetOrder_item_optionGroupByPayload<T extends order_item_optionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Order_item_optionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Order_item_optionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Order_item_optionGroupByOutputType[P]>
            : GetScalarType<T[P], Order_item_optionGroupByOutputType[P]>
        }
      >
    >


  export type order_item_optionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    order_item_id?: boolean
    option_item_id?: boolean
    option_item?: boolean | option_itemDefaultArgs<ExtArgs>
    order_item?: boolean | order_itemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order_item_option"]>

  export type order_item_optionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    order_item_id?: boolean
    option_item_id?: boolean
    option_item?: boolean | option_itemDefaultArgs<ExtArgs>
    order_item?: boolean | order_itemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order_item_option"]>

  export type order_item_optionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    order_item_id?: boolean
    option_item_id?: boolean
    option_item?: boolean | option_itemDefaultArgs<ExtArgs>
    order_item?: boolean | order_itemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order_item_option"]>

  export type order_item_optionSelectScalar = {
    order_item_id?: boolean
    option_item_id?: boolean
  }

  export type order_item_optionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"order_item_id" | "option_item_id", ExtArgs["result"]["order_item_option"]>
  export type order_item_optionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    option_item?: boolean | option_itemDefaultArgs<ExtArgs>
    order_item?: boolean | order_itemDefaultArgs<ExtArgs>
  }
  export type order_item_optionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    option_item?: boolean | option_itemDefaultArgs<ExtArgs>
    order_item?: boolean | order_itemDefaultArgs<ExtArgs>
  }
  export type order_item_optionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    option_item?: boolean | option_itemDefaultArgs<ExtArgs>
    order_item?: boolean | order_itemDefaultArgs<ExtArgs>
  }

  export type $order_item_optionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "order_item_option"
    objects: {
      option_item: Prisma.$option_itemPayload<ExtArgs>
      order_item: Prisma.$order_itemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      order_item_id: string
      option_item_id: string
    }, ExtArgs["result"]["order_item_option"]>
    composites: {}
  }

  type order_item_optionGetPayload<S extends boolean | null | undefined | order_item_optionDefaultArgs> = $Result.GetResult<Prisma.$order_item_optionPayload, S>

  type order_item_optionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<order_item_optionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Order_item_optionCountAggregateInputType | true
    }

  export interface order_item_optionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['order_item_option'], meta: { name: 'order_item_option' } }
    /**
     * Find zero or one Order_item_option that matches the filter.
     * @param {order_item_optionFindUniqueArgs} args - Arguments to find a Order_item_option
     * @example
     * // Get one Order_item_option
     * const order_item_option = await prisma.order_item_option.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends order_item_optionFindUniqueArgs>(args: SelectSubset<T, order_item_optionFindUniqueArgs<ExtArgs>>): Prisma__order_item_optionClient<$Result.GetResult<Prisma.$order_item_optionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Order_item_option that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {order_item_optionFindUniqueOrThrowArgs} args - Arguments to find a Order_item_option
     * @example
     * // Get one Order_item_option
     * const order_item_option = await prisma.order_item_option.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends order_item_optionFindUniqueOrThrowArgs>(args: SelectSubset<T, order_item_optionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__order_item_optionClient<$Result.GetResult<Prisma.$order_item_optionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order_item_option that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_item_optionFindFirstArgs} args - Arguments to find a Order_item_option
     * @example
     * // Get one Order_item_option
     * const order_item_option = await prisma.order_item_option.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends order_item_optionFindFirstArgs>(args?: SelectSubset<T, order_item_optionFindFirstArgs<ExtArgs>>): Prisma__order_item_optionClient<$Result.GetResult<Prisma.$order_item_optionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order_item_option that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_item_optionFindFirstOrThrowArgs} args - Arguments to find a Order_item_option
     * @example
     * // Get one Order_item_option
     * const order_item_option = await prisma.order_item_option.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends order_item_optionFindFirstOrThrowArgs>(args?: SelectSubset<T, order_item_optionFindFirstOrThrowArgs<ExtArgs>>): Prisma__order_item_optionClient<$Result.GetResult<Prisma.$order_item_optionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Order_item_options that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_item_optionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Order_item_options
     * const order_item_options = await prisma.order_item_option.findMany()
     * 
     * // Get first 10 Order_item_options
     * const order_item_options = await prisma.order_item_option.findMany({ take: 10 })
     * 
     * // Only select the `order_item_id`
     * const order_item_optionWithOrder_item_idOnly = await prisma.order_item_option.findMany({ select: { order_item_id: true } })
     * 
     */
    findMany<T extends order_item_optionFindManyArgs>(args?: SelectSubset<T, order_item_optionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$order_item_optionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Order_item_option.
     * @param {order_item_optionCreateArgs} args - Arguments to create a Order_item_option.
     * @example
     * // Create one Order_item_option
     * const Order_item_option = await prisma.order_item_option.create({
     *   data: {
     *     // ... data to create a Order_item_option
     *   }
     * })
     * 
     */
    create<T extends order_item_optionCreateArgs>(args: SelectSubset<T, order_item_optionCreateArgs<ExtArgs>>): Prisma__order_item_optionClient<$Result.GetResult<Prisma.$order_item_optionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Order_item_options.
     * @param {order_item_optionCreateManyArgs} args - Arguments to create many Order_item_options.
     * @example
     * // Create many Order_item_options
     * const order_item_option = await prisma.order_item_option.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends order_item_optionCreateManyArgs>(args?: SelectSubset<T, order_item_optionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Order_item_options and returns the data saved in the database.
     * @param {order_item_optionCreateManyAndReturnArgs} args - Arguments to create many Order_item_options.
     * @example
     * // Create many Order_item_options
     * const order_item_option = await prisma.order_item_option.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Order_item_options and only return the `order_item_id`
     * const order_item_optionWithOrder_item_idOnly = await prisma.order_item_option.createManyAndReturn({
     *   select: { order_item_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends order_item_optionCreateManyAndReturnArgs>(args?: SelectSubset<T, order_item_optionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$order_item_optionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Order_item_option.
     * @param {order_item_optionDeleteArgs} args - Arguments to delete one Order_item_option.
     * @example
     * // Delete one Order_item_option
     * const Order_item_option = await prisma.order_item_option.delete({
     *   where: {
     *     // ... filter to delete one Order_item_option
     *   }
     * })
     * 
     */
    delete<T extends order_item_optionDeleteArgs>(args: SelectSubset<T, order_item_optionDeleteArgs<ExtArgs>>): Prisma__order_item_optionClient<$Result.GetResult<Prisma.$order_item_optionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Order_item_option.
     * @param {order_item_optionUpdateArgs} args - Arguments to update one Order_item_option.
     * @example
     * // Update one Order_item_option
     * const order_item_option = await prisma.order_item_option.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends order_item_optionUpdateArgs>(args: SelectSubset<T, order_item_optionUpdateArgs<ExtArgs>>): Prisma__order_item_optionClient<$Result.GetResult<Prisma.$order_item_optionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Order_item_options.
     * @param {order_item_optionDeleteManyArgs} args - Arguments to filter Order_item_options to delete.
     * @example
     * // Delete a few Order_item_options
     * const { count } = await prisma.order_item_option.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends order_item_optionDeleteManyArgs>(args?: SelectSubset<T, order_item_optionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Order_item_options.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_item_optionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Order_item_options
     * const order_item_option = await prisma.order_item_option.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends order_item_optionUpdateManyArgs>(args: SelectSubset<T, order_item_optionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Order_item_options and returns the data updated in the database.
     * @param {order_item_optionUpdateManyAndReturnArgs} args - Arguments to update many Order_item_options.
     * @example
     * // Update many Order_item_options
     * const order_item_option = await prisma.order_item_option.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Order_item_options and only return the `order_item_id`
     * const order_item_optionWithOrder_item_idOnly = await prisma.order_item_option.updateManyAndReturn({
     *   select: { order_item_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends order_item_optionUpdateManyAndReturnArgs>(args: SelectSubset<T, order_item_optionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$order_item_optionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Order_item_option.
     * @param {order_item_optionUpsertArgs} args - Arguments to update or create a Order_item_option.
     * @example
     * // Update or create a Order_item_option
     * const order_item_option = await prisma.order_item_option.upsert({
     *   create: {
     *     // ... data to create a Order_item_option
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order_item_option we want to update
     *   }
     * })
     */
    upsert<T extends order_item_optionUpsertArgs>(args: SelectSubset<T, order_item_optionUpsertArgs<ExtArgs>>): Prisma__order_item_optionClient<$Result.GetResult<Prisma.$order_item_optionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Order_item_options.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_item_optionCountArgs} args - Arguments to filter Order_item_options to count.
     * @example
     * // Count the number of Order_item_options
     * const count = await prisma.order_item_option.count({
     *   where: {
     *     // ... the filter for the Order_item_options we want to count
     *   }
     * })
    **/
    count<T extends order_item_optionCountArgs>(
      args?: Subset<T, order_item_optionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Order_item_optionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order_item_option.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Order_item_optionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Order_item_optionAggregateArgs>(args: Subset<T, Order_item_optionAggregateArgs>): Prisma.PrismaPromise<GetOrder_item_optionAggregateType<T>>

    /**
     * Group by Order_item_option.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_item_optionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends order_item_optionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: order_item_optionGroupByArgs['orderBy'] }
        : { orderBy?: order_item_optionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, order_item_optionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrder_item_optionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the order_item_option model
   */
  readonly fields: order_item_optionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for order_item_option.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__order_item_optionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    option_item<T extends option_itemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, option_itemDefaultArgs<ExtArgs>>): Prisma__option_itemClient<$Result.GetResult<Prisma.$option_itemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    order_item<T extends order_itemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, order_itemDefaultArgs<ExtArgs>>): Prisma__order_itemClient<$Result.GetResult<Prisma.$order_itemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the order_item_option model
   */
  interface order_item_optionFieldRefs {
    readonly order_item_id: FieldRef<"order_item_option", 'String'>
    readonly option_item_id: FieldRef<"order_item_option", 'String'>
  }
    

  // Custom InputTypes
  /**
   * order_item_option findUnique
   */
  export type order_item_optionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_item_option
     */
    select?: order_item_optionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_item_option
     */
    omit?: order_item_optionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_item_optionInclude<ExtArgs> | null
    /**
     * Filter, which order_item_option to fetch.
     */
    where: order_item_optionWhereUniqueInput
  }

  /**
   * order_item_option findUniqueOrThrow
   */
  export type order_item_optionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_item_option
     */
    select?: order_item_optionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_item_option
     */
    omit?: order_item_optionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_item_optionInclude<ExtArgs> | null
    /**
     * Filter, which order_item_option to fetch.
     */
    where: order_item_optionWhereUniqueInput
  }

  /**
   * order_item_option findFirst
   */
  export type order_item_optionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_item_option
     */
    select?: order_item_optionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_item_option
     */
    omit?: order_item_optionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_item_optionInclude<ExtArgs> | null
    /**
     * Filter, which order_item_option to fetch.
     */
    where?: order_item_optionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_item_options to fetch.
     */
    orderBy?: order_item_optionOrderByWithRelationInput | order_item_optionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for order_item_options.
     */
    cursor?: order_item_optionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_item_options from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_item_options.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of order_item_options.
     */
    distinct?: Order_item_optionScalarFieldEnum | Order_item_optionScalarFieldEnum[]
  }

  /**
   * order_item_option findFirstOrThrow
   */
  export type order_item_optionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_item_option
     */
    select?: order_item_optionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_item_option
     */
    omit?: order_item_optionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_item_optionInclude<ExtArgs> | null
    /**
     * Filter, which order_item_option to fetch.
     */
    where?: order_item_optionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_item_options to fetch.
     */
    orderBy?: order_item_optionOrderByWithRelationInput | order_item_optionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for order_item_options.
     */
    cursor?: order_item_optionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_item_options from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_item_options.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of order_item_options.
     */
    distinct?: Order_item_optionScalarFieldEnum | Order_item_optionScalarFieldEnum[]
  }

  /**
   * order_item_option findMany
   */
  export type order_item_optionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_item_option
     */
    select?: order_item_optionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_item_option
     */
    omit?: order_item_optionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_item_optionInclude<ExtArgs> | null
    /**
     * Filter, which order_item_options to fetch.
     */
    where?: order_item_optionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_item_options to fetch.
     */
    orderBy?: order_item_optionOrderByWithRelationInput | order_item_optionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing order_item_options.
     */
    cursor?: order_item_optionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_item_options from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_item_options.
     */
    skip?: number
    distinct?: Order_item_optionScalarFieldEnum | Order_item_optionScalarFieldEnum[]
  }

  /**
   * order_item_option create
   */
  export type order_item_optionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_item_option
     */
    select?: order_item_optionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_item_option
     */
    omit?: order_item_optionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_item_optionInclude<ExtArgs> | null
    /**
     * The data needed to create a order_item_option.
     */
    data: XOR<order_item_optionCreateInput, order_item_optionUncheckedCreateInput>
  }

  /**
   * order_item_option createMany
   */
  export type order_item_optionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many order_item_options.
     */
    data: order_item_optionCreateManyInput | order_item_optionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * order_item_option createManyAndReturn
   */
  export type order_item_optionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_item_option
     */
    select?: order_item_optionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the order_item_option
     */
    omit?: order_item_optionOmit<ExtArgs> | null
    /**
     * The data used to create many order_item_options.
     */
    data: order_item_optionCreateManyInput | order_item_optionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_item_optionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * order_item_option update
   */
  export type order_item_optionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_item_option
     */
    select?: order_item_optionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_item_option
     */
    omit?: order_item_optionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_item_optionInclude<ExtArgs> | null
    /**
     * The data needed to update a order_item_option.
     */
    data: XOR<order_item_optionUpdateInput, order_item_optionUncheckedUpdateInput>
    /**
     * Choose, which order_item_option to update.
     */
    where: order_item_optionWhereUniqueInput
  }

  /**
   * order_item_option updateMany
   */
  export type order_item_optionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update order_item_options.
     */
    data: XOR<order_item_optionUpdateManyMutationInput, order_item_optionUncheckedUpdateManyInput>
    /**
     * Filter which order_item_options to update
     */
    where?: order_item_optionWhereInput
    /**
     * Limit how many order_item_options to update.
     */
    limit?: number
  }

  /**
   * order_item_option updateManyAndReturn
   */
  export type order_item_optionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_item_option
     */
    select?: order_item_optionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the order_item_option
     */
    omit?: order_item_optionOmit<ExtArgs> | null
    /**
     * The data used to update order_item_options.
     */
    data: XOR<order_item_optionUpdateManyMutationInput, order_item_optionUncheckedUpdateManyInput>
    /**
     * Filter which order_item_options to update
     */
    where?: order_item_optionWhereInput
    /**
     * Limit how many order_item_options to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_item_optionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * order_item_option upsert
   */
  export type order_item_optionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_item_option
     */
    select?: order_item_optionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_item_option
     */
    omit?: order_item_optionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_item_optionInclude<ExtArgs> | null
    /**
     * The filter to search for the order_item_option to update in case it exists.
     */
    where: order_item_optionWhereUniqueInput
    /**
     * In case the order_item_option found by the `where` argument doesn't exist, create a new order_item_option with this data.
     */
    create: XOR<order_item_optionCreateInput, order_item_optionUncheckedCreateInput>
    /**
     * In case the order_item_option was found with the provided `where` argument, update it with this data.
     */
    update: XOR<order_item_optionUpdateInput, order_item_optionUncheckedUpdateInput>
  }

  /**
   * order_item_option delete
   */
  export type order_item_optionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_item_option
     */
    select?: order_item_optionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_item_option
     */
    omit?: order_item_optionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_item_optionInclude<ExtArgs> | null
    /**
     * Filter which order_item_option to delete.
     */
    where: order_item_optionWhereUniqueInput
  }

  /**
   * order_item_option deleteMany
   */
  export type order_item_optionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which order_item_options to delete
     */
    where?: order_item_optionWhereInput
    /**
     * Limit how many order_item_options to delete.
     */
    limit?: number
  }

  /**
   * order_item_option without action
   */
  export type order_item_optionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_item_option
     */
    select?: order_item_optionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_item_option
     */
    omit?: order_item_optionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_item_optionInclude<ExtArgs> | null
  }


  /**
   * Model payment_transaction
   */

  export type AggregatePayment_transaction = {
    _count: Payment_transactionCountAggregateOutputType | null
    _avg: Payment_transactionAvgAggregateOutputType | null
    _sum: Payment_transactionSumAggregateOutputType | null
    _min: Payment_transactionMinAggregateOutputType | null
    _max: Payment_transactionMaxAggregateOutputType | null
  }

  export type Payment_transactionAvgAggregateOutputType = {
    amount: number | null
  }

  export type Payment_transactionSumAggregateOutputType = {
    amount: bigint | null
  }

  export type Payment_transactionMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    merchant_id: string | null
    order_id: string | null
    amount: bigint | null
    currency: string | null
    txn_ref: string | null
    transaction_no: string | null
    payment_method: string | null
    status: $Enums.PaymentStatus | null
    response_code: string | null
    bank_code: string | null
    pay_date: string | null
    tmn_code: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Payment_transactionMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    merchant_id: string | null
    order_id: string | null
    amount: bigint | null
    currency: string | null
    txn_ref: string | null
    transaction_no: string | null
    payment_method: string | null
    status: $Enums.PaymentStatus | null
    response_code: string | null
    bank_code: string | null
    pay_date: string | null
    tmn_code: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Payment_transactionCountAggregateOutputType = {
    id: number
    user_id: number
    merchant_id: number
    order_id: number
    amount: number
    currency: number
    txn_ref: number
    transaction_no: number
    payment_method: number
    status: number
    response_code: number
    bank_code: number
    pay_date: number
    tmn_code: number
    raw_payload: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Payment_transactionAvgAggregateInputType = {
    amount?: true
  }

  export type Payment_transactionSumAggregateInputType = {
    amount?: true
  }

  export type Payment_transactionMinAggregateInputType = {
    id?: true
    user_id?: true
    merchant_id?: true
    order_id?: true
    amount?: true
    currency?: true
    txn_ref?: true
    transaction_no?: true
    payment_method?: true
    status?: true
    response_code?: true
    bank_code?: true
    pay_date?: true
    tmn_code?: true
    created_at?: true
    updated_at?: true
  }

  export type Payment_transactionMaxAggregateInputType = {
    id?: true
    user_id?: true
    merchant_id?: true
    order_id?: true
    amount?: true
    currency?: true
    txn_ref?: true
    transaction_no?: true
    payment_method?: true
    status?: true
    response_code?: true
    bank_code?: true
    pay_date?: true
    tmn_code?: true
    created_at?: true
    updated_at?: true
  }

  export type Payment_transactionCountAggregateInputType = {
    id?: true
    user_id?: true
    merchant_id?: true
    order_id?: true
    amount?: true
    currency?: true
    txn_ref?: true
    transaction_no?: true
    payment_method?: true
    status?: true
    response_code?: true
    bank_code?: true
    pay_date?: true
    tmn_code?: true
    raw_payload?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Payment_transactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payment_transaction to aggregate.
     */
    where?: payment_transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_transactions to fetch.
     */
    orderBy?: payment_transactionOrderByWithRelationInput | payment_transactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: payment_transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned payment_transactions
    **/
    _count?: true | Payment_transactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Payment_transactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Payment_transactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Payment_transactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Payment_transactionMaxAggregateInputType
  }

  export type GetPayment_transactionAggregateType<T extends Payment_transactionAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment_transaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment_transaction[P]>
      : GetScalarType<T[P], AggregatePayment_transaction[P]>
  }




  export type payment_transactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: payment_transactionWhereInput
    orderBy?: payment_transactionOrderByWithAggregationInput | payment_transactionOrderByWithAggregationInput[]
    by: Payment_transactionScalarFieldEnum[] | Payment_transactionScalarFieldEnum
    having?: payment_transactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Payment_transactionCountAggregateInputType | true
    _avg?: Payment_transactionAvgAggregateInputType
    _sum?: Payment_transactionSumAggregateInputType
    _min?: Payment_transactionMinAggregateInputType
    _max?: Payment_transactionMaxAggregateInputType
  }

  export type Payment_transactionGroupByOutputType = {
    id: string
    user_id: string
    merchant_id: string
    order_id: string | null
    amount: bigint
    currency: string
    txn_ref: string
    transaction_no: string | null
    payment_method: string
    status: $Enums.PaymentStatus
    response_code: string | null
    bank_code: string | null
    pay_date: string | null
    tmn_code: string | null
    raw_payload: JsonValue | null
    created_at: Date
    updated_at: Date
    _count: Payment_transactionCountAggregateOutputType | null
    _avg: Payment_transactionAvgAggregateOutputType | null
    _sum: Payment_transactionSumAggregateOutputType | null
    _min: Payment_transactionMinAggregateOutputType | null
    _max: Payment_transactionMaxAggregateOutputType | null
  }

  type GetPayment_transactionGroupByPayload<T extends payment_transactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Payment_transactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Payment_transactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Payment_transactionGroupByOutputType[P]>
            : GetScalarType<T[P], Payment_transactionGroupByOutputType[P]>
        }
      >
    >


  export type payment_transactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    merchant_id?: boolean
    order_id?: boolean
    amount?: boolean
    currency?: boolean
    txn_ref?: boolean
    transaction_no?: boolean
    payment_method?: boolean
    status?: boolean
    response_code?: boolean
    bank_code?: boolean
    pay_date?: boolean
    tmn_code?: boolean
    raw_payload?: boolean
    created_at?: boolean
    updated_at?: boolean
    merchant?: boolean | merchantDefaultArgs<ExtArgs>
    order?: boolean | payment_transaction$orderArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment_transaction"]>

  export type payment_transactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    merchant_id?: boolean
    order_id?: boolean
    amount?: boolean
    currency?: boolean
    txn_ref?: boolean
    transaction_no?: boolean
    payment_method?: boolean
    status?: boolean
    response_code?: boolean
    bank_code?: boolean
    pay_date?: boolean
    tmn_code?: boolean
    raw_payload?: boolean
    created_at?: boolean
    updated_at?: boolean
    merchant?: boolean | merchantDefaultArgs<ExtArgs>
    order?: boolean | payment_transaction$orderArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment_transaction"]>

  export type payment_transactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    merchant_id?: boolean
    order_id?: boolean
    amount?: boolean
    currency?: boolean
    txn_ref?: boolean
    transaction_no?: boolean
    payment_method?: boolean
    status?: boolean
    response_code?: boolean
    bank_code?: boolean
    pay_date?: boolean
    tmn_code?: boolean
    raw_payload?: boolean
    created_at?: boolean
    updated_at?: boolean
    merchant?: boolean | merchantDefaultArgs<ExtArgs>
    order?: boolean | payment_transaction$orderArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment_transaction"]>

  export type payment_transactionSelectScalar = {
    id?: boolean
    user_id?: boolean
    merchant_id?: boolean
    order_id?: boolean
    amount?: boolean
    currency?: boolean
    txn_ref?: boolean
    transaction_no?: boolean
    payment_method?: boolean
    status?: boolean
    response_code?: boolean
    bank_code?: boolean
    pay_date?: boolean
    tmn_code?: boolean
    raw_payload?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type payment_transactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "merchant_id" | "order_id" | "amount" | "currency" | "txn_ref" | "transaction_no" | "payment_method" | "status" | "response_code" | "bank_code" | "pay_date" | "tmn_code" | "raw_payload" | "created_at" | "updated_at", ExtArgs["result"]["payment_transaction"]>
  export type payment_transactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    merchant?: boolean | merchantDefaultArgs<ExtArgs>
    order?: boolean | payment_transaction$orderArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type payment_transactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    merchant?: boolean | merchantDefaultArgs<ExtArgs>
    order?: boolean | payment_transaction$orderArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type payment_transactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    merchant?: boolean | merchantDefaultArgs<ExtArgs>
    order?: boolean | payment_transaction$orderArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $payment_transactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "payment_transaction"
    objects: {
      merchant: Prisma.$merchantPayload<ExtArgs>
      order: Prisma.$orderPayload<ExtArgs> | null
      user: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      merchant_id: string
      order_id: string | null
      amount: bigint
      currency: string
      txn_ref: string
      transaction_no: string | null
      payment_method: string
      status: $Enums.PaymentStatus
      response_code: string | null
      bank_code: string | null
      pay_date: string | null
      tmn_code: string | null
      raw_payload: Prisma.JsonValue | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["payment_transaction"]>
    composites: {}
  }

  type payment_transactionGetPayload<S extends boolean | null | undefined | payment_transactionDefaultArgs> = $Result.GetResult<Prisma.$payment_transactionPayload, S>

  type payment_transactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<payment_transactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Payment_transactionCountAggregateInputType | true
    }

  export interface payment_transactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['payment_transaction'], meta: { name: 'payment_transaction' } }
    /**
     * Find zero or one Payment_transaction that matches the filter.
     * @param {payment_transactionFindUniqueArgs} args - Arguments to find a Payment_transaction
     * @example
     * // Get one Payment_transaction
     * const payment_transaction = await prisma.payment_transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends payment_transactionFindUniqueArgs>(args: SelectSubset<T, payment_transactionFindUniqueArgs<ExtArgs>>): Prisma__payment_transactionClient<$Result.GetResult<Prisma.$payment_transactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment_transaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {payment_transactionFindUniqueOrThrowArgs} args - Arguments to find a Payment_transaction
     * @example
     * // Get one Payment_transaction
     * const payment_transaction = await prisma.payment_transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends payment_transactionFindUniqueOrThrowArgs>(args: SelectSubset<T, payment_transactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__payment_transactionClient<$Result.GetResult<Prisma.$payment_transactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment_transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_transactionFindFirstArgs} args - Arguments to find a Payment_transaction
     * @example
     * // Get one Payment_transaction
     * const payment_transaction = await prisma.payment_transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends payment_transactionFindFirstArgs>(args?: SelectSubset<T, payment_transactionFindFirstArgs<ExtArgs>>): Prisma__payment_transactionClient<$Result.GetResult<Prisma.$payment_transactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment_transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_transactionFindFirstOrThrowArgs} args - Arguments to find a Payment_transaction
     * @example
     * // Get one Payment_transaction
     * const payment_transaction = await prisma.payment_transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends payment_transactionFindFirstOrThrowArgs>(args?: SelectSubset<T, payment_transactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__payment_transactionClient<$Result.GetResult<Prisma.$payment_transactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payment_transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_transactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payment_transactions
     * const payment_transactions = await prisma.payment_transaction.findMany()
     * 
     * // Get first 10 Payment_transactions
     * const payment_transactions = await prisma.payment_transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const payment_transactionWithIdOnly = await prisma.payment_transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends payment_transactionFindManyArgs>(args?: SelectSubset<T, payment_transactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_transactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment_transaction.
     * @param {payment_transactionCreateArgs} args - Arguments to create a Payment_transaction.
     * @example
     * // Create one Payment_transaction
     * const Payment_transaction = await prisma.payment_transaction.create({
     *   data: {
     *     // ... data to create a Payment_transaction
     *   }
     * })
     * 
     */
    create<T extends payment_transactionCreateArgs>(args: SelectSubset<T, payment_transactionCreateArgs<ExtArgs>>): Prisma__payment_transactionClient<$Result.GetResult<Prisma.$payment_transactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payment_transactions.
     * @param {payment_transactionCreateManyArgs} args - Arguments to create many Payment_transactions.
     * @example
     * // Create many Payment_transactions
     * const payment_transaction = await prisma.payment_transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends payment_transactionCreateManyArgs>(args?: SelectSubset<T, payment_transactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payment_transactions and returns the data saved in the database.
     * @param {payment_transactionCreateManyAndReturnArgs} args - Arguments to create many Payment_transactions.
     * @example
     * // Create many Payment_transactions
     * const payment_transaction = await prisma.payment_transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payment_transactions and only return the `id`
     * const payment_transactionWithIdOnly = await prisma.payment_transaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends payment_transactionCreateManyAndReturnArgs>(args?: SelectSubset<T, payment_transactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_transactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment_transaction.
     * @param {payment_transactionDeleteArgs} args - Arguments to delete one Payment_transaction.
     * @example
     * // Delete one Payment_transaction
     * const Payment_transaction = await prisma.payment_transaction.delete({
     *   where: {
     *     // ... filter to delete one Payment_transaction
     *   }
     * })
     * 
     */
    delete<T extends payment_transactionDeleteArgs>(args: SelectSubset<T, payment_transactionDeleteArgs<ExtArgs>>): Prisma__payment_transactionClient<$Result.GetResult<Prisma.$payment_transactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment_transaction.
     * @param {payment_transactionUpdateArgs} args - Arguments to update one Payment_transaction.
     * @example
     * // Update one Payment_transaction
     * const payment_transaction = await prisma.payment_transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends payment_transactionUpdateArgs>(args: SelectSubset<T, payment_transactionUpdateArgs<ExtArgs>>): Prisma__payment_transactionClient<$Result.GetResult<Prisma.$payment_transactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payment_transactions.
     * @param {payment_transactionDeleteManyArgs} args - Arguments to filter Payment_transactions to delete.
     * @example
     * // Delete a few Payment_transactions
     * const { count } = await prisma.payment_transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends payment_transactionDeleteManyArgs>(args?: SelectSubset<T, payment_transactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payment_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_transactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payment_transactions
     * const payment_transaction = await prisma.payment_transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends payment_transactionUpdateManyArgs>(args: SelectSubset<T, payment_transactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payment_transactions and returns the data updated in the database.
     * @param {payment_transactionUpdateManyAndReturnArgs} args - Arguments to update many Payment_transactions.
     * @example
     * // Update many Payment_transactions
     * const payment_transaction = await prisma.payment_transaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payment_transactions and only return the `id`
     * const payment_transactionWithIdOnly = await prisma.payment_transaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends payment_transactionUpdateManyAndReturnArgs>(args: SelectSubset<T, payment_transactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_transactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment_transaction.
     * @param {payment_transactionUpsertArgs} args - Arguments to update or create a Payment_transaction.
     * @example
     * // Update or create a Payment_transaction
     * const payment_transaction = await prisma.payment_transaction.upsert({
     *   create: {
     *     // ... data to create a Payment_transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment_transaction we want to update
     *   }
     * })
     */
    upsert<T extends payment_transactionUpsertArgs>(args: SelectSubset<T, payment_transactionUpsertArgs<ExtArgs>>): Prisma__payment_transactionClient<$Result.GetResult<Prisma.$payment_transactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payment_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_transactionCountArgs} args - Arguments to filter Payment_transactions to count.
     * @example
     * // Count the number of Payment_transactions
     * const count = await prisma.payment_transaction.count({
     *   where: {
     *     // ... the filter for the Payment_transactions we want to count
     *   }
     * })
    **/
    count<T extends payment_transactionCountArgs>(
      args?: Subset<T, payment_transactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Payment_transactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment_transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Payment_transactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Payment_transactionAggregateArgs>(args: Subset<T, Payment_transactionAggregateArgs>): Prisma.PrismaPromise<GetPayment_transactionAggregateType<T>>

    /**
     * Group by Payment_transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_transactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends payment_transactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: payment_transactionGroupByArgs['orderBy'] }
        : { orderBy?: payment_transactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, payment_transactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayment_transactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the payment_transaction model
   */
  readonly fields: payment_transactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for payment_transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__payment_transactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    merchant<T extends merchantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, merchantDefaultArgs<ExtArgs>>): Prisma__merchantClient<$Result.GetResult<Prisma.$merchantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    order<T extends payment_transaction$orderArgs<ExtArgs> = {}>(args?: Subset<T, payment_transaction$orderArgs<ExtArgs>>): Prisma__orderClient<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the payment_transaction model
   */
  interface payment_transactionFieldRefs {
    readonly id: FieldRef<"payment_transaction", 'String'>
    readonly user_id: FieldRef<"payment_transaction", 'String'>
    readonly merchant_id: FieldRef<"payment_transaction", 'String'>
    readonly order_id: FieldRef<"payment_transaction", 'String'>
    readonly amount: FieldRef<"payment_transaction", 'BigInt'>
    readonly currency: FieldRef<"payment_transaction", 'String'>
    readonly txn_ref: FieldRef<"payment_transaction", 'String'>
    readonly transaction_no: FieldRef<"payment_transaction", 'String'>
    readonly payment_method: FieldRef<"payment_transaction", 'String'>
    readonly status: FieldRef<"payment_transaction", 'PaymentStatus'>
    readonly response_code: FieldRef<"payment_transaction", 'String'>
    readonly bank_code: FieldRef<"payment_transaction", 'String'>
    readonly pay_date: FieldRef<"payment_transaction", 'String'>
    readonly tmn_code: FieldRef<"payment_transaction", 'String'>
    readonly raw_payload: FieldRef<"payment_transaction", 'Json'>
    readonly created_at: FieldRef<"payment_transaction", 'DateTime'>
    readonly updated_at: FieldRef<"payment_transaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * payment_transaction findUnique
   */
  export type payment_transactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_transaction
     */
    select?: payment_transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_transaction
     */
    omit?: payment_transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_transactionInclude<ExtArgs> | null
    /**
     * Filter, which payment_transaction to fetch.
     */
    where: payment_transactionWhereUniqueInput
  }

  /**
   * payment_transaction findUniqueOrThrow
   */
  export type payment_transactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_transaction
     */
    select?: payment_transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_transaction
     */
    omit?: payment_transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_transactionInclude<ExtArgs> | null
    /**
     * Filter, which payment_transaction to fetch.
     */
    where: payment_transactionWhereUniqueInput
  }

  /**
   * payment_transaction findFirst
   */
  export type payment_transactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_transaction
     */
    select?: payment_transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_transaction
     */
    omit?: payment_transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_transactionInclude<ExtArgs> | null
    /**
     * Filter, which payment_transaction to fetch.
     */
    where?: payment_transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_transactions to fetch.
     */
    orderBy?: payment_transactionOrderByWithRelationInput | payment_transactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payment_transactions.
     */
    cursor?: payment_transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payment_transactions.
     */
    distinct?: Payment_transactionScalarFieldEnum | Payment_transactionScalarFieldEnum[]
  }

  /**
   * payment_transaction findFirstOrThrow
   */
  export type payment_transactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_transaction
     */
    select?: payment_transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_transaction
     */
    omit?: payment_transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_transactionInclude<ExtArgs> | null
    /**
     * Filter, which payment_transaction to fetch.
     */
    where?: payment_transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_transactions to fetch.
     */
    orderBy?: payment_transactionOrderByWithRelationInput | payment_transactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payment_transactions.
     */
    cursor?: payment_transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payment_transactions.
     */
    distinct?: Payment_transactionScalarFieldEnum | Payment_transactionScalarFieldEnum[]
  }

  /**
   * payment_transaction findMany
   */
  export type payment_transactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_transaction
     */
    select?: payment_transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_transaction
     */
    omit?: payment_transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_transactionInclude<ExtArgs> | null
    /**
     * Filter, which payment_transactions to fetch.
     */
    where?: payment_transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_transactions to fetch.
     */
    orderBy?: payment_transactionOrderByWithRelationInput | payment_transactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing payment_transactions.
     */
    cursor?: payment_transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_transactions.
     */
    skip?: number
    distinct?: Payment_transactionScalarFieldEnum | Payment_transactionScalarFieldEnum[]
  }

  /**
   * payment_transaction create
   */
  export type payment_transactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_transaction
     */
    select?: payment_transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_transaction
     */
    omit?: payment_transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_transactionInclude<ExtArgs> | null
    /**
     * The data needed to create a payment_transaction.
     */
    data: XOR<payment_transactionCreateInput, payment_transactionUncheckedCreateInput>
  }

  /**
   * payment_transaction createMany
   */
  export type payment_transactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many payment_transactions.
     */
    data: payment_transactionCreateManyInput | payment_transactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * payment_transaction createManyAndReturn
   */
  export type payment_transactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_transaction
     */
    select?: payment_transactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payment_transaction
     */
    omit?: payment_transactionOmit<ExtArgs> | null
    /**
     * The data used to create many payment_transactions.
     */
    data: payment_transactionCreateManyInput | payment_transactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_transactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * payment_transaction update
   */
  export type payment_transactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_transaction
     */
    select?: payment_transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_transaction
     */
    omit?: payment_transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_transactionInclude<ExtArgs> | null
    /**
     * The data needed to update a payment_transaction.
     */
    data: XOR<payment_transactionUpdateInput, payment_transactionUncheckedUpdateInput>
    /**
     * Choose, which payment_transaction to update.
     */
    where: payment_transactionWhereUniqueInput
  }

  /**
   * payment_transaction updateMany
   */
  export type payment_transactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update payment_transactions.
     */
    data: XOR<payment_transactionUpdateManyMutationInput, payment_transactionUncheckedUpdateManyInput>
    /**
     * Filter which payment_transactions to update
     */
    where?: payment_transactionWhereInput
    /**
     * Limit how many payment_transactions to update.
     */
    limit?: number
  }

  /**
   * payment_transaction updateManyAndReturn
   */
  export type payment_transactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_transaction
     */
    select?: payment_transactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payment_transaction
     */
    omit?: payment_transactionOmit<ExtArgs> | null
    /**
     * The data used to update payment_transactions.
     */
    data: XOR<payment_transactionUpdateManyMutationInput, payment_transactionUncheckedUpdateManyInput>
    /**
     * Filter which payment_transactions to update
     */
    where?: payment_transactionWhereInput
    /**
     * Limit how many payment_transactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_transactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * payment_transaction upsert
   */
  export type payment_transactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_transaction
     */
    select?: payment_transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_transaction
     */
    omit?: payment_transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_transactionInclude<ExtArgs> | null
    /**
     * The filter to search for the payment_transaction to update in case it exists.
     */
    where: payment_transactionWhereUniqueInput
    /**
     * In case the payment_transaction found by the `where` argument doesn't exist, create a new payment_transaction with this data.
     */
    create: XOR<payment_transactionCreateInput, payment_transactionUncheckedCreateInput>
    /**
     * In case the payment_transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<payment_transactionUpdateInput, payment_transactionUncheckedUpdateInput>
  }

  /**
   * payment_transaction delete
   */
  export type payment_transactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_transaction
     */
    select?: payment_transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_transaction
     */
    omit?: payment_transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_transactionInclude<ExtArgs> | null
    /**
     * Filter which payment_transaction to delete.
     */
    where: payment_transactionWhereUniqueInput
  }

  /**
   * payment_transaction deleteMany
   */
  export type payment_transactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payment_transactions to delete
     */
    where?: payment_transactionWhereInput
    /**
     * Limit how many payment_transactions to delete.
     */
    limit?: number
  }

  /**
   * payment_transaction.order
   */
  export type payment_transaction$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order
     */
    omit?: orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderInclude<ExtArgs> | null
    where?: orderWhereInput
  }

  /**
   * payment_transaction without action
   */
  export type payment_transactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_transaction
     */
    select?: payment_transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_transaction
     */
    omit?: payment_transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_transactionInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UsersScalarFieldEnum: {
    id: 'id',
    image: 'image',
    full_name: 'full_name',
    role: 'role',
    birth: 'birth',
    password: 'password',
    phone: 'phone',
    email: 'email',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const MerchantScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    merchant_name: 'merchant_name',
    location: 'location',
    phone: 'phone',
    email: 'email',
    profile_image: 'profile_image',
    cover_image: 'cover_image',
    time_open: 'time_open',
    cuisine: 'cuisine'
  };

  export type MerchantScalarFieldEnum = (typeof MerchantScalarFieldEnum)[keyof typeof MerchantScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    merchant_id: 'merchant_id',
    category_name: 'category_name'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const Menu_itemScalarFieldEnum: {
    id: 'id',
    merchant_id: 'merchant_id',
    category_id: 'category_id',
    name_item: 'name_item',
    likes: 'likes',
    price: 'price',
    description: 'description',
    sold_count: 'sold_count',
    image_item: 'image_item',
    status: 'status'
  };

  export type Menu_itemScalarFieldEnum = (typeof Menu_itemScalarFieldEnum)[keyof typeof Menu_itemScalarFieldEnum]


  export const OptionScalarFieldEnum: {
    id: 'id',
    merchant_id: 'merchant_id',
    option_name: 'option_name',
    multi_select: 'multi_select',
    require_select: 'require_select',
    number_select: 'number_select'
  };

  export type OptionScalarFieldEnum = (typeof OptionScalarFieldEnum)[keyof typeof OptionScalarFieldEnum]


  export const Option_itemScalarFieldEnum: {
    id: 'id',
    option_id: 'option_id',
    option_item_name: 'option_item_name',
    status: 'status',
    status_select: 'status_select'
  };

  export type Option_itemScalarFieldEnum = (typeof Option_itemScalarFieldEnum)[keyof typeof Option_itemScalarFieldEnum]


  export const Menu_item_optionScalarFieldEnum: {
    option_id: 'option_id',
    menu_item_id: 'menu_item_id'
  };

  export type Menu_item_optionScalarFieldEnum = (typeof Menu_item_optionScalarFieldEnum)[keyof typeof Menu_item_optionScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    merchant_id: 'merchant_id',
    user_id: 'user_id',
    full_name: 'full_name',
    phone: 'phone',
    delivery_address: 'delivery_address',
    delivery_fee: 'delivery_fee',
    note: 'note',
    total_amount: 'total_amount',
    created_at: 'created_at',
    updated_at: 'updated_at',
    status: 'status',
    status_payment: 'status_payment',
    payment_method: 'payment_method'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const Order_itemScalarFieldEnum: {
    id: 'id',
    order_id: 'order_id',
    menu_item_id: 'menu_item_id',
    note: 'note',
    quantity: 'quantity',
    price: 'price'
  };

  export type Order_itemScalarFieldEnum = (typeof Order_itemScalarFieldEnum)[keyof typeof Order_itemScalarFieldEnum]


  export const Order_item_optionScalarFieldEnum: {
    order_item_id: 'order_item_id',
    option_item_id: 'option_item_id'
  };

  export type Order_item_optionScalarFieldEnum = (typeof Order_item_optionScalarFieldEnum)[keyof typeof Order_item_optionScalarFieldEnum]


  export const Payment_transactionScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    merchant_id: 'merchant_id',
    order_id: 'order_id',
    amount: 'amount',
    currency: 'currency',
    txn_ref: 'txn_ref',
    transaction_no: 'transaction_no',
    payment_method: 'payment_method',
    status: 'status',
    response_code: 'response_code',
    bank_code: 'bank_code',
    pay_date: 'pay_date',
    tmn_code: 'tmn_code',
    raw_payload: 'raw_payload',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Payment_transactionScalarFieldEnum = (typeof Payment_transactionScalarFieldEnum)[keyof typeof Payment_transactionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    id?: UuidFilter<"users"> | string
    image?: JsonNullableFilter<"users">
    full_name?: StringFilter<"users"> | string
    role?: StringNullableFilter<"users"> | string | null
    birth?: DateTimeNullableFilter<"users"> | Date | string | null
    password?: StringFilter<"users"> | string
    phone?: StringFilter<"users"> | string
    email?: StringFilter<"users"> | string
    created_at?: DateTimeNullableFilter<"users"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"users"> | Date | string | null
    merchants?: MerchantListRelationFilter
    orders?: OrderListRelationFilter
    payment_transactions?: Payment_transactionListRelationFilter
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    image?: SortOrderInput | SortOrder
    full_name?: SortOrder
    role?: SortOrderInput | SortOrder
    birth?: SortOrderInput | SortOrder
    password?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    merchants?: merchantOrderByRelationAggregateInput
    orders?: orderOrderByRelationAggregateInput
    payment_transactions?: payment_transactionOrderByRelationAggregateInput
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    phone?: string
    email?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    image?: JsonNullableFilter<"users">
    full_name?: StringFilter<"users"> | string
    role?: StringNullableFilter<"users"> | string | null
    birth?: DateTimeNullableFilter<"users"> | Date | string | null
    password?: StringFilter<"users"> | string
    created_at?: DateTimeNullableFilter<"users"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"users"> | Date | string | null
    merchants?: MerchantListRelationFilter
    orders?: OrderListRelationFilter
    payment_transactions?: Payment_transactionListRelationFilter
  }, "id" | "phone" | "email">

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    image?: SortOrderInput | SortOrder
    full_name?: SortOrder
    role?: SortOrderInput | SortOrder
    birth?: SortOrderInput | SortOrder
    password?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: usersCountOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"users"> | string
    image?: JsonNullableWithAggregatesFilter<"users">
    full_name?: StringWithAggregatesFilter<"users"> | string
    role?: StringNullableWithAggregatesFilter<"users"> | string | null
    birth?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    password?: StringWithAggregatesFilter<"users"> | string
    phone?: StringWithAggregatesFilter<"users"> | string
    email?: StringWithAggregatesFilter<"users"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
  }

  export type merchantWhereInput = {
    AND?: merchantWhereInput | merchantWhereInput[]
    OR?: merchantWhereInput[]
    NOT?: merchantWhereInput | merchantWhereInput[]
    id?: UuidFilter<"merchant"> | string
    user_id?: UuidFilter<"merchant"> | string
    merchant_name?: StringFilter<"merchant"> | string
    location?: JsonNullableFilter<"merchant">
    phone?: StringNullableFilter<"merchant"> | string | null
    email?: StringNullableFilter<"merchant"> | string | null
    profile_image?: JsonNullableFilter<"merchant">
    cover_image?: JsonNullableFilter<"merchant">
    time_open?: JsonNullableFilter<"merchant">
    cuisine?: StringNullableFilter<"merchant"> | string | null
    categories?: CategoryListRelationFilter
    menu_item?: Menu_itemListRelationFilter
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
    option?: OptionListRelationFilter
    orders?: OrderListRelationFilter
    payment_transactions?: Payment_transactionListRelationFilter
  }

  export type merchantOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    merchant_name?: SortOrder
    location?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    profile_image?: SortOrderInput | SortOrder
    cover_image?: SortOrderInput | SortOrder
    time_open?: SortOrderInput | SortOrder
    cuisine?: SortOrderInput | SortOrder
    categories?: categoryOrderByRelationAggregateInput
    menu_item?: menu_itemOrderByRelationAggregateInput
    user?: usersOrderByWithRelationInput
    option?: optionOrderByRelationAggregateInput
    orders?: orderOrderByRelationAggregateInput
    payment_transactions?: payment_transactionOrderByRelationAggregateInput
  }

  export type merchantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: merchantWhereInput | merchantWhereInput[]
    OR?: merchantWhereInput[]
    NOT?: merchantWhereInput | merchantWhereInput[]
    user_id?: UuidFilter<"merchant"> | string
    merchant_name?: StringFilter<"merchant"> | string
    location?: JsonNullableFilter<"merchant">
    phone?: StringNullableFilter<"merchant"> | string | null
    email?: StringNullableFilter<"merchant"> | string | null
    profile_image?: JsonNullableFilter<"merchant">
    cover_image?: JsonNullableFilter<"merchant">
    time_open?: JsonNullableFilter<"merchant">
    cuisine?: StringNullableFilter<"merchant"> | string | null
    categories?: CategoryListRelationFilter
    menu_item?: Menu_itemListRelationFilter
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
    option?: OptionListRelationFilter
    orders?: OrderListRelationFilter
    payment_transactions?: Payment_transactionListRelationFilter
  }, "id">

  export type merchantOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    merchant_name?: SortOrder
    location?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    profile_image?: SortOrderInput | SortOrder
    cover_image?: SortOrderInput | SortOrder
    time_open?: SortOrderInput | SortOrder
    cuisine?: SortOrderInput | SortOrder
    _count?: merchantCountOrderByAggregateInput
    _max?: merchantMaxOrderByAggregateInput
    _min?: merchantMinOrderByAggregateInput
  }

  export type merchantScalarWhereWithAggregatesInput = {
    AND?: merchantScalarWhereWithAggregatesInput | merchantScalarWhereWithAggregatesInput[]
    OR?: merchantScalarWhereWithAggregatesInput[]
    NOT?: merchantScalarWhereWithAggregatesInput | merchantScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"merchant"> | string
    user_id?: UuidWithAggregatesFilter<"merchant"> | string
    merchant_name?: StringWithAggregatesFilter<"merchant"> | string
    location?: JsonNullableWithAggregatesFilter<"merchant">
    phone?: StringNullableWithAggregatesFilter<"merchant"> | string | null
    email?: StringNullableWithAggregatesFilter<"merchant"> | string | null
    profile_image?: JsonNullableWithAggregatesFilter<"merchant">
    cover_image?: JsonNullableWithAggregatesFilter<"merchant">
    time_open?: JsonNullableWithAggregatesFilter<"merchant">
    cuisine?: StringNullableWithAggregatesFilter<"merchant"> | string | null
  }

  export type categoryWhereInput = {
    AND?: categoryWhereInput | categoryWhereInput[]
    OR?: categoryWhereInput[]
    NOT?: categoryWhereInput | categoryWhereInput[]
    id?: UuidFilter<"category"> | string
    merchant_id?: UuidFilter<"category"> | string
    category_name?: StringFilter<"category"> | string
    merchant?: XOR<MerchantScalarRelationFilter, merchantWhereInput>
    menu_item?: Menu_itemListRelationFilter
  }

  export type categoryOrderByWithRelationInput = {
    id?: SortOrder
    merchant_id?: SortOrder
    category_name?: SortOrder
    merchant?: merchantOrderByWithRelationInput
    menu_item?: menu_itemOrderByRelationAggregateInput
  }

  export type categoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: categoryWhereInput | categoryWhereInput[]
    OR?: categoryWhereInput[]
    NOT?: categoryWhereInput | categoryWhereInput[]
    merchant_id?: UuidFilter<"category"> | string
    category_name?: StringFilter<"category"> | string
    merchant?: XOR<MerchantScalarRelationFilter, merchantWhereInput>
    menu_item?: Menu_itemListRelationFilter
  }, "id">

  export type categoryOrderByWithAggregationInput = {
    id?: SortOrder
    merchant_id?: SortOrder
    category_name?: SortOrder
    _count?: categoryCountOrderByAggregateInput
    _max?: categoryMaxOrderByAggregateInput
    _min?: categoryMinOrderByAggregateInput
  }

  export type categoryScalarWhereWithAggregatesInput = {
    AND?: categoryScalarWhereWithAggregatesInput | categoryScalarWhereWithAggregatesInput[]
    OR?: categoryScalarWhereWithAggregatesInput[]
    NOT?: categoryScalarWhereWithAggregatesInput | categoryScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"category"> | string
    merchant_id?: UuidWithAggregatesFilter<"category"> | string
    category_name?: StringWithAggregatesFilter<"category"> | string
  }

  export type menu_itemWhereInput = {
    AND?: menu_itemWhereInput | menu_itemWhereInput[]
    OR?: menu_itemWhereInput[]
    NOT?: menu_itemWhereInput | menu_itemWhereInput[]
    id?: UuidFilter<"menu_item"> | string
    merchant_id?: UuidFilter<"menu_item"> | string
    category_id?: UuidNullableFilter<"menu_item"> | string | null
    name_item?: StringFilter<"menu_item"> | string
    likes?: BigIntFilter<"menu_item"> | bigint | number
    price?: BigIntFilter<"menu_item"> | bigint | number
    description?: StringNullableFilter<"menu_item"> | string | null
    sold_count?: BigIntFilter<"menu_item"> | bigint | number
    image_item?: JsonNullableFilter<"menu_item">
    status?: BoolFilter<"menu_item"> | boolean
    category?: XOR<CategoryNullableScalarRelationFilter, categoryWhereInput> | null
    merchant?: XOR<MerchantScalarRelationFilter, merchantWhereInput>
    menu_item_option?: Menu_item_optionListRelationFilter
    order_items?: Order_itemListRelationFilter
  }

  export type menu_itemOrderByWithRelationInput = {
    id?: SortOrder
    merchant_id?: SortOrder
    category_id?: SortOrderInput | SortOrder
    name_item?: SortOrder
    likes?: SortOrder
    price?: SortOrder
    description?: SortOrderInput | SortOrder
    sold_count?: SortOrder
    image_item?: SortOrderInput | SortOrder
    status?: SortOrder
    category?: categoryOrderByWithRelationInput
    merchant?: merchantOrderByWithRelationInput
    menu_item_option?: menu_item_optionOrderByRelationAggregateInput
    order_items?: order_itemOrderByRelationAggregateInput
  }

  export type menu_itemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: menu_itemWhereInput | menu_itemWhereInput[]
    OR?: menu_itemWhereInput[]
    NOT?: menu_itemWhereInput | menu_itemWhereInput[]
    merchant_id?: UuidFilter<"menu_item"> | string
    category_id?: UuidNullableFilter<"menu_item"> | string | null
    name_item?: StringFilter<"menu_item"> | string
    likes?: BigIntFilter<"menu_item"> | bigint | number
    price?: BigIntFilter<"menu_item"> | bigint | number
    description?: StringNullableFilter<"menu_item"> | string | null
    sold_count?: BigIntFilter<"menu_item"> | bigint | number
    image_item?: JsonNullableFilter<"menu_item">
    status?: BoolFilter<"menu_item"> | boolean
    category?: XOR<CategoryNullableScalarRelationFilter, categoryWhereInput> | null
    merchant?: XOR<MerchantScalarRelationFilter, merchantWhereInput>
    menu_item_option?: Menu_item_optionListRelationFilter
    order_items?: Order_itemListRelationFilter
  }, "id">

  export type menu_itemOrderByWithAggregationInput = {
    id?: SortOrder
    merchant_id?: SortOrder
    category_id?: SortOrderInput | SortOrder
    name_item?: SortOrder
    likes?: SortOrder
    price?: SortOrder
    description?: SortOrderInput | SortOrder
    sold_count?: SortOrder
    image_item?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: menu_itemCountOrderByAggregateInput
    _avg?: menu_itemAvgOrderByAggregateInput
    _max?: menu_itemMaxOrderByAggregateInput
    _min?: menu_itemMinOrderByAggregateInput
    _sum?: menu_itemSumOrderByAggregateInput
  }

  export type menu_itemScalarWhereWithAggregatesInput = {
    AND?: menu_itemScalarWhereWithAggregatesInput | menu_itemScalarWhereWithAggregatesInput[]
    OR?: menu_itemScalarWhereWithAggregatesInput[]
    NOT?: menu_itemScalarWhereWithAggregatesInput | menu_itemScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"menu_item"> | string
    merchant_id?: UuidWithAggregatesFilter<"menu_item"> | string
    category_id?: UuidNullableWithAggregatesFilter<"menu_item"> | string | null
    name_item?: StringWithAggregatesFilter<"menu_item"> | string
    likes?: BigIntWithAggregatesFilter<"menu_item"> | bigint | number
    price?: BigIntWithAggregatesFilter<"menu_item"> | bigint | number
    description?: StringNullableWithAggregatesFilter<"menu_item"> | string | null
    sold_count?: BigIntWithAggregatesFilter<"menu_item"> | bigint | number
    image_item?: JsonNullableWithAggregatesFilter<"menu_item">
    status?: BoolWithAggregatesFilter<"menu_item"> | boolean
  }

  export type optionWhereInput = {
    AND?: optionWhereInput | optionWhereInput[]
    OR?: optionWhereInput[]
    NOT?: optionWhereInput | optionWhereInput[]
    id?: UuidFilter<"option"> | string
    merchant_id?: UuidFilter<"option"> | string
    option_name?: StringFilter<"option"> | string
    multi_select?: BoolFilter<"option"> | boolean
    require_select?: BoolFilter<"option"> | boolean
    number_select?: BigIntFilter<"option"> | bigint | number
    menu_item_option?: Menu_item_optionListRelationFilter
    merchant?: XOR<MerchantScalarRelationFilter, merchantWhereInput>
    option_item?: Option_itemListRelationFilter
  }

  export type optionOrderByWithRelationInput = {
    id?: SortOrder
    merchant_id?: SortOrder
    option_name?: SortOrder
    multi_select?: SortOrder
    require_select?: SortOrder
    number_select?: SortOrder
    menu_item_option?: menu_item_optionOrderByRelationAggregateInput
    merchant?: merchantOrderByWithRelationInput
    option_item?: option_itemOrderByRelationAggregateInput
  }

  export type optionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: optionWhereInput | optionWhereInput[]
    OR?: optionWhereInput[]
    NOT?: optionWhereInput | optionWhereInput[]
    merchant_id?: UuidFilter<"option"> | string
    option_name?: StringFilter<"option"> | string
    multi_select?: BoolFilter<"option"> | boolean
    require_select?: BoolFilter<"option"> | boolean
    number_select?: BigIntFilter<"option"> | bigint | number
    menu_item_option?: Menu_item_optionListRelationFilter
    merchant?: XOR<MerchantScalarRelationFilter, merchantWhereInput>
    option_item?: Option_itemListRelationFilter
  }, "id">

  export type optionOrderByWithAggregationInput = {
    id?: SortOrder
    merchant_id?: SortOrder
    option_name?: SortOrder
    multi_select?: SortOrder
    require_select?: SortOrder
    number_select?: SortOrder
    _count?: optionCountOrderByAggregateInput
    _avg?: optionAvgOrderByAggregateInput
    _max?: optionMaxOrderByAggregateInput
    _min?: optionMinOrderByAggregateInput
    _sum?: optionSumOrderByAggregateInput
  }

  export type optionScalarWhereWithAggregatesInput = {
    AND?: optionScalarWhereWithAggregatesInput | optionScalarWhereWithAggregatesInput[]
    OR?: optionScalarWhereWithAggregatesInput[]
    NOT?: optionScalarWhereWithAggregatesInput | optionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"option"> | string
    merchant_id?: UuidWithAggregatesFilter<"option"> | string
    option_name?: StringWithAggregatesFilter<"option"> | string
    multi_select?: BoolWithAggregatesFilter<"option"> | boolean
    require_select?: BoolWithAggregatesFilter<"option"> | boolean
    number_select?: BigIntWithAggregatesFilter<"option"> | bigint | number
  }

  export type option_itemWhereInput = {
    AND?: option_itemWhereInput | option_itemWhereInput[]
    OR?: option_itemWhereInput[]
    NOT?: option_itemWhereInput | option_itemWhereInput[]
    id?: UuidFilter<"option_item"> | string
    option_id?: UuidFilter<"option_item"> | string
    option_item_name?: StringFilter<"option_item"> | string
    status?: BoolFilter<"option_item"> | boolean
    status_select?: BoolFilter<"option_item"> | boolean
    option?: XOR<OptionScalarRelationFilter, optionWhereInput>
    order_item_options?: Order_item_optionListRelationFilter
  }

  export type option_itemOrderByWithRelationInput = {
    id?: SortOrder
    option_id?: SortOrder
    option_item_name?: SortOrder
    status?: SortOrder
    status_select?: SortOrder
    option?: optionOrderByWithRelationInput
    order_item_options?: order_item_optionOrderByRelationAggregateInput
  }

  export type option_itemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: option_itemWhereInput | option_itemWhereInput[]
    OR?: option_itemWhereInput[]
    NOT?: option_itemWhereInput | option_itemWhereInput[]
    option_id?: UuidFilter<"option_item"> | string
    option_item_name?: StringFilter<"option_item"> | string
    status?: BoolFilter<"option_item"> | boolean
    status_select?: BoolFilter<"option_item"> | boolean
    option?: XOR<OptionScalarRelationFilter, optionWhereInput>
    order_item_options?: Order_item_optionListRelationFilter
  }, "id">

  export type option_itemOrderByWithAggregationInput = {
    id?: SortOrder
    option_id?: SortOrder
    option_item_name?: SortOrder
    status?: SortOrder
    status_select?: SortOrder
    _count?: option_itemCountOrderByAggregateInput
    _max?: option_itemMaxOrderByAggregateInput
    _min?: option_itemMinOrderByAggregateInput
  }

  export type option_itemScalarWhereWithAggregatesInput = {
    AND?: option_itemScalarWhereWithAggregatesInput | option_itemScalarWhereWithAggregatesInput[]
    OR?: option_itemScalarWhereWithAggregatesInput[]
    NOT?: option_itemScalarWhereWithAggregatesInput | option_itemScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"option_item"> | string
    option_id?: UuidWithAggregatesFilter<"option_item"> | string
    option_item_name?: StringWithAggregatesFilter<"option_item"> | string
    status?: BoolWithAggregatesFilter<"option_item"> | boolean
    status_select?: BoolWithAggregatesFilter<"option_item"> | boolean
  }

  export type menu_item_optionWhereInput = {
    AND?: menu_item_optionWhereInput | menu_item_optionWhereInput[]
    OR?: menu_item_optionWhereInput[]
    NOT?: menu_item_optionWhereInput | menu_item_optionWhereInput[]
    option_id?: UuidFilter<"menu_item_option"> | string
    menu_item_id?: UuidFilter<"menu_item_option"> | string
    menu_item?: XOR<Menu_itemScalarRelationFilter, menu_itemWhereInput>
    option?: XOR<OptionScalarRelationFilter, optionWhereInput>
  }

  export type menu_item_optionOrderByWithRelationInput = {
    option_id?: SortOrder
    menu_item_id?: SortOrder
    menu_item?: menu_itemOrderByWithRelationInput
    option?: optionOrderByWithRelationInput
  }

  export type menu_item_optionWhereUniqueInput = Prisma.AtLeast<{
    option_id_menu_item_id?: menu_item_optionOption_idMenu_item_idCompoundUniqueInput
    AND?: menu_item_optionWhereInput | menu_item_optionWhereInput[]
    OR?: menu_item_optionWhereInput[]
    NOT?: menu_item_optionWhereInput | menu_item_optionWhereInput[]
    option_id?: UuidFilter<"menu_item_option"> | string
    menu_item_id?: UuidFilter<"menu_item_option"> | string
    menu_item?: XOR<Menu_itemScalarRelationFilter, menu_itemWhereInput>
    option?: XOR<OptionScalarRelationFilter, optionWhereInput>
  }, "option_id_menu_item_id">

  export type menu_item_optionOrderByWithAggregationInput = {
    option_id?: SortOrder
    menu_item_id?: SortOrder
    _count?: menu_item_optionCountOrderByAggregateInput
    _max?: menu_item_optionMaxOrderByAggregateInput
    _min?: menu_item_optionMinOrderByAggregateInput
  }

  export type menu_item_optionScalarWhereWithAggregatesInput = {
    AND?: menu_item_optionScalarWhereWithAggregatesInput | menu_item_optionScalarWhereWithAggregatesInput[]
    OR?: menu_item_optionScalarWhereWithAggregatesInput[]
    NOT?: menu_item_optionScalarWhereWithAggregatesInput | menu_item_optionScalarWhereWithAggregatesInput[]
    option_id?: UuidWithAggregatesFilter<"menu_item_option"> | string
    menu_item_id?: UuidWithAggregatesFilter<"menu_item_option"> | string
  }

  export type orderWhereInput = {
    AND?: orderWhereInput | orderWhereInput[]
    OR?: orderWhereInput[]
    NOT?: orderWhereInput | orderWhereInput[]
    id?: UuidFilter<"order"> | string
    merchant_id?: UuidFilter<"order"> | string
    user_id?: UuidFilter<"order"> | string
    full_name?: StringFilter<"order"> | string
    phone?: StringNullableFilter<"order"> | string | null
    delivery_address?: StringNullableFilter<"order"> | string | null
    delivery_fee?: BigIntNullableFilter<"order"> | bigint | number | null
    note?: StringNullableFilter<"order"> | string | null
    total_amount?: BigIntFilter<"order"> | bigint | number
    created_at?: DateTimeNullableFilter<"order"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"order"> | Date | string | null
    status?: StringNullableFilter<"order"> | string | null
    status_payment?: StringNullableFilter<"order"> | string | null
    payment_method?: StringNullableFilter<"order"> | string | null
    merchant?: XOR<MerchantScalarRelationFilter, merchantWhereInput>
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
    items?: Order_itemListRelationFilter
    payments?: Payment_transactionListRelationFilter
  }

  export type orderOrderByWithRelationInput = {
    id?: SortOrder
    merchant_id?: SortOrder
    user_id?: SortOrder
    full_name?: SortOrder
    phone?: SortOrderInput | SortOrder
    delivery_address?: SortOrderInput | SortOrder
    delivery_fee?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    total_amount?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    status_payment?: SortOrderInput | SortOrder
    payment_method?: SortOrderInput | SortOrder
    merchant?: merchantOrderByWithRelationInput
    user?: usersOrderByWithRelationInput
    items?: order_itemOrderByRelationAggregateInput
    payments?: payment_transactionOrderByRelationAggregateInput
  }

  export type orderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: orderWhereInput | orderWhereInput[]
    OR?: orderWhereInput[]
    NOT?: orderWhereInput | orderWhereInput[]
    merchant_id?: UuidFilter<"order"> | string
    user_id?: UuidFilter<"order"> | string
    full_name?: StringFilter<"order"> | string
    phone?: StringNullableFilter<"order"> | string | null
    delivery_address?: StringNullableFilter<"order"> | string | null
    delivery_fee?: BigIntNullableFilter<"order"> | bigint | number | null
    note?: StringNullableFilter<"order"> | string | null
    total_amount?: BigIntFilter<"order"> | bigint | number
    created_at?: DateTimeNullableFilter<"order"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"order"> | Date | string | null
    status?: StringNullableFilter<"order"> | string | null
    status_payment?: StringNullableFilter<"order"> | string | null
    payment_method?: StringNullableFilter<"order"> | string | null
    merchant?: XOR<MerchantScalarRelationFilter, merchantWhereInput>
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
    items?: Order_itemListRelationFilter
    payments?: Payment_transactionListRelationFilter
  }, "id">

  export type orderOrderByWithAggregationInput = {
    id?: SortOrder
    merchant_id?: SortOrder
    user_id?: SortOrder
    full_name?: SortOrder
    phone?: SortOrderInput | SortOrder
    delivery_address?: SortOrderInput | SortOrder
    delivery_fee?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    total_amount?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    status_payment?: SortOrderInput | SortOrder
    payment_method?: SortOrderInput | SortOrder
    _count?: orderCountOrderByAggregateInput
    _avg?: orderAvgOrderByAggregateInput
    _max?: orderMaxOrderByAggregateInput
    _min?: orderMinOrderByAggregateInput
    _sum?: orderSumOrderByAggregateInput
  }

  export type orderScalarWhereWithAggregatesInput = {
    AND?: orderScalarWhereWithAggregatesInput | orderScalarWhereWithAggregatesInput[]
    OR?: orderScalarWhereWithAggregatesInput[]
    NOT?: orderScalarWhereWithAggregatesInput | orderScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"order"> | string
    merchant_id?: UuidWithAggregatesFilter<"order"> | string
    user_id?: UuidWithAggregatesFilter<"order"> | string
    full_name?: StringWithAggregatesFilter<"order"> | string
    phone?: StringNullableWithAggregatesFilter<"order"> | string | null
    delivery_address?: StringNullableWithAggregatesFilter<"order"> | string | null
    delivery_fee?: BigIntNullableWithAggregatesFilter<"order"> | bigint | number | null
    note?: StringNullableWithAggregatesFilter<"order"> | string | null
    total_amount?: BigIntWithAggregatesFilter<"order"> | bigint | number
    created_at?: DateTimeNullableWithAggregatesFilter<"order"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"order"> | Date | string | null
    status?: StringNullableWithAggregatesFilter<"order"> | string | null
    status_payment?: StringNullableWithAggregatesFilter<"order"> | string | null
    payment_method?: StringNullableWithAggregatesFilter<"order"> | string | null
  }

  export type order_itemWhereInput = {
    AND?: order_itemWhereInput | order_itemWhereInput[]
    OR?: order_itemWhereInput[]
    NOT?: order_itemWhereInput | order_itemWhereInput[]
    id?: UuidFilter<"order_item"> | string
    order_id?: UuidFilter<"order_item"> | string
    menu_item_id?: UuidFilter<"order_item"> | string
    note?: StringNullableFilter<"order_item"> | string | null
    quantity?: BigIntFilter<"order_item"> | bigint | number
    price?: BigIntFilter<"order_item"> | bigint | number
    menu_item?: XOR<Menu_itemScalarRelationFilter, menu_itemWhereInput>
    order?: XOR<OrderScalarRelationFilter, orderWhereInput>
    options?: Order_item_optionListRelationFilter
  }

  export type order_itemOrderByWithRelationInput = {
    id?: SortOrder
    order_id?: SortOrder
    menu_item_id?: SortOrder
    note?: SortOrderInput | SortOrder
    quantity?: SortOrder
    price?: SortOrder
    menu_item?: menu_itemOrderByWithRelationInput
    order?: orderOrderByWithRelationInput
    options?: order_item_optionOrderByRelationAggregateInput
  }

  export type order_itemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: order_itemWhereInput | order_itemWhereInput[]
    OR?: order_itemWhereInput[]
    NOT?: order_itemWhereInput | order_itemWhereInput[]
    order_id?: UuidFilter<"order_item"> | string
    menu_item_id?: UuidFilter<"order_item"> | string
    note?: StringNullableFilter<"order_item"> | string | null
    quantity?: BigIntFilter<"order_item"> | bigint | number
    price?: BigIntFilter<"order_item"> | bigint | number
    menu_item?: XOR<Menu_itemScalarRelationFilter, menu_itemWhereInput>
    order?: XOR<OrderScalarRelationFilter, orderWhereInput>
    options?: Order_item_optionListRelationFilter
  }, "id">

  export type order_itemOrderByWithAggregationInput = {
    id?: SortOrder
    order_id?: SortOrder
    menu_item_id?: SortOrder
    note?: SortOrderInput | SortOrder
    quantity?: SortOrder
    price?: SortOrder
    _count?: order_itemCountOrderByAggregateInput
    _avg?: order_itemAvgOrderByAggregateInput
    _max?: order_itemMaxOrderByAggregateInput
    _min?: order_itemMinOrderByAggregateInput
    _sum?: order_itemSumOrderByAggregateInput
  }

  export type order_itemScalarWhereWithAggregatesInput = {
    AND?: order_itemScalarWhereWithAggregatesInput | order_itemScalarWhereWithAggregatesInput[]
    OR?: order_itemScalarWhereWithAggregatesInput[]
    NOT?: order_itemScalarWhereWithAggregatesInput | order_itemScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"order_item"> | string
    order_id?: UuidWithAggregatesFilter<"order_item"> | string
    menu_item_id?: UuidWithAggregatesFilter<"order_item"> | string
    note?: StringNullableWithAggregatesFilter<"order_item"> | string | null
    quantity?: BigIntWithAggregatesFilter<"order_item"> | bigint | number
    price?: BigIntWithAggregatesFilter<"order_item"> | bigint | number
  }

  export type order_item_optionWhereInput = {
    AND?: order_item_optionWhereInput | order_item_optionWhereInput[]
    OR?: order_item_optionWhereInput[]
    NOT?: order_item_optionWhereInput | order_item_optionWhereInput[]
    order_item_id?: UuidFilter<"order_item_option"> | string
    option_item_id?: UuidFilter<"order_item_option"> | string
    option_item?: XOR<Option_itemScalarRelationFilter, option_itemWhereInput>
    order_item?: XOR<Order_itemScalarRelationFilter, order_itemWhereInput>
  }

  export type order_item_optionOrderByWithRelationInput = {
    order_item_id?: SortOrder
    option_item_id?: SortOrder
    option_item?: option_itemOrderByWithRelationInput
    order_item?: order_itemOrderByWithRelationInput
  }

  export type order_item_optionWhereUniqueInput = Prisma.AtLeast<{
    order_item_id_option_item_id?: order_item_optionOrder_item_idOption_item_idCompoundUniqueInput
    AND?: order_item_optionWhereInput | order_item_optionWhereInput[]
    OR?: order_item_optionWhereInput[]
    NOT?: order_item_optionWhereInput | order_item_optionWhereInput[]
    order_item_id?: UuidFilter<"order_item_option"> | string
    option_item_id?: UuidFilter<"order_item_option"> | string
    option_item?: XOR<Option_itemScalarRelationFilter, option_itemWhereInput>
    order_item?: XOR<Order_itemScalarRelationFilter, order_itemWhereInput>
  }, "order_item_id_option_item_id">

  export type order_item_optionOrderByWithAggregationInput = {
    order_item_id?: SortOrder
    option_item_id?: SortOrder
    _count?: order_item_optionCountOrderByAggregateInput
    _max?: order_item_optionMaxOrderByAggregateInput
    _min?: order_item_optionMinOrderByAggregateInput
  }

  export type order_item_optionScalarWhereWithAggregatesInput = {
    AND?: order_item_optionScalarWhereWithAggregatesInput | order_item_optionScalarWhereWithAggregatesInput[]
    OR?: order_item_optionScalarWhereWithAggregatesInput[]
    NOT?: order_item_optionScalarWhereWithAggregatesInput | order_item_optionScalarWhereWithAggregatesInput[]
    order_item_id?: UuidWithAggregatesFilter<"order_item_option"> | string
    option_item_id?: UuidWithAggregatesFilter<"order_item_option"> | string
  }

  export type payment_transactionWhereInput = {
    AND?: payment_transactionWhereInput | payment_transactionWhereInput[]
    OR?: payment_transactionWhereInput[]
    NOT?: payment_transactionWhereInput | payment_transactionWhereInput[]
    id?: UuidFilter<"payment_transaction"> | string
    user_id?: UuidFilter<"payment_transaction"> | string
    merchant_id?: UuidFilter<"payment_transaction"> | string
    order_id?: UuidNullableFilter<"payment_transaction"> | string | null
    amount?: BigIntFilter<"payment_transaction"> | bigint | number
    currency?: StringFilter<"payment_transaction"> | string
    txn_ref?: StringFilter<"payment_transaction"> | string
    transaction_no?: StringNullableFilter<"payment_transaction"> | string | null
    payment_method?: StringFilter<"payment_transaction"> | string
    status?: EnumPaymentStatusFilter<"payment_transaction"> | $Enums.PaymentStatus
    response_code?: StringNullableFilter<"payment_transaction"> | string | null
    bank_code?: StringNullableFilter<"payment_transaction"> | string | null
    pay_date?: StringNullableFilter<"payment_transaction"> | string | null
    tmn_code?: StringNullableFilter<"payment_transaction"> | string | null
    raw_payload?: JsonNullableFilter<"payment_transaction">
    created_at?: DateTimeFilter<"payment_transaction"> | Date | string
    updated_at?: DateTimeFilter<"payment_transaction"> | Date | string
    merchant?: XOR<MerchantScalarRelationFilter, merchantWhereInput>
    order?: XOR<OrderNullableScalarRelationFilter, orderWhereInput> | null
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type payment_transactionOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    merchant_id?: SortOrder
    order_id?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    txn_ref?: SortOrder
    transaction_no?: SortOrderInput | SortOrder
    payment_method?: SortOrder
    status?: SortOrder
    response_code?: SortOrderInput | SortOrder
    bank_code?: SortOrderInput | SortOrder
    pay_date?: SortOrderInput | SortOrder
    tmn_code?: SortOrderInput | SortOrder
    raw_payload?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    merchant?: merchantOrderByWithRelationInput
    order?: orderOrderByWithRelationInput
    user?: usersOrderByWithRelationInput
  }

  export type payment_transactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    order_id_txn_ref?: payment_transactionOrder_idTxn_refCompoundUniqueInput
    AND?: payment_transactionWhereInput | payment_transactionWhereInput[]
    OR?: payment_transactionWhereInput[]
    NOT?: payment_transactionWhereInput | payment_transactionWhereInput[]
    user_id?: UuidFilter<"payment_transaction"> | string
    merchant_id?: UuidFilter<"payment_transaction"> | string
    order_id?: UuidNullableFilter<"payment_transaction"> | string | null
    amount?: BigIntFilter<"payment_transaction"> | bigint | number
    currency?: StringFilter<"payment_transaction"> | string
    txn_ref?: StringFilter<"payment_transaction"> | string
    transaction_no?: StringNullableFilter<"payment_transaction"> | string | null
    payment_method?: StringFilter<"payment_transaction"> | string
    status?: EnumPaymentStatusFilter<"payment_transaction"> | $Enums.PaymentStatus
    response_code?: StringNullableFilter<"payment_transaction"> | string | null
    bank_code?: StringNullableFilter<"payment_transaction"> | string | null
    pay_date?: StringNullableFilter<"payment_transaction"> | string | null
    tmn_code?: StringNullableFilter<"payment_transaction"> | string | null
    raw_payload?: JsonNullableFilter<"payment_transaction">
    created_at?: DateTimeFilter<"payment_transaction"> | Date | string
    updated_at?: DateTimeFilter<"payment_transaction"> | Date | string
    merchant?: XOR<MerchantScalarRelationFilter, merchantWhereInput>
    order?: XOR<OrderNullableScalarRelationFilter, orderWhereInput> | null
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id" | "order_id_txn_ref">

  export type payment_transactionOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    merchant_id?: SortOrder
    order_id?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    txn_ref?: SortOrder
    transaction_no?: SortOrderInput | SortOrder
    payment_method?: SortOrder
    status?: SortOrder
    response_code?: SortOrderInput | SortOrder
    bank_code?: SortOrderInput | SortOrder
    pay_date?: SortOrderInput | SortOrder
    tmn_code?: SortOrderInput | SortOrder
    raw_payload?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: payment_transactionCountOrderByAggregateInput
    _avg?: payment_transactionAvgOrderByAggregateInput
    _max?: payment_transactionMaxOrderByAggregateInput
    _min?: payment_transactionMinOrderByAggregateInput
    _sum?: payment_transactionSumOrderByAggregateInput
  }

  export type payment_transactionScalarWhereWithAggregatesInput = {
    AND?: payment_transactionScalarWhereWithAggregatesInput | payment_transactionScalarWhereWithAggregatesInput[]
    OR?: payment_transactionScalarWhereWithAggregatesInput[]
    NOT?: payment_transactionScalarWhereWithAggregatesInput | payment_transactionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"payment_transaction"> | string
    user_id?: UuidWithAggregatesFilter<"payment_transaction"> | string
    merchant_id?: UuidWithAggregatesFilter<"payment_transaction"> | string
    order_id?: UuidNullableWithAggregatesFilter<"payment_transaction"> | string | null
    amount?: BigIntWithAggregatesFilter<"payment_transaction"> | bigint | number
    currency?: StringWithAggregatesFilter<"payment_transaction"> | string
    txn_ref?: StringWithAggregatesFilter<"payment_transaction"> | string
    transaction_no?: StringNullableWithAggregatesFilter<"payment_transaction"> | string | null
    payment_method?: StringWithAggregatesFilter<"payment_transaction"> | string
    status?: EnumPaymentStatusWithAggregatesFilter<"payment_transaction"> | $Enums.PaymentStatus
    response_code?: StringNullableWithAggregatesFilter<"payment_transaction"> | string | null
    bank_code?: StringNullableWithAggregatesFilter<"payment_transaction"> | string | null
    pay_date?: StringNullableWithAggregatesFilter<"payment_transaction"> | string | null
    tmn_code?: StringNullableWithAggregatesFilter<"payment_transaction"> | string | null
    raw_payload?: JsonNullableWithAggregatesFilter<"payment_transaction">
    created_at?: DateTimeWithAggregatesFilter<"payment_transaction"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"payment_transaction"> | Date | string
  }

  export type usersCreateInput = {
    id?: string
    image?: NullableJsonNullValueInput | InputJsonValue
    full_name: string
    role?: string | null
    birth?: Date | string | null
    password: string
    phone: string
    email: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    merchants?: merchantCreateNestedManyWithoutUserInput
    orders?: orderCreateNestedManyWithoutUserInput
    payment_transactions?: payment_transactionCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateInput = {
    id?: string
    image?: NullableJsonNullValueInput | InputJsonValue
    full_name: string
    role?: string | null
    birth?: Date | string | null
    password: string
    phone: string
    email: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    merchants?: merchantUncheckedCreateNestedManyWithoutUserInput
    orders?: orderUncheckedCreateNestedManyWithoutUserInput
    payment_transactions?: payment_transactionUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: NullableJsonNullValueInput | InputJsonValue
    full_name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    merchants?: merchantUpdateManyWithoutUserNestedInput
    orders?: orderUpdateManyWithoutUserNestedInput
    payment_transactions?: payment_transactionUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: NullableJsonNullValueInput | InputJsonValue
    full_name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    merchants?: merchantUncheckedUpdateManyWithoutUserNestedInput
    orders?: orderUncheckedUpdateManyWithoutUserNestedInput
    payment_transactions?: payment_transactionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type usersCreateManyInput = {
    id?: string
    image?: NullableJsonNullValueInput | InputJsonValue
    full_name: string
    role?: string | null
    birth?: Date | string | null
    password: string
    phone: string
    email: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type usersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: NullableJsonNullValueInput | InputJsonValue
    full_name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: NullableJsonNullValueInput | InputJsonValue
    full_name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type merchantCreateInput = {
    id?: string
    merchant_name: string
    location?: NullableJsonNullValueInput | InputJsonValue
    phone?: string | null
    email?: string | null
    profile_image?: NullableJsonNullValueInput | InputJsonValue
    cover_image?: NullableJsonNullValueInput | InputJsonValue
    time_open?: NullableJsonNullValueInput | InputJsonValue
    cuisine?: string | null
    categories?: categoryCreateNestedManyWithoutMerchantInput
    menu_item?: menu_itemCreateNestedManyWithoutMerchantInput
    user: usersCreateNestedOneWithoutMerchantsInput
    option?: optionCreateNestedManyWithoutMerchantInput
    orders?: orderCreateNestedManyWithoutMerchantInput
    payment_transactions?: payment_transactionCreateNestedManyWithoutMerchantInput
  }

  export type merchantUncheckedCreateInput = {
    id?: string
    user_id: string
    merchant_name: string
    location?: NullableJsonNullValueInput | InputJsonValue
    phone?: string | null
    email?: string | null
    profile_image?: NullableJsonNullValueInput | InputJsonValue
    cover_image?: NullableJsonNullValueInput | InputJsonValue
    time_open?: NullableJsonNullValueInput | InputJsonValue
    cuisine?: string | null
    categories?: categoryUncheckedCreateNestedManyWithoutMerchantInput
    menu_item?: menu_itemUncheckedCreateNestedManyWithoutMerchantInput
    option?: optionUncheckedCreateNestedManyWithoutMerchantInput
    orders?: orderUncheckedCreateNestedManyWithoutMerchantInput
    payment_transactions?: payment_transactionUncheckedCreateNestedManyWithoutMerchantInput
  }

  export type merchantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchant_name?: StringFieldUpdateOperationsInput | string
    location?: NullableJsonNullValueInput | InputJsonValue
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableJsonNullValueInput | InputJsonValue
    cover_image?: NullableJsonNullValueInput | InputJsonValue
    time_open?: NullableJsonNullValueInput | InputJsonValue
    cuisine?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: categoryUpdateManyWithoutMerchantNestedInput
    menu_item?: menu_itemUpdateManyWithoutMerchantNestedInput
    user?: usersUpdateOneRequiredWithoutMerchantsNestedInput
    option?: optionUpdateManyWithoutMerchantNestedInput
    orders?: orderUpdateManyWithoutMerchantNestedInput
    payment_transactions?: payment_transactionUpdateManyWithoutMerchantNestedInput
  }

  export type merchantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    merchant_name?: StringFieldUpdateOperationsInput | string
    location?: NullableJsonNullValueInput | InputJsonValue
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableJsonNullValueInput | InputJsonValue
    cover_image?: NullableJsonNullValueInput | InputJsonValue
    time_open?: NullableJsonNullValueInput | InputJsonValue
    cuisine?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: categoryUncheckedUpdateManyWithoutMerchantNestedInput
    menu_item?: menu_itemUncheckedUpdateManyWithoutMerchantNestedInput
    option?: optionUncheckedUpdateManyWithoutMerchantNestedInput
    orders?: orderUncheckedUpdateManyWithoutMerchantNestedInput
    payment_transactions?: payment_transactionUncheckedUpdateManyWithoutMerchantNestedInput
  }

  export type merchantCreateManyInput = {
    id?: string
    user_id: string
    merchant_name: string
    location?: NullableJsonNullValueInput | InputJsonValue
    phone?: string | null
    email?: string | null
    profile_image?: NullableJsonNullValueInput | InputJsonValue
    cover_image?: NullableJsonNullValueInput | InputJsonValue
    time_open?: NullableJsonNullValueInput | InputJsonValue
    cuisine?: string | null
  }

  export type merchantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchant_name?: StringFieldUpdateOperationsInput | string
    location?: NullableJsonNullValueInput | InputJsonValue
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableJsonNullValueInput | InputJsonValue
    cover_image?: NullableJsonNullValueInput | InputJsonValue
    time_open?: NullableJsonNullValueInput | InputJsonValue
    cuisine?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type merchantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    merchant_name?: StringFieldUpdateOperationsInput | string
    location?: NullableJsonNullValueInput | InputJsonValue
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableJsonNullValueInput | InputJsonValue
    cover_image?: NullableJsonNullValueInput | InputJsonValue
    time_open?: NullableJsonNullValueInput | InputJsonValue
    cuisine?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type categoryCreateInput = {
    id?: string
    category_name: string
    merchant: merchantCreateNestedOneWithoutCategoriesInput
    menu_item?: menu_itemCreateNestedManyWithoutCategoryInput
  }

  export type categoryUncheckedCreateInput = {
    id?: string
    merchant_id: string
    category_name: string
    menu_item?: menu_itemUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type categoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category_name?: StringFieldUpdateOperationsInput | string
    merchant?: merchantUpdateOneRequiredWithoutCategoriesNestedInput
    menu_item?: menu_itemUpdateManyWithoutCategoryNestedInput
  }

  export type categoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchant_id?: StringFieldUpdateOperationsInput | string
    category_name?: StringFieldUpdateOperationsInput | string
    menu_item?: menu_itemUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type categoryCreateManyInput = {
    id?: string
    merchant_id: string
    category_name: string
  }

  export type categoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    category_name?: StringFieldUpdateOperationsInput | string
  }

  export type categoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchant_id?: StringFieldUpdateOperationsInput | string
    category_name?: StringFieldUpdateOperationsInput | string
  }

  export type menu_itemCreateInput = {
    id?: string
    name_item: string
    likes?: bigint | number
    price: bigint | number
    description?: string | null
    sold_count?: bigint | number
    image_item?: NullableJsonNullValueInput | InputJsonValue
    status?: boolean
    category?: categoryCreateNestedOneWithoutMenu_itemInput
    merchant: merchantCreateNestedOneWithoutMenu_itemInput
    menu_item_option?: menu_item_optionCreateNestedManyWithoutMenu_itemInput
    order_items?: order_itemCreateNestedManyWithoutMenu_itemInput
  }

  export type menu_itemUncheckedCreateInput = {
    id?: string
    merchant_id: string
    category_id?: string | null
    name_item: string
    likes?: bigint | number
    price: bigint | number
    description?: string | null
    sold_count?: bigint | number
    image_item?: NullableJsonNullValueInput | InputJsonValue
    status?: boolean
    menu_item_option?: menu_item_optionUncheckedCreateNestedManyWithoutMenu_itemInput
    order_items?: order_itemUncheckedCreateNestedManyWithoutMenu_itemInput
  }

  export type menu_itemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_item?: StringFieldUpdateOperationsInput | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    price?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sold_count?: BigIntFieldUpdateOperationsInput | bigint | number
    image_item?: NullableJsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
    category?: categoryUpdateOneWithoutMenu_itemNestedInput
    merchant?: merchantUpdateOneRequiredWithoutMenu_itemNestedInput
    menu_item_option?: menu_item_optionUpdateManyWithoutMenu_itemNestedInput
    order_items?: order_itemUpdateManyWithoutMenu_itemNestedInput
  }

  export type menu_itemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchant_id?: StringFieldUpdateOperationsInput | string
    category_id?: NullableStringFieldUpdateOperationsInput | string | null
    name_item?: StringFieldUpdateOperationsInput | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    price?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sold_count?: BigIntFieldUpdateOperationsInput | bigint | number
    image_item?: NullableJsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
    menu_item_option?: menu_item_optionUncheckedUpdateManyWithoutMenu_itemNestedInput
    order_items?: order_itemUncheckedUpdateManyWithoutMenu_itemNestedInput
  }

  export type menu_itemCreateManyInput = {
    id?: string
    merchant_id: string
    category_id?: string | null
    name_item: string
    likes?: bigint | number
    price: bigint | number
    description?: string | null
    sold_count?: bigint | number
    image_item?: NullableJsonNullValueInput | InputJsonValue
    status?: boolean
  }

  export type menu_itemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_item?: StringFieldUpdateOperationsInput | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    price?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sold_count?: BigIntFieldUpdateOperationsInput | bigint | number
    image_item?: NullableJsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
  }

  export type menu_itemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchant_id?: StringFieldUpdateOperationsInput | string
    category_id?: NullableStringFieldUpdateOperationsInput | string | null
    name_item?: StringFieldUpdateOperationsInput | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    price?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sold_count?: BigIntFieldUpdateOperationsInput | bigint | number
    image_item?: NullableJsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
  }

  export type optionCreateInput = {
    id?: string
    option_name: string
    multi_select?: boolean
    require_select?: boolean
    number_select?: bigint | number
    menu_item_option?: menu_item_optionCreateNestedManyWithoutOptionInput
    merchant: merchantCreateNestedOneWithoutOptionInput
    option_item?: option_itemCreateNestedManyWithoutOptionInput
  }

  export type optionUncheckedCreateInput = {
    id?: string
    merchant_id: string
    option_name: string
    multi_select?: boolean
    require_select?: boolean
    number_select?: bigint | number
    menu_item_option?: menu_item_optionUncheckedCreateNestedManyWithoutOptionInput
    option_item?: option_itemUncheckedCreateNestedManyWithoutOptionInput
  }

  export type optionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    option_name?: StringFieldUpdateOperationsInput | string
    multi_select?: BoolFieldUpdateOperationsInput | boolean
    require_select?: BoolFieldUpdateOperationsInput | boolean
    number_select?: BigIntFieldUpdateOperationsInput | bigint | number
    menu_item_option?: menu_item_optionUpdateManyWithoutOptionNestedInput
    merchant?: merchantUpdateOneRequiredWithoutOptionNestedInput
    option_item?: option_itemUpdateManyWithoutOptionNestedInput
  }

  export type optionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchant_id?: StringFieldUpdateOperationsInput | string
    option_name?: StringFieldUpdateOperationsInput | string
    multi_select?: BoolFieldUpdateOperationsInput | boolean
    require_select?: BoolFieldUpdateOperationsInput | boolean
    number_select?: BigIntFieldUpdateOperationsInput | bigint | number
    menu_item_option?: menu_item_optionUncheckedUpdateManyWithoutOptionNestedInput
    option_item?: option_itemUncheckedUpdateManyWithoutOptionNestedInput
  }

  export type optionCreateManyInput = {
    id?: string
    merchant_id: string
    option_name: string
    multi_select?: boolean
    require_select?: boolean
    number_select?: bigint | number
  }

  export type optionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    option_name?: StringFieldUpdateOperationsInput | string
    multi_select?: BoolFieldUpdateOperationsInput | boolean
    require_select?: BoolFieldUpdateOperationsInput | boolean
    number_select?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type optionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchant_id?: StringFieldUpdateOperationsInput | string
    option_name?: StringFieldUpdateOperationsInput | string
    multi_select?: BoolFieldUpdateOperationsInput | boolean
    require_select?: BoolFieldUpdateOperationsInput | boolean
    number_select?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type option_itemCreateInput = {
    id?: string
    option_item_name: string
    status?: boolean
    status_select?: boolean
    option: optionCreateNestedOneWithoutOption_itemInput
    order_item_options?: order_item_optionCreateNestedManyWithoutOption_itemInput
  }

  export type option_itemUncheckedCreateInput = {
    id?: string
    option_id: string
    option_item_name: string
    status?: boolean
    status_select?: boolean
    order_item_options?: order_item_optionUncheckedCreateNestedManyWithoutOption_itemInput
  }

  export type option_itemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    option_item_name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    status_select?: BoolFieldUpdateOperationsInput | boolean
    option?: optionUpdateOneRequiredWithoutOption_itemNestedInput
    order_item_options?: order_item_optionUpdateManyWithoutOption_itemNestedInput
  }

  export type option_itemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    option_id?: StringFieldUpdateOperationsInput | string
    option_item_name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    status_select?: BoolFieldUpdateOperationsInput | boolean
    order_item_options?: order_item_optionUncheckedUpdateManyWithoutOption_itemNestedInput
  }

  export type option_itemCreateManyInput = {
    id?: string
    option_id: string
    option_item_name: string
    status?: boolean
    status_select?: boolean
  }

  export type option_itemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    option_item_name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    status_select?: BoolFieldUpdateOperationsInput | boolean
  }

  export type option_itemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    option_id?: StringFieldUpdateOperationsInput | string
    option_item_name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    status_select?: BoolFieldUpdateOperationsInput | boolean
  }

  export type menu_item_optionCreateInput = {
    menu_item: menu_itemCreateNestedOneWithoutMenu_item_optionInput
    option: optionCreateNestedOneWithoutMenu_item_optionInput
  }

  export type menu_item_optionUncheckedCreateInput = {
    option_id: string
    menu_item_id: string
  }

  export type menu_item_optionUpdateInput = {
    menu_item?: menu_itemUpdateOneRequiredWithoutMenu_item_optionNestedInput
    option?: optionUpdateOneRequiredWithoutMenu_item_optionNestedInput
  }

  export type menu_item_optionUncheckedUpdateInput = {
    option_id?: StringFieldUpdateOperationsInput | string
    menu_item_id?: StringFieldUpdateOperationsInput | string
  }

  export type menu_item_optionCreateManyInput = {
    option_id: string
    menu_item_id: string
  }

  export type menu_item_optionUpdateManyMutationInput = {

  }

  export type menu_item_optionUncheckedUpdateManyInput = {
    option_id?: StringFieldUpdateOperationsInput | string
    menu_item_id?: StringFieldUpdateOperationsInput | string
  }

  export type orderCreateInput = {
    id?: string
    full_name: string
    phone?: string | null
    delivery_address?: string | null
    delivery_fee?: bigint | number | null
    note?: string | null
    total_amount: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    status?: string | null
    status_payment?: string | null
    payment_method?: string | null
    merchant: merchantCreateNestedOneWithoutOrdersInput
    user: usersCreateNestedOneWithoutOrdersInput
    items?: order_itemCreateNestedManyWithoutOrderInput
    payments?: payment_transactionCreateNestedManyWithoutOrderInput
  }

  export type orderUncheckedCreateInput = {
    id?: string
    merchant_id: string
    user_id: string
    full_name: string
    phone?: string | null
    delivery_address?: string | null
    delivery_fee?: bigint | number | null
    note?: string | null
    total_amount: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    status?: string | null
    status_payment?: string | null
    payment_method?: string | null
    items?: order_itemUncheckedCreateNestedManyWithoutOrderInput
    payments?: payment_transactionUncheckedCreateNestedManyWithoutOrderInput
  }

  export type orderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_address?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_fee?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    status_payment?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: merchantUpdateOneRequiredWithoutOrdersNestedInput
    user?: usersUpdateOneRequiredWithoutOrdersNestedInput
    items?: order_itemUpdateManyWithoutOrderNestedInput
    payments?: payment_transactionUpdateManyWithoutOrderNestedInput
  }

  export type orderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchant_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_address?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_fee?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    status_payment?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    items?: order_itemUncheckedUpdateManyWithoutOrderNestedInput
    payments?: payment_transactionUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type orderCreateManyInput = {
    id?: string
    merchant_id: string
    user_id: string
    full_name: string
    phone?: string | null
    delivery_address?: string | null
    delivery_fee?: bigint | number | null
    note?: string | null
    total_amount: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    status?: string | null
    status_payment?: string | null
    payment_method?: string | null
  }

  export type orderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_address?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_fee?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    status_payment?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type orderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchant_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_address?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_fee?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    status_payment?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type order_itemCreateInput = {
    id?: string
    note?: string | null
    quantity: bigint | number
    price: bigint | number
    menu_item: menu_itemCreateNestedOneWithoutOrder_itemsInput
    order: orderCreateNestedOneWithoutItemsInput
    options?: order_item_optionCreateNestedManyWithoutOrder_itemInput
  }

  export type order_itemUncheckedCreateInput = {
    id?: string
    order_id: string
    menu_item_id: string
    note?: string | null
    quantity: bigint | number
    price: bigint | number
    options?: order_item_optionUncheckedCreateNestedManyWithoutOrder_itemInput
  }

  export type order_itemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: BigIntFieldUpdateOperationsInput | bigint | number
    price?: BigIntFieldUpdateOperationsInput | bigint | number
    menu_item?: menu_itemUpdateOneRequiredWithoutOrder_itemsNestedInput
    order?: orderUpdateOneRequiredWithoutItemsNestedInput
    options?: order_item_optionUpdateManyWithoutOrder_itemNestedInput
  }

  export type order_itemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    order_id?: StringFieldUpdateOperationsInput | string
    menu_item_id?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: BigIntFieldUpdateOperationsInput | bigint | number
    price?: BigIntFieldUpdateOperationsInput | bigint | number
    options?: order_item_optionUncheckedUpdateManyWithoutOrder_itemNestedInput
  }

  export type order_itemCreateManyInput = {
    id?: string
    order_id: string
    menu_item_id: string
    note?: string | null
    quantity: bigint | number
    price: bigint | number
  }

  export type order_itemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: BigIntFieldUpdateOperationsInput | bigint | number
    price?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type order_itemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    order_id?: StringFieldUpdateOperationsInput | string
    menu_item_id?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: BigIntFieldUpdateOperationsInput | bigint | number
    price?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type order_item_optionCreateInput = {
    option_item: option_itemCreateNestedOneWithoutOrder_item_optionsInput
    order_item: order_itemCreateNestedOneWithoutOptionsInput
  }

  export type order_item_optionUncheckedCreateInput = {
    order_item_id: string
    option_item_id: string
  }

  export type order_item_optionUpdateInput = {
    option_item?: option_itemUpdateOneRequiredWithoutOrder_item_optionsNestedInput
    order_item?: order_itemUpdateOneRequiredWithoutOptionsNestedInput
  }

  export type order_item_optionUncheckedUpdateInput = {
    order_item_id?: StringFieldUpdateOperationsInput | string
    option_item_id?: StringFieldUpdateOperationsInput | string
  }

  export type order_item_optionCreateManyInput = {
    order_item_id: string
    option_item_id: string
  }

  export type order_item_optionUpdateManyMutationInput = {

  }

  export type order_item_optionUncheckedUpdateManyInput = {
    order_item_id?: StringFieldUpdateOperationsInput | string
    option_item_id?: StringFieldUpdateOperationsInput | string
  }

  export type payment_transactionCreateInput = {
    id?: string
    amount: bigint | number
    currency?: string
    txn_ref: string
    transaction_no?: string | null
    payment_method: string
    status?: $Enums.PaymentStatus
    response_code?: string | null
    bank_code?: string | null
    pay_date?: string | null
    tmn_code?: string | null
    raw_payload?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    merchant: merchantCreateNestedOneWithoutPayment_transactionsInput
    order?: orderCreateNestedOneWithoutPaymentsInput
    user: usersCreateNestedOneWithoutPayment_transactionsInput
  }

  export type payment_transactionUncheckedCreateInput = {
    id?: string
    user_id: string
    merchant_id: string
    order_id?: string | null
    amount: bigint | number
    currency?: string
    txn_ref: string
    transaction_no?: string | null
    payment_method: string
    status?: $Enums.PaymentStatus
    response_code?: string | null
    bank_code?: string | null
    pay_date?: string | null
    tmn_code?: string | null
    raw_payload?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type payment_transactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    txn_ref?: StringFieldUpdateOperationsInput | string
    transaction_no?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    response_code?: NullableStringFieldUpdateOperationsInput | string | null
    bank_code?: NullableStringFieldUpdateOperationsInput | string | null
    pay_date?: NullableStringFieldUpdateOperationsInput | string | null
    tmn_code?: NullableStringFieldUpdateOperationsInput | string | null
    raw_payload?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    merchant?: merchantUpdateOneRequiredWithoutPayment_transactionsNestedInput
    order?: orderUpdateOneWithoutPaymentsNestedInput
    user?: usersUpdateOneRequiredWithoutPayment_transactionsNestedInput
  }

  export type payment_transactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    merchant_id?: StringFieldUpdateOperationsInput | string
    order_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    txn_ref?: StringFieldUpdateOperationsInput | string
    transaction_no?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    response_code?: NullableStringFieldUpdateOperationsInput | string | null
    bank_code?: NullableStringFieldUpdateOperationsInput | string | null
    pay_date?: NullableStringFieldUpdateOperationsInput | string | null
    tmn_code?: NullableStringFieldUpdateOperationsInput | string | null
    raw_payload?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type payment_transactionCreateManyInput = {
    id?: string
    user_id: string
    merchant_id: string
    order_id?: string | null
    amount: bigint | number
    currency?: string
    txn_ref: string
    transaction_no?: string | null
    payment_method: string
    status?: $Enums.PaymentStatus
    response_code?: string | null
    bank_code?: string | null
    pay_date?: string | null
    tmn_code?: string | null
    raw_payload?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type payment_transactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    txn_ref?: StringFieldUpdateOperationsInput | string
    transaction_no?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    response_code?: NullableStringFieldUpdateOperationsInput | string | null
    bank_code?: NullableStringFieldUpdateOperationsInput | string | null
    pay_date?: NullableStringFieldUpdateOperationsInput | string | null
    tmn_code?: NullableStringFieldUpdateOperationsInput | string | null
    raw_payload?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type payment_transactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    merchant_id?: StringFieldUpdateOperationsInput | string
    order_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    txn_ref?: StringFieldUpdateOperationsInput | string
    transaction_no?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    response_code?: NullableStringFieldUpdateOperationsInput | string | null
    bank_code?: NullableStringFieldUpdateOperationsInput | string | null
    pay_date?: NullableStringFieldUpdateOperationsInput | string | null
    tmn_code?: NullableStringFieldUpdateOperationsInput | string | null
    raw_payload?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type MerchantListRelationFilter = {
    every?: merchantWhereInput
    some?: merchantWhereInput
    none?: merchantWhereInput
  }

  export type OrderListRelationFilter = {
    every?: orderWhereInput
    some?: orderWhereInput
    none?: orderWhereInput
  }

  export type Payment_transactionListRelationFilter = {
    every?: payment_transactionWhereInput
    some?: payment_transactionWhereInput
    none?: payment_transactionWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type merchantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type orderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type payment_transactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    image?: SortOrder
    full_name?: SortOrder
    role?: SortOrder
    birth?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    full_name?: SortOrder
    role?: SortOrder
    birth?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    full_name?: SortOrder
    role?: SortOrder
    birth?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type CategoryListRelationFilter = {
    every?: categoryWhereInput
    some?: categoryWhereInput
    none?: categoryWhereInput
  }

  export type Menu_itemListRelationFilter = {
    every?: menu_itemWhereInput
    some?: menu_itemWhereInput
    none?: menu_itemWhereInput
  }

  export type UsersScalarRelationFilter = {
    is?: usersWhereInput
    isNot?: usersWhereInput
  }

  export type OptionListRelationFilter = {
    every?: optionWhereInput
    some?: optionWhereInput
    none?: optionWhereInput
  }

  export type categoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type menu_itemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type optionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type merchantCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    merchant_name?: SortOrder
    location?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    profile_image?: SortOrder
    cover_image?: SortOrder
    time_open?: SortOrder
    cuisine?: SortOrder
  }

  export type merchantMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    merchant_name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    cuisine?: SortOrder
  }

  export type merchantMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    merchant_name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    cuisine?: SortOrder
  }

  export type MerchantScalarRelationFilter = {
    is?: merchantWhereInput
    isNot?: merchantWhereInput
  }

  export type categoryCountOrderByAggregateInput = {
    id?: SortOrder
    merchant_id?: SortOrder
    category_name?: SortOrder
  }

  export type categoryMaxOrderByAggregateInput = {
    id?: SortOrder
    merchant_id?: SortOrder
    category_name?: SortOrder
  }

  export type categoryMinOrderByAggregateInput = {
    id?: SortOrder
    merchant_id?: SortOrder
    category_name?: SortOrder
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type CategoryNullableScalarRelationFilter = {
    is?: categoryWhereInput | null
    isNot?: categoryWhereInput | null
  }

  export type Menu_item_optionListRelationFilter = {
    every?: menu_item_optionWhereInput
    some?: menu_item_optionWhereInput
    none?: menu_item_optionWhereInput
  }

  export type Order_itemListRelationFilter = {
    every?: order_itemWhereInput
    some?: order_itemWhereInput
    none?: order_itemWhereInput
  }

  export type menu_item_optionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type order_itemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type menu_itemCountOrderByAggregateInput = {
    id?: SortOrder
    merchant_id?: SortOrder
    category_id?: SortOrder
    name_item?: SortOrder
    likes?: SortOrder
    price?: SortOrder
    description?: SortOrder
    sold_count?: SortOrder
    image_item?: SortOrder
    status?: SortOrder
  }

  export type menu_itemAvgOrderByAggregateInput = {
    likes?: SortOrder
    price?: SortOrder
    sold_count?: SortOrder
  }

  export type menu_itemMaxOrderByAggregateInput = {
    id?: SortOrder
    merchant_id?: SortOrder
    category_id?: SortOrder
    name_item?: SortOrder
    likes?: SortOrder
    price?: SortOrder
    description?: SortOrder
    sold_count?: SortOrder
    status?: SortOrder
  }

  export type menu_itemMinOrderByAggregateInput = {
    id?: SortOrder
    merchant_id?: SortOrder
    category_id?: SortOrder
    name_item?: SortOrder
    likes?: SortOrder
    price?: SortOrder
    description?: SortOrder
    sold_count?: SortOrder
    status?: SortOrder
  }

  export type menu_itemSumOrderByAggregateInput = {
    likes?: SortOrder
    price?: SortOrder
    sold_count?: SortOrder
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type Option_itemListRelationFilter = {
    every?: option_itemWhereInput
    some?: option_itemWhereInput
    none?: option_itemWhereInput
  }

  export type option_itemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type optionCountOrderByAggregateInput = {
    id?: SortOrder
    merchant_id?: SortOrder
    option_name?: SortOrder
    multi_select?: SortOrder
    require_select?: SortOrder
    number_select?: SortOrder
  }

  export type optionAvgOrderByAggregateInput = {
    number_select?: SortOrder
  }

  export type optionMaxOrderByAggregateInput = {
    id?: SortOrder
    merchant_id?: SortOrder
    option_name?: SortOrder
    multi_select?: SortOrder
    require_select?: SortOrder
    number_select?: SortOrder
  }

  export type optionMinOrderByAggregateInput = {
    id?: SortOrder
    merchant_id?: SortOrder
    option_name?: SortOrder
    multi_select?: SortOrder
    require_select?: SortOrder
    number_select?: SortOrder
  }

  export type optionSumOrderByAggregateInput = {
    number_select?: SortOrder
  }

  export type OptionScalarRelationFilter = {
    is?: optionWhereInput
    isNot?: optionWhereInput
  }

  export type Order_item_optionListRelationFilter = {
    every?: order_item_optionWhereInput
    some?: order_item_optionWhereInput
    none?: order_item_optionWhereInput
  }

  export type order_item_optionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type option_itemCountOrderByAggregateInput = {
    id?: SortOrder
    option_id?: SortOrder
    option_item_name?: SortOrder
    status?: SortOrder
    status_select?: SortOrder
  }

  export type option_itemMaxOrderByAggregateInput = {
    id?: SortOrder
    option_id?: SortOrder
    option_item_name?: SortOrder
    status?: SortOrder
    status_select?: SortOrder
  }

  export type option_itemMinOrderByAggregateInput = {
    id?: SortOrder
    option_id?: SortOrder
    option_item_name?: SortOrder
    status?: SortOrder
    status_select?: SortOrder
  }

  export type Menu_itemScalarRelationFilter = {
    is?: menu_itemWhereInput
    isNot?: menu_itemWhereInput
  }

  export type menu_item_optionOption_idMenu_item_idCompoundUniqueInput = {
    option_id: string
    menu_item_id: string
  }

  export type menu_item_optionCountOrderByAggregateInput = {
    option_id?: SortOrder
    menu_item_id?: SortOrder
  }

  export type menu_item_optionMaxOrderByAggregateInput = {
    option_id?: SortOrder
    menu_item_id?: SortOrder
  }

  export type menu_item_optionMinOrderByAggregateInput = {
    option_id?: SortOrder
    menu_item_id?: SortOrder
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type orderCountOrderByAggregateInput = {
    id?: SortOrder
    merchant_id?: SortOrder
    user_id?: SortOrder
    full_name?: SortOrder
    phone?: SortOrder
    delivery_address?: SortOrder
    delivery_fee?: SortOrder
    note?: SortOrder
    total_amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    status?: SortOrder
    status_payment?: SortOrder
    payment_method?: SortOrder
  }

  export type orderAvgOrderByAggregateInput = {
    delivery_fee?: SortOrder
    total_amount?: SortOrder
  }

  export type orderMaxOrderByAggregateInput = {
    id?: SortOrder
    merchant_id?: SortOrder
    user_id?: SortOrder
    full_name?: SortOrder
    phone?: SortOrder
    delivery_address?: SortOrder
    delivery_fee?: SortOrder
    note?: SortOrder
    total_amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    status?: SortOrder
    status_payment?: SortOrder
    payment_method?: SortOrder
  }

  export type orderMinOrderByAggregateInput = {
    id?: SortOrder
    merchant_id?: SortOrder
    user_id?: SortOrder
    full_name?: SortOrder
    phone?: SortOrder
    delivery_address?: SortOrder
    delivery_fee?: SortOrder
    note?: SortOrder
    total_amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    status?: SortOrder
    status_payment?: SortOrder
    payment_method?: SortOrder
  }

  export type orderSumOrderByAggregateInput = {
    delivery_fee?: SortOrder
    total_amount?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type OrderScalarRelationFilter = {
    is?: orderWhereInput
    isNot?: orderWhereInput
  }

  export type order_itemCountOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    menu_item_id?: SortOrder
    note?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
  }

  export type order_itemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
  }

  export type order_itemMaxOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    menu_item_id?: SortOrder
    note?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
  }

  export type order_itemMinOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    menu_item_id?: SortOrder
    note?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
  }

  export type order_itemSumOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
  }

  export type Option_itemScalarRelationFilter = {
    is?: option_itemWhereInput
    isNot?: option_itemWhereInput
  }

  export type Order_itemScalarRelationFilter = {
    is?: order_itemWhereInput
    isNot?: order_itemWhereInput
  }

  export type order_item_optionOrder_item_idOption_item_idCompoundUniqueInput = {
    order_item_id: string
    option_item_id: string
  }

  export type order_item_optionCountOrderByAggregateInput = {
    order_item_id?: SortOrder
    option_item_id?: SortOrder
  }

  export type order_item_optionMaxOrderByAggregateInput = {
    order_item_id?: SortOrder
    option_item_id?: SortOrder
  }

  export type order_item_optionMinOrderByAggregateInput = {
    order_item_id?: SortOrder
    option_item_id?: SortOrder
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type OrderNullableScalarRelationFilter = {
    is?: orderWhereInput | null
    isNot?: orderWhereInput | null
  }

  export type payment_transactionOrder_idTxn_refCompoundUniqueInput = {
    order_id: string
    txn_ref: string
  }

  export type payment_transactionCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    merchant_id?: SortOrder
    order_id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    txn_ref?: SortOrder
    transaction_no?: SortOrder
    payment_method?: SortOrder
    status?: SortOrder
    response_code?: SortOrder
    bank_code?: SortOrder
    pay_date?: SortOrder
    tmn_code?: SortOrder
    raw_payload?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type payment_transactionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type payment_transactionMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    merchant_id?: SortOrder
    order_id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    txn_ref?: SortOrder
    transaction_no?: SortOrder
    payment_method?: SortOrder
    status?: SortOrder
    response_code?: SortOrder
    bank_code?: SortOrder
    pay_date?: SortOrder
    tmn_code?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type payment_transactionMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    merchant_id?: SortOrder
    order_id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    txn_ref?: SortOrder
    transaction_no?: SortOrder
    payment_method?: SortOrder
    status?: SortOrder
    response_code?: SortOrder
    bank_code?: SortOrder
    pay_date?: SortOrder
    tmn_code?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type payment_transactionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type merchantCreateNestedManyWithoutUserInput = {
    create?: XOR<merchantCreateWithoutUserInput, merchantUncheckedCreateWithoutUserInput> | merchantCreateWithoutUserInput[] | merchantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: merchantCreateOrConnectWithoutUserInput | merchantCreateOrConnectWithoutUserInput[]
    createMany?: merchantCreateManyUserInputEnvelope
    connect?: merchantWhereUniqueInput | merchantWhereUniqueInput[]
  }

  export type orderCreateNestedManyWithoutUserInput = {
    create?: XOR<orderCreateWithoutUserInput, orderUncheckedCreateWithoutUserInput> | orderCreateWithoutUserInput[] | orderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: orderCreateOrConnectWithoutUserInput | orderCreateOrConnectWithoutUserInput[]
    createMany?: orderCreateManyUserInputEnvelope
    connect?: orderWhereUniqueInput | orderWhereUniqueInput[]
  }

  export type payment_transactionCreateNestedManyWithoutUserInput = {
    create?: XOR<payment_transactionCreateWithoutUserInput, payment_transactionUncheckedCreateWithoutUserInput> | payment_transactionCreateWithoutUserInput[] | payment_transactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: payment_transactionCreateOrConnectWithoutUserInput | payment_transactionCreateOrConnectWithoutUserInput[]
    createMany?: payment_transactionCreateManyUserInputEnvelope
    connect?: payment_transactionWhereUniqueInput | payment_transactionWhereUniqueInput[]
  }

  export type merchantUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<merchantCreateWithoutUserInput, merchantUncheckedCreateWithoutUserInput> | merchantCreateWithoutUserInput[] | merchantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: merchantCreateOrConnectWithoutUserInput | merchantCreateOrConnectWithoutUserInput[]
    createMany?: merchantCreateManyUserInputEnvelope
    connect?: merchantWhereUniqueInput | merchantWhereUniqueInput[]
  }

  export type orderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<orderCreateWithoutUserInput, orderUncheckedCreateWithoutUserInput> | orderCreateWithoutUserInput[] | orderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: orderCreateOrConnectWithoutUserInput | orderCreateOrConnectWithoutUserInput[]
    createMany?: orderCreateManyUserInputEnvelope
    connect?: orderWhereUniqueInput | orderWhereUniqueInput[]
  }

  export type payment_transactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<payment_transactionCreateWithoutUserInput, payment_transactionUncheckedCreateWithoutUserInput> | payment_transactionCreateWithoutUserInput[] | payment_transactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: payment_transactionCreateOrConnectWithoutUserInput | payment_transactionCreateOrConnectWithoutUserInput[]
    createMany?: payment_transactionCreateManyUserInputEnvelope
    connect?: payment_transactionWhereUniqueInput | payment_transactionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type merchantUpdateManyWithoutUserNestedInput = {
    create?: XOR<merchantCreateWithoutUserInput, merchantUncheckedCreateWithoutUserInput> | merchantCreateWithoutUserInput[] | merchantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: merchantCreateOrConnectWithoutUserInput | merchantCreateOrConnectWithoutUserInput[]
    upsert?: merchantUpsertWithWhereUniqueWithoutUserInput | merchantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: merchantCreateManyUserInputEnvelope
    set?: merchantWhereUniqueInput | merchantWhereUniqueInput[]
    disconnect?: merchantWhereUniqueInput | merchantWhereUniqueInput[]
    delete?: merchantWhereUniqueInput | merchantWhereUniqueInput[]
    connect?: merchantWhereUniqueInput | merchantWhereUniqueInput[]
    update?: merchantUpdateWithWhereUniqueWithoutUserInput | merchantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: merchantUpdateManyWithWhereWithoutUserInput | merchantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: merchantScalarWhereInput | merchantScalarWhereInput[]
  }

  export type orderUpdateManyWithoutUserNestedInput = {
    create?: XOR<orderCreateWithoutUserInput, orderUncheckedCreateWithoutUserInput> | orderCreateWithoutUserInput[] | orderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: orderCreateOrConnectWithoutUserInput | orderCreateOrConnectWithoutUserInput[]
    upsert?: orderUpsertWithWhereUniqueWithoutUserInput | orderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: orderCreateManyUserInputEnvelope
    set?: orderWhereUniqueInput | orderWhereUniqueInput[]
    disconnect?: orderWhereUniqueInput | orderWhereUniqueInput[]
    delete?: orderWhereUniqueInput | orderWhereUniqueInput[]
    connect?: orderWhereUniqueInput | orderWhereUniqueInput[]
    update?: orderUpdateWithWhereUniqueWithoutUserInput | orderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: orderUpdateManyWithWhereWithoutUserInput | orderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: orderScalarWhereInput | orderScalarWhereInput[]
  }

  export type payment_transactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<payment_transactionCreateWithoutUserInput, payment_transactionUncheckedCreateWithoutUserInput> | payment_transactionCreateWithoutUserInput[] | payment_transactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: payment_transactionCreateOrConnectWithoutUserInput | payment_transactionCreateOrConnectWithoutUserInput[]
    upsert?: payment_transactionUpsertWithWhereUniqueWithoutUserInput | payment_transactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: payment_transactionCreateManyUserInputEnvelope
    set?: payment_transactionWhereUniqueInput | payment_transactionWhereUniqueInput[]
    disconnect?: payment_transactionWhereUniqueInput | payment_transactionWhereUniqueInput[]
    delete?: payment_transactionWhereUniqueInput | payment_transactionWhereUniqueInput[]
    connect?: payment_transactionWhereUniqueInput | payment_transactionWhereUniqueInput[]
    update?: payment_transactionUpdateWithWhereUniqueWithoutUserInput | payment_transactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: payment_transactionUpdateManyWithWhereWithoutUserInput | payment_transactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: payment_transactionScalarWhereInput | payment_transactionScalarWhereInput[]
  }

  export type merchantUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<merchantCreateWithoutUserInput, merchantUncheckedCreateWithoutUserInput> | merchantCreateWithoutUserInput[] | merchantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: merchantCreateOrConnectWithoutUserInput | merchantCreateOrConnectWithoutUserInput[]
    upsert?: merchantUpsertWithWhereUniqueWithoutUserInput | merchantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: merchantCreateManyUserInputEnvelope
    set?: merchantWhereUniqueInput | merchantWhereUniqueInput[]
    disconnect?: merchantWhereUniqueInput | merchantWhereUniqueInput[]
    delete?: merchantWhereUniqueInput | merchantWhereUniqueInput[]
    connect?: merchantWhereUniqueInput | merchantWhereUniqueInput[]
    update?: merchantUpdateWithWhereUniqueWithoutUserInput | merchantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: merchantUpdateManyWithWhereWithoutUserInput | merchantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: merchantScalarWhereInput | merchantScalarWhereInput[]
  }

  export type orderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<orderCreateWithoutUserInput, orderUncheckedCreateWithoutUserInput> | orderCreateWithoutUserInput[] | orderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: orderCreateOrConnectWithoutUserInput | orderCreateOrConnectWithoutUserInput[]
    upsert?: orderUpsertWithWhereUniqueWithoutUserInput | orderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: orderCreateManyUserInputEnvelope
    set?: orderWhereUniqueInput | orderWhereUniqueInput[]
    disconnect?: orderWhereUniqueInput | orderWhereUniqueInput[]
    delete?: orderWhereUniqueInput | orderWhereUniqueInput[]
    connect?: orderWhereUniqueInput | orderWhereUniqueInput[]
    update?: orderUpdateWithWhereUniqueWithoutUserInput | orderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: orderUpdateManyWithWhereWithoutUserInput | orderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: orderScalarWhereInput | orderScalarWhereInput[]
  }

  export type payment_transactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<payment_transactionCreateWithoutUserInput, payment_transactionUncheckedCreateWithoutUserInput> | payment_transactionCreateWithoutUserInput[] | payment_transactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: payment_transactionCreateOrConnectWithoutUserInput | payment_transactionCreateOrConnectWithoutUserInput[]
    upsert?: payment_transactionUpsertWithWhereUniqueWithoutUserInput | payment_transactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: payment_transactionCreateManyUserInputEnvelope
    set?: payment_transactionWhereUniqueInput | payment_transactionWhereUniqueInput[]
    disconnect?: payment_transactionWhereUniqueInput | payment_transactionWhereUniqueInput[]
    delete?: payment_transactionWhereUniqueInput | payment_transactionWhereUniqueInput[]
    connect?: payment_transactionWhereUniqueInput | payment_transactionWhereUniqueInput[]
    update?: payment_transactionUpdateWithWhereUniqueWithoutUserInput | payment_transactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: payment_transactionUpdateManyWithWhereWithoutUserInput | payment_transactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: payment_transactionScalarWhereInput | payment_transactionScalarWhereInput[]
  }

  export type categoryCreateNestedManyWithoutMerchantInput = {
    create?: XOR<categoryCreateWithoutMerchantInput, categoryUncheckedCreateWithoutMerchantInput> | categoryCreateWithoutMerchantInput[] | categoryUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: categoryCreateOrConnectWithoutMerchantInput | categoryCreateOrConnectWithoutMerchantInput[]
    createMany?: categoryCreateManyMerchantInputEnvelope
    connect?: categoryWhereUniqueInput | categoryWhereUniqueInput[]
  }

  export type menu_itemCreateNestedManyWithoutMerchantInput = {
    create?: XOR<menu_itemCreateWithoutMerchantInput, menu_itemUncheckedCreateWithoutMerchantInput> | menu_itemCreateWithoutMerchantInput[] | menu_itemUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: menu_itemCreateOrConnectWithoutMerchantInput | menu_itemCreateOrConnectWithoutMerchantInput[]
    createMany?: menu_itemCreateManyMerchantInputEnvelope
    connect?: menu_itemWhereUniqueInput | menu_itemWhereUniqueInput[]
  }

  export type usersCreateNestedOneWithoutMerchantsInput = {
    create?: XOR<usersCreateWithoutMerchantsInput, usersUncheckedCreateWithoutMerchantsInput>
    connectOrCreate?: usersCreateOrConnectWithoutMerchantsInput
    connect?: usersWhereUniqueInput
  }

  export type optionCreateNestedManyWithoutMerchantInput = {
    create?: XOR<optionCreateWithoutMerchantInput, optionUncheckedCreateWithoutMerchantInput> | optionCreateWithoutMerchantInput[] | optionUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: optionCreateOrConnectWithoutMerchantInput | optionCreateOrConnectWithoutMerchantInput[]
    createMany?: optionCreateManyMerchantInputEnvelope
    connect?: optionWhereUniqueInput | optionWhereUniqueInput[]
  }

  export type orderCreateNestedManyWithoutMerchantInput = {
    create?: XOR<orderCreateWithoutMerchantInput, orderUncheckedCreateWithoutMerchantInput> | orderCreateWithoutMerchantInput[] | orderUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: orderCreateOrConnectWithoutMerchantInput | orderCreateOrConnectWithoutMerchantInput[]
    createMany?: orderCreateManyMerchantInputEnvelope
    connect?: orderWhereUniqueInput | orderWhereUniqueInput[]
  }

  export type payment_transactionCreateNestedManyWithoutMerchantInput = {
    create?: XOR<payment_transactionCreateWithoutMerchantInput, payment_transactionUncheckedCreateWithoutMerchantInput> | payment_transactionCreateWithoutMerchantInput[] | payment_transactionUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: payment_transactionCreateOrConnectWithoutMerchantInput | payment_transactionCreateOrConnectWithoutMerchantInput[]
    createMany?: payment_transactionCreateManyMerchantInputEnvelope
    connect?: payment_transactionWhereUniqueInput | payment_transactionWhereUniqueInput[]
  }

  export type categoryUncheckedCreateNestedManyWithoutMerchantInput = {
    create?: XOR<categoryCreateWithoutMerchantInput, categoryUncheckedCreateWithoutMerchantInput> | categoryCreateWithoutMerchantInput[] | categoryUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: categoryCreateOrConnectWithoutMerchantInput | categoryCreateOrConnectWithoutMerchantInput[]
    createMany?: categoryCreateManyMerchantInputEnvelope
    connect?: categoryWhereUniqueInput | categoryWhereUniqueInput[]
  }

  export type menu_itemUncheckedCreateNestedManyWithoutMerchantInput = {
    create?: XOR<menu_itemCreateWithoutMerchantInput, menu_itemUncheckedCreateWithoutMerchantInput> | menu_itemCreateWithoutMerchantInput[] | menu_itemUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: menu_itemCreateOrConnectWithoutMerchantInput | menu_itemCreateOrConnectWithoutMerchantInput[]
    createMany?: menu_itemCreateManyMerchantInputEnvelope
    connect?: menu_itemWhereUniqueInput | menu_itemWhereUniqueInput[]
  }

  export type optionUncheckedCreateNestedManyWithoutMerchantInput = {
    create?: XOR<optionCreateWithoutMerchantInput, optionUncheckedCreateWithoutMerchantInput> | optionCreateWithoutMerchantInput[] | optionUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: optionCreateOrConnectWithoutMerchantInput | optionCreateOrConnectWithoutMerchantInput[]
    createMany?: optionCreateManyMerchantInputEnvelope
    connect?: optionWhereUniqueInput | optionWhereUniqueInput[]
  }

  export type orderUncheckedCreateNestedManyWithoutMerchantInput = {
    create?: XOR<orderCreateWithoutMerchantInput, orderUncheckedCreateWithoutMerchantInput> | orderCreateWithoutMerchantInput[] | orderUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: orderCreateOrConnectWithoutMerchantInput | orderCreateOrConnectWithoutMerchantInput[]
    createMany?: orderCreateManyMerchantInputEnvelope
    connect?: orderWhereUniqueInput | orderWhereUniqueInput[]
  }

  export type payment_transactionUncheckedCreateNestedManyWithoutMerchantInput = {
    create?: XOR<payment_transactionCreateWithoutMerchantInput, payment_transactionUncheckedCreateWithoutMerchantInput> | payment_transactionCreateWithoutMerchantInput[] | payment_transactionUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: payment_transactionCreateOrConnectWithoutMerchantInput | payment_transactionCreateOrConnectWithoutMerchantInput[]
    createMany?: payment_transactionCreateManyMerchantInputEnvelope
    connect?: payment_transactionWhereUniqueInput | payment_transactionWhereUniqueInput[]
  }

  export type categoryUpdateManyWithoutMerchantNestedInput = {
    create?: XOR<categoryCreateWithoutMerchantInput, categoryUncheckedCreateWithoutMerchantInput> | categoryCreateWithoutMerchantInput[] | categoryUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: categoryCreateOrConnectWithoutMerchantInput | categoryCreateOrConnectWithoutMerchantInput[]
    upsert?: categoryUpsertWithWhereUniqueWithoutMerchantInput | categoryUpsertWithWhereUniqueWithoutMerchantInput[]
    createMany?: categoryCreateManyMerchantInputEnvelope
    set?: categoryWhereUniqueInput | categoryWhereUniqueInput[]
    disconnect?: categoryWhereUniqueInput | categoryWhereUniqueInput[]
    delete?: categoryWhereUniqueInput | categoryWhereUniqueInput[]
    connect?: categoryWhereUniqueInput | categoryWhereUniqueInput[]
    update?: categoryUpdateWithWhereUniqueWithoutMerchantInput | categoryUpdateWithWhereUniqueWithoutMerchantInput[]
    updateMany?: categoryUpdateManyWithWhereWithoutMerchantInput | categoryUpdateManyWithWhereWithoutMerchantInput[]
    deleteMany?: categoryScalarWhereInput | categoryScalarWhereInput[]
  }

  export type menu_itemUpdateManyWithoutMerchantNestedInput = {
    create?: XOR<menu_itemCreateWithoutMerchantInput, menu_itemUncheckedCreateWithoutMerchantInput> | menu_itemCreateWithoutMerchantInput[] | menu_itemUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: menu_itemCreateOrConnectWithoutMerchantInput | menu_itemCreateOrConnectWithoutMerchantInput[]
    upsert?: menu_itemUpsertWithWhereUniqueWithoutMerchantInput | menu_itemUpsertWithWhereUniqueWithoutMerchantInput[]
    createMany?: menu_itemCreateManyMerchantInputEnvelope
    set?: menu_itemWhereUniqueInput | menu_itemWhereUniqueInput[]
    disconnect?: menu_itemWhereUniqueInput | menu_itemWhereUniqueInput[]
    delete?: menu_itemWhereUniqueInput | menu_itemWhereUniqueInput[]
    connect?: menu_itemWhereUniqueInput | menu_itemWhereUniqueInput[]
    update?: menu_itemUpdateWithWhereUniqueWithoutMerchantInput | menu_itemUpdateWithWhereUniqueWithoutMerchantInput[]
    updateMany?: menu_itemUpdateManyWithWhereWithoutMerchantInput | menu_itemUpdateManyWithWhereWithoutMerchantInput[]
    deleteMany?: menu_itemScalarWhereInput | menu_itemScalarWhereInput[]
  }

  export type usersUpdateOneRequiredWithoutMerchantsNestedInput = {
    create?: XOR<usersCreateWithoutMerchantsInput, usersUncheckedCreateWithoutMerchantsInput>
    connectOrCreate?: usersCreateOrConnectWithoutMerchantsInput
    upsert?: usersUpsertWithoutMerchantsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutMerchantsInput, usersUpdateWithoutMerchantsInput>, usersUncheckedUpdateWithoutMerchantsInput>
  }

  export type optionUpdateManyWithoutMerchantNestedInput = {
    create?: XOR<optionCreateWithoutMerchantInput, optionUncheckedCreateWithoutMerchantInput> | optionCreateWithoutMerchantInput[] | optionUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: optionCreateOrConnectWithoutMerchantInput | optionCreateOrConnectWithoutMerchantInput[]
    upsert?: optionUpsertWithWhereUniqueWithoutMerchantInput | optionUpsertWithWhereUniqueWithoutMerchantInput[]
    createMany?: optionCreateManyMerchantInputEnvelope
    set?: optionWhereUniqueInput | optionWhereUniqueInput[]
    disconnect?: optionWhereUniqueInput | optionWhereUniqueInput[]
    delete?: optionWhereUniqueInput | optionWhereUniqueInput[]
    connect?: optionWhereUniqueInput | optionWhereUniqueInput[]
    update?: optionUpdateWithWhereUniqueWithoutMerchantInput | optionUpdateWithWhereUniqueWithoutMerchantInput[]
    updateMany?: optionUpdateManyWithWhereWithoutMerchantInput | optionUpdateManyWithWhereWithoutMerchantInput[]
    deleteMany?: optionScalarWhereInput | optionScalarWhereInput[]
  }

  export type orderUpdateManyWithoutMerchantNestedInput = {
    create?: XOR<orderCreateWithoutMerchantInput, orderUncheckedCreateWithoutMerchantInput> | orderCreateWithoutMerchantInput[] | orderUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: orderCreateOrConnectWithoutMerchantInput | orderCreateOrConnectWithoutMerchantInput[]
    upsert?: orderUpsertWithWhereUniqueWithoutMerchantInput | orderUpsertWithWhereUniqueWithoutMerchantInput[]
    createMany?: orderCreateManyMerchantInputEnvelope
    set?: orderWhereUniqueInput | orderWhereUniqueInput[]
    disconnect?: orderWhereUniqueInput | orderWhereUniqueInput[]
    delete?: orderWhereUniqueInput | orderWhereUniqueInput[]
    connect?: orderWhereUniqueInput | orderWhereUniqueInput[]
    update?: orderUpdateWithWhereUniqueWithoutMerchantInput | orderUpdateWithWhereUniqueWithoutMerchantInput[]
    updateMany?: orderUpdateManyWithWhereWithoutMerchantInput | orderUpdateManyWithWhereWithoutMerchantInput[]
    deleteMany?: orderScalarWhereInput | orderScalarWhereInput[]
  }

  export type payment_transactionUpdateManyWithoutMerchantNestedInput = {
    create?: XOR<payment_transactionCreateWithoutMerchantInput, payment_transactionUncheckedCreateWithoutMerchantInput> | payment_transactionCreateWithoutMerchantInput[] | payment_transactionUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: payment_transactionCreateOrConnectWithoutMerchantInput | payment_transactionCreateOrConnectWithoutMerchantInput[]
    upsert?: payment_transactionUpsertWithWhereUniqueWithoutMerchantInput | payment_transactionUpsertWithWhereUniqueWithoutMerchantInput[]
    createMany?: payment_transactionCreateManyMerchantInputEnvelope
    set?: payment_transactionWhereUniqueInput | payment_transactionWhereUniqueInput[]
    disconnect?: payment_transactionWhereUniqueInput | payment_transactionWhereUniqueInput[]
    delete?: payment_transactionWhereUniqueInput | payment_transactionWhereUniqueInput[]
    connect?: payment_transactionWhereUniqueInput | payment_transactionWhereUniqueInput[]
    update?: payment_transactionUpdateWithWhereUniqueWithoutMerchantInput | payment_transactionUpdateWithWhereUniqueWithoutMerchantInput[]
    updateMany?: payment_transactionUpdateManyWithWhereWithoutMerchantInput | payment_transactionUpdateManyWithWhereWithoutMerchantInput[]
    deleteMany?: payment_transactionScalarWhereInput | payment_transactionScalarWhereInput[]
  }

  export type categoryUncheckedUpdateManyWithoutMerchantNestedInput = {
    create?: XOR<categoryCreateWithoutMerchantInput, categoryUncheckedCreateWithoutMerchantInput> | categoryCreateWithoutMerchantInput[] | categoryUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: categoryCreateOrConnectWithoutMerchantInput | categoryCreateOrConnectWithoutMerchantInput[]
    upsert?: categoryUpsertWithWhereUniqueWithoutMerchantInput | categoryUpsertWithWhereUniqueWithoutMerchantInput[]
    createMany?: categoryCreateManyMerchantInputEnvelope
    set?: categoryWhereUniqueInput | categoryWhereUniqueInput[]
    disconnect?: categoryWhereUniqueInput | categoryWhereUniqueInput[]
    delete?: categoryWhereUniqueInput | categoryWhereUniqueInput[]
    connect?: categoryWhereUniqueInput | categoryWhereUniqueInput[]
    update?: categoryUpdateWithWhereUniqueWithoutMerchantInput | categoryUpdateWithWhereUniqueWithoutMerchantInput[]
    updateMany?: categoryUpdateManyWithWhereWithoutMerchantInput | categoryUpdateManyWithWhereWithoutMerchantInput[]
    deleteMany?: categoryScalarWhereInput | categoryScalarWhereInput[]
  }

  export type menu_itemUncheckedUpdateManyWithoutMerchantNestedInput = {
    create?: XOR<menu_itemCreateWithoutMerchantInput, menu_itemUncheckedCreateWithoutMerchantInput> | menu_itemCreateWithoutMerchantInput[] | menu_itemUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: menu_itemCreateOrConnectWithoutMerchantInput | menu_itemCreateOrConnectWithoutMerchantInput[]
    upsert?: menu_itemUpsertWithWhereUniqueWithoutMerchantInput | menu_itemUpsertWithWhereUniqueWithoutMerchantInput[]
    createMany?: menu_itemCreateManyMerchantInputEnvelope
    set?: menu_itemWhereUniqueInput | menu_itemWhereUniqueInput[]
    disconnect?: menu_itemWhereUniqueInput | menu_itemWhereUniqueInput[]
    delete?: menu_itemWhereUniqueInput | menu_itemWhereUniqueInput[]
    connect?: menu_itemWhereUniqueInput | menu_itemWhereUniqueInput[]
    update?: menu_itemUpdateWithWhereUniqueWithoutMerchantInput | menu_itemUpdateWithWhereUniqueWithoutMerchantInput[]
    updateMany?: menu_itemUpdateManyWithWhereWithoutMerchantInput | menu_itemUpdateManyWithWhereWithoutMerchantInput[]
    deleteMany?: menu_itemScalarWhereInput | menu_itemScalarWhereInput[]
  }

  export type optionUncheckedUpdateManyWithoutMerchantNestedInput = {
    create?: XOR<optionCreateWithoutMerchantInput, optionUncheckedCreateWithoutMerchantInput> | optionCreateWithoutMerchantInput[] | optionUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: optionCreateOrConnectWithoutMerchantInput | optionCreateOrConnectWithoutMerchantInput[]
    upsert?: optionUpsertWithWhereUniqueWithoutMerchantInput | optionUpsertWithWhereUniqueWithoutMerchantInput[]
    createMany?: optionCreateManyMerchantInputEnvelope
    set?: optionWhereUniqueInput | optionWhereUniqueInput[]
    disconnect?: optionWhereUniqueInput | optionWhereUniqueInput[]
    delete?: optionWhereUniqueInput | optionWhereUniqueInput[]
    connect?: optionWhereUniqueInput | optionWhereUniqueInput[]
    update?: optionUpdateWithWhereUniqueWithoutMerchantInput | optionUpdateWithWhereUniqueWithoutMerchantInput[]
    updateMany?: optionUpdateManyWithWhereWithoutMerchantInput | optionUpdateManyWithWhereWithoutMerchantInput[]
    deleteMany?: optionScalarWhereInput | optionScalarWhereInput[]
  }

  export type orderUncheckedUpdateManyWithoutMerchantNestedInput = {
    create?: XOR<orderCreateWithoutMerchantInput, orderUncheckedCreateWithoutMerchantInput> | orderCreateWithoutMerchantInput[] | orderUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: orderCreateOrConnectWithoutMerchantInput | orderCreateOrConnectWithoutMerchantInput[]
    upsert?: orderUpsertWithWhereUniqueWithoutMerchantInput | orderUpsertWithWhereUniqueWithoutMerchantInput[]
    createMany?: orderCreateManyMerchantInputEnvelope
    set?: orderWhereUniqueInput | orderWhereUniqueInput[]
    disconnect?: orderWhereUniqueInput | orderWhereUniqueInput[]
    delete?: orderWhereUniqueInput | orderWhereUniqueInput[]
    connect?: orderWhereUniqueInput | orderWhereUniqueInput[]
    update?: orderUpdateWithWhereUniqueWithoutMerchantInput | orderUpdateWithWhereUniqueWithoutMerchantInput[]
    updateMany?: orderUpdateManyWithWhereWithoutMerchantInput | orderUpdateManyWithWhereWithoutMerchantInput[]
    deleteMany?: orderScalarWhereInput | orderScalarWhereInput[]
  }

  export type payment_transactionUncheckedUpdateManyWithoutMerchantNestedInput = {
    create?: XOR<payment_transactionCreateWithoutMerchantInput, payment_transactionUncheckedCreateWithoutMerchantInput> | payment_transactionCreateWithoutMerchantInput[] | payment_transactionUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: payment_transactionCreateOrConnectWithoutMerchantInput | payment_transactionCreateOrConnectWithoutMerchantInput[]
    upsert?: payment_transactionUpsertWithWhereUniqueWithoutMerchantInput | payment_transactionUpsertWithWhereUniqueWithoutMerchantInput[]
    createMany?: payment_transactionCreateManyMerchantInputEnvelope
    set?: payment_transactionWhereUniqueInput | payment_transactionWhereUniqueInput[]
    disconnect?: payment_transactionWhereUniqueInput | payment_transactionWhereUniqueInput[]
    delete?: payment_transactionWhereUniqueInput | payment_transactionWhereUniqueInput[]
    connect?: payment_transactionWhereUniqueInput | payment_transactionWhereUniqueInput[]
    update?: payment_transactionUpdateWithWhereUniqueWithoutMerchantInput | payment_transactionUpdateWithWhereUniqueWithoutMerchantInput[]
    updateMany?: payment_transactionUpdateManyWithWhereWithoutMerchantInput | payment_transactionUpdateManyWithWhereWithoutMerchantInput[]
    deleteMany?: payment_transactionScalarWhereInput | payment_transactionScalarWhereInput[]
  }

  export type merchantCreateNestedOneWithoutCategoriesInput = {
    create?: XOR<merchantCreateWithoutCategoriesInput, merchantUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: merchantCreateOrConnectWithoutCategoriesInput
    connect?: merchantWhereUniqueInput
  }

  export type menu_itemCreateNestedManyWithoutCategoryInput = {
    create?: XOR<menu_itemCreateWithoutCategoryInput, menu_itemUncheckedCreateWithoutCategoryInput> | menu_itemCreateWithoutCategoryInput[] | menu_itemUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: menu_itemCreateOrConnectWithoutCategoryInput | menu_itemCreateOrConnectWithoutCategoryInput[]
    createMany?: menu_itemCreateManyCategoryInputEnvelope
    connect?: menu_itemWhereUniqueInput | menu_itemWhereUniqueInput[]
  }

  export type menu_itemUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<menu_itemCreateWithoutCategoryInput, menu_itemUncheckedCreateWithoutCategoryInput> | menu_itemCreateWithoutCategoryInput[] | menu_itemUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: menu_itemCreateOrConnectWithoutCategoryInput | menu_itemCreateOrConnectWithoutCategoryInput[]
    createMany?: menu_itemCreateManyCategoryInputEnvelope
    connect?: menu_itemWhereUniqueInput | menu_itemWhereUniqueInput[]
  }

  export type merchantUpdateOneRequiredWithoutCategoriesNestedInput = {
    create?: XOR<merchantCreateWithoutCategoriesInput, merchantUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: merchantCreateOrConnectWithoutCategoriesInput
    upsert?: merchantUpsertWithoutCategoriesInput
    connect?: merchantWhereUniqueInput
    update?: XOR<XOR<merchantUpdateToOneWithWhereWithoutCategoriesInput, merchantUpdateWithoutCategoriesInput>, merchantUncheckedUpdateWithoutCategoriesInput>
  }

  export type menu_itemUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<menu_itemCreateWithoutCategoryInput, menu_itemUncheckedCreateWithoutCategoryInput> | menu_itemCreateWithoutCategoryInput[] | menu_itemUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: menu_itemCreateOrConnectWithoutCategoryInput | menu_itemCreateOrConnectWithoutCategoryInput[]
    upsert?: menu_itemUpsertWithWhereUniqueWithoutCategoryInput | menu_itemUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: menu_itemCreateManyCategoryInputEnvelope
    set?: menu_itemWhereUniqueInput | menu_itemWhereUniqueInput[]
    disconnect?: menu_itemWhereUniqueInput | menu_itemWhereUniqueInput[]
    delete?: menu_itemWhereUniqueInput | menu_itemWhereUniqueInput[]
    connect?: menu_itemWhereUniqueInput | menu_itemWhereUniqueInput[]
    update?: menu_itemUpdateWithWhereUniqueWithoutCategoryInput | menu_itemUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: menu_itemUpdateManyWithWhereWithoutCategoryInput | menu_itemUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: menu_itemScalarWhereInput | menu_itemScalarWhereInput[]
  }

  export type menu_itemUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<menu_itemCreateWithoutCategoryInput, menu_itemUncheckedCreateWithoutCategoryInput> | menu_itemCreateWithoutCategoryInput[] | menu_itemUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: menu_itemCreateOrConnectWithoutCategoryInput | menu_itemCreateOrConnectWithoutCategoryInput[]
    upsert?: menu_itemUpsertWithWhereUniqueWithoutCategoryInput | menu_itemUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: menu_itemCreateManyCategoryInputEnvelope
    set?: menu_itemWhereUniqueInput | menu_itemWhereUniqueInput[]
    disconnect?: menu_itemWhereUniqueInput | menu_itemWhereUniqueInput[]
    delete?: menu_itemWhereUniqueInput | menu_itemWhereUniqueInput[]
    connect?: menu_itemWhereUniqueInput | menu_itemWhereUniqueInput[]
    update?: menu_itemUpdateWithWhereUniqueWithoutCategoryInput | menu_itemUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: menu_itemUpdateManyWithWhereWithoutCategoryInput | menu_itemUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: menu_itemScalarWhereInput | menu_itemScalarWhereInput[]
  }

  export type categoryCreateNestedOneWithoutMenu_itemInput = {
    create?: XOR<categoryCreateWithoutMenu_itemInput, categoryUncheckedCreateWithoutMenu_itemInput>
    connectOrCreate?: categoryCreateOrConnectWithoutMenu_itemInput
    connect?: categoryWhereUniqueInput
  }

  export type merchantCreateNestedOneWithoutMenu_itemInput = {
    create?: XOR<merchantCreateWithoutMenu_itemInput, merchantUncheckedCreateWithoutMenu_itemInput>
    connectOrCreate?: merchantCreateOrConnectWithoutMenu_itemInput
    connect?: merchantWhereUniqueInput
  }

  export type menu_item_optionCreateNestedManyWithoutMenu_itemInput = {
    create?: XOR<menu_item_optionCreateWithoutMenu_itemInput, menu_item_optionUncheckedCreateWithoutMenu_itemInput> | menu_item_optionCreateWithoutMenu_itemInput[] | menu_item_optionUncheckedCreateWithoutMenu_itemInput[]
    connectOrCreate?: menu_item_optionCreateOrConnectWithoutMenu_itemInput | menu_item_optionCreateOrConnectWithoutMenu_itemInput[]
    createMany?: menu_item_optionCreateManyMenu_itemInputEnvelope
    connect?: menu_item_optionWhereUniqueInput | menu_item_optionWhereUniqueInput[]
  }

  export type order_itemCreateNestedManyWithoutMenu_itemInput = {
    create?: XOR<order_itemCreateWithoutMenu_itemInput, order_itemUncheckedCreateWithoutMenu_itemInput> | order_itemCreateWithoutMenu_itemInput[] | order_itemUncheckedCreateWithoutMenu_itemInput[]
    connectOrCreate?: order_itemCreateOrConnectWithoutMenu_itemInput | order_itemCreateOrConnectWithoutMenu_itemInput[]
    createMany?: order_itemCreateManyMenu_itemInputEnvelope
    connect?: order_itemWhereUniqueInput | order_itemWhereUniqueInput[]
  }

  export type menu_item_optionUncheckedCreateNestedManyWithoutMenu_itemInput = {
    create?: XOR<menu_item_optionCreateWithoutMenu_itemInput, menu_item_optionUncheckedCreateWithoutMenu_itemInput> | menu_item_optionCreateWithoutMenu_itemInput[] | menu_item_optionUncheckedCreateWithoutMenu_itemInput[]
    connectOrCreate?: menu_item_optionCreateOrConnectWithoutMenu_itemInput | menu_item_optionCreateOrConnectWithoutMenu_itemInput[]
    createMany?: menu_item_optionCreateManyMenu_itemInputEnvelope
    connect?: menu_item_optionWhereUniqueInput | menu_item_optionWhereUniqueInput[]
  }

  export type order_itemUncheckedCreateNestedManyWithoutMenu_itemInput = {
    create?: XOR<order_itemCreateWithoutMenu_itemInput, order_itemUncheckedCreateWithoutMenu_itemInput> | order_itemCreateWithoutMenu_itemInput[] | order_itemUncheckedCreateWithoutMenu_itemInput[]
    connectOrCreate?: order_itemCreateOrConnectWithoutMenu_itemInput | order_itemCreateOrConnectWithoutMenu_itemInput[]
    createMany?: order_itemCreateManyMenu_itemInputEnvelope
    connect?: order_itemWhereUniqueInput | order_itemWhereUniqueInput[]
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type categoryUpdateOneWithoutMenu_itemNestedInput = {
    create?: XOR<categoryCreateWithoutMenu_itemInput, categoryUncheckedCreateWithoutMenu_itemInput>
    connectOrCreate?: categoryCreateOrConnectWithoutMenu_itemInput
    upsert?: categoryUpsertWithoutMenu_itemInput
    disconnect?: categoryWhereInput | boolean
    delete?: categoryWhereInput | boolean
    connect?: categoryWhereUniqueInput
    update?: XOR<XOR<categoryUpdateToOneWithWhereWithoutMenu_itemInput, categoryUpdateWithoutMenu_itemInput>, categoryUncheckedUpdateWithoutMenu_itemInput>
  }

  export type merchantUpdateOneRequiredWithoutMenu_itemNestedInput = {
    create?: XOR<merchantCreateWithoutMenu_itemInput, merchantUncheckedCreateWithoutMenu_itemInput>
    connectOrCreate?: merchantCreateOrConnectWithoutMenu_itemInput
    upsert?: merchantUpsertWithoutMenu_itemInput
    connect?: merchantWhereUniqueInput
    update?: XOR<XOR<merchantUpdateToOneWithWhereWithoutMenu_itemInput, merchantUpdateWithoutMenu_itemInput>, merchantUncheckedUpdateWithoutMenu_itemInput>
  }

  export type menu_item_optionUpdateManyWithoutMenu_itemNestedInput = {
    create?: XOR<menu_item_optionCreateWithoutMenu_itemInput, menu_item_optionUncheckedCreateWithoutMenu_itemInput> | menu_item_optionCreateWithoutMenu_itemInput[] | menu_item_optionUncheckedCreateWithoutMenu_itemInput[]
    connectOrCreate?: menu_item_optionCreateOrConnectWithoutMenu_itemInput | menu_item_optionCreateOrConnectWithoutMenu_itemInput[]
    upsert?: menu_item_optionUpsertWithWhereUniqueWithoutMenu_itemInput | menu_item_optionUpsertWithWhereUniqueWithoutMenu_itemInput[]
    createMany?: menu_item_optionCreateManyMenu_itemInputEnvelope
    set?: menu_item_optionWhereUniqueInput | menu_item_optionWhereUniqueInput[]
    disconnect?: menu_item_optionWhereUniqueInput | menu_item_optionWhereUniqueInput[]
    delete?: menu_item_optionWhereUniqueInput | menu_item_optionWhereUniqueInput[]
    connect?: menu_item_optionWhereUniqueInput | menu_item_optionWhereUniqueInput[]
    update?: menu_item_optionUpdateWithWhereUniqueWithoutMenu_itemInput | menu_item_optionUpdateWithWhereUniqueWithoutMenu_itemInput[]
    updateMany?: menu_item_optionUpdateManyWithWhereWithoutMenu_itemInput | menu_item_optionUpdateManyWithWhereWithoutMenu_itemInput[]
    deleteMany?: menu_item_optionScalarWhereInput | menu_item_optionScalarWhereInput[]
  }

  export type order_itemUpdateManyWithoutMenu_itemNestedInput = {
    create?: XOR<order_itemCreateWithoutMenu_itemInput, order_itemUncheckedCreateWithoutMenu_itemInput> | order_itemCreateWithoutMenu_itemInput[] | order_itemUncheckedCreateWithoutMenu_itemInput[]
    connectOrCreate?: order_itemCreateOrConnectWithoutMenu_itemInput | order_itemCreateOrConnectWithoutMenu_itemInput[]
    upsert?: order_itemUpsertWithWhereUniqueWithoutMenu_itemInput | order_itemUpsertWithWhereUniqueWithoutMenu_itemInput[]
    createMany?: order_itemCreateManyMenu_itemInputEnvelope
    set?: order_itemWhereUniqueInput | order_itemWhereUniqueInput[]
    disconnect?: order_itemWhereUniqueInput | order_itemWhereUniqueInput[]
    delete?: order_itemWhereUniqueInput | order_itemWhereUniqueInput[]
    connect?: order_itemWhereUniqueInput | order_itemWhereUniqueInput[]
    update?: order_itemUpdateWithWhereUniqueWithoutMenu_itemInput | order_itemUpdateWithWhereUniqueWithoutMenu_itemInput[]
    updateMany?: order_itemUpdateManyWithWhereWithoutMenu_itemInput | order_itemUpdateManyWithWhereWithoutMenu_itemInput[]
    deleteMany?: order_itemScalarWhereInput | order_itemScalarWhereInput[]
  }

  export type menu_item_optionUncheckedUpdateManyWithoutMenu_itemNestedInput = {
    create?: XOR<menu_item_optionCreateWithoutMenu_itemInput, menu_item_optionUncheckedCreateWithoutMenu_itemInput> | menu_item_optionCreateWithoutMenu_itemInput[] | menu_item_optionUncheckedCreateWithoutMenu_itemInput[]
    connectOrCreate?: menu_item_optionCreateOrConnectWithoutMenu_itemInput | menu_item_optionCreateOrConnectWithoutMenu_itemInput[]
    upsert?: menu_item_optionUpsertWithWhereUniqueWithoutMenu_itemInput | menu_item_optionUpsertWithWhereUniqueWithoutMenu_itemInput[]
    createMany?: menu_item_optionCreateManyMenu_itemInputEnvelope
    set?: menu_item_optionWhereUniqueInput | menu_item_optionWhereUniqueInput[]
    disconnect?: menu_item_optionWhereUniqueInput | menu_item_optionWhereUniqueInput[]
    delete?: menu_item_optionWhereUniqueInput | menu_item_optionWhereUniqueInput[]
    connect?: menu_item_optionWhereUniqueInput | menu_item_optionWhereUniqueInput[]
    update?: menu_item_optionUpdateWithWhereUniqueWithoutMenu_itemInput | menu_item_optionUpdateWithWhereUniqueWithoutMenu_itemInput[]
    updateMany?: menu_item_optionUpdateManyWithWhereWithoutMenu_itemInput | menu_item_optionUpdateManyWithWhereWithoutMenu_itemInput[]
    deleteMany?: menu_item_optionScalarWhereInput | menu_item_optionScalarWhereInput[]
  }

  export type order_itemUncheckedUpdateManyWithoutMenu_itemNestedInput = {
    create?: XOR<order_itemCreateWithoutMenu_itemInput, order_itemUncheckedCreateWithoutMenu_itemInput> | order_itemCreateWithoutMenu_itemInput[] | order_itemUncheckedCreateWithoutMenu_itemInput[]
    connectOrCreate?: order_itemCreateOrConnectWithoutMenu_itemInput | order_itemCreateOrConnectWithoutMenu_itemInput[]
    upsert?: order_itemUpsertWithWhereUniqueWithoutMenu_itemInput | order_itemUpsertWithWhereUniqueWithoutMenu_itemInput[]
    createMany?: order_itemCreateManyMenu_itemInputEnvelope
    set?: order_itemWhereUniqueInput | order_itemWhereUniqueInput[]
    disconnect?: order_itemWhereUniqueInput | order_itemWhereUniqueInput[]
    delete?: order_itemWhereUniqueInput | order_itemWhereUniqueInput[]
    connect?: order_itemWhereUniqueInput | order_itemWhereUniqueInput[]
    update?: order_itemUpdateWithWhereUniqueWithoutMenu_itemInput | order_itemUpdateWithWhereUniqueWithoutMenu_itemInput[]
    updateMany?: order_itemUpdateManyWithWhereWithoutMenu_itemInput | order_itemUpdateManyWithWhereWithoutMenu_itemInput[]
    deleteMany?: order_itemScalarWhereInput | order_itemScalarWhereInput[]
  }

  export type menu_item_optionCreateNestedManyWithoutOptionInput = {
    create?: XOR<menu_item_optionCreateWithoutOptionInput, menu_item_optionUncheckedCreateWithoutOptionInput> | menu_item_optionCreateWithoutOptionInput[] | menu_item_optionUncheckedCreateWithoutOptionInput[]
    connectOrCreate?: menu_item_optionCreateOrConnectWithoutOptionInput | menu_item_optionCreateOrConnectWithoutOptionInput[]
    createMany?: menu_item_optionCreateManyOptionInputEnvelope
    connect?: menu_item_optionWhereUniqueInput | menu_item_optionWhereUniqueInput[]
  }

  export type merchantCreateNestedOneWithoutOptionInput = {
    create?: XOR<merchantCreateWithoutOptionInput, merchantUncheckedCreateWithoutOptionInput>
    connectOrCreate?: merchantCreateOrConnectWithoutOptionInput
    connect?: merchantWhereUniqueInput
  }

  export type option_itemCreateNestedManyWithoutOptionInput = {
    create?: XOR<option_itemCreateWithoutOptionInput, option_itemUncheckedCreateWithoutOptionInput> | option_itemCreateWithoutOptionInput[] | option_itemUncheckedCreateWithoutOptionInput[]
    connectOrCreate?: option_itemCreateOrConnectWithoutOptionInput | option_itemCreateOrConnectWithoutOptionInput[]
    createMany?: option_itemCreateManyOptionInputEnvelope
    connect?: option_itemWhereUniqueInput | option_itemWhereUniqueInput[]
  }

  export type menu_item_optionUncheckedCreateNestedManyWithoutOptionInput = {
    create?: XOR<menu_item_optionCreateWithoutOptionInput, menu_item_optionUncheckedCreateWithoutOptionInput> | menu_item_optionCreateWithoutOptionInput[] | menu_item_optionUncheckedCreateWithoutOptionInput[]
    connectOrCreate?: menu_item_optionCreateOrConnectWithoutOptionInput | menu_item_optionCreateOrConnectWithoutOptionInput[]
    createMany?: menu_item_optionCreateManyOptionInputEnvelope
    connect?: menu_item_optionWhereUniqueInput | menu_item_optionWhereUniqueInput[]
  }

  export type option_itemUncheckedCreateNestedManyWithoutOptionInput = {
    create?: XOR<option_itemCreateWithoutOptionInput, option_itemUncheckedCreateWithoutOptionInput> | option_itemCreateWithoutOptionInput[] | option_itemUncheckedCreateWithoutOptionInput[]
    connectOrCreate?: option_itemCreateOrConnectWithoutOptionInput | option_itemCreateOrConnectWithoutOptionInput[]
    createMany?: option_itemCreateManyOptionInputEnvelope
    connect?: option_itemWhereUniqueInput | option_itemWhereUniqueInput[]
  }

  export type menu_item_optionUpdateManyWithoutOptionNestedInput = {
    create?: XOR<menu_item_optionCreateWithoutOptionInput, menu_item_optionUncheckedCreateWithoutOptionInput> | menu_item_optionCreateWithoutOptionInput[] | menu_item_optionUncheckedCreateWithoutOptionInput[]
    connectOrCreate?: menu_item_optionCreateOrConnectWithoutOptionInput | menu_item_optionCreateOrConnectWithoutOptionInput[]
    upsert?: menu_item_optionUpsertWithWhereUniqueWithoutOptionInput | menu_item_optionUpsertWithWhereUniqueWithoutOptionInput[]
    createMany?: menu_item_optionCreateManyOptionInputEnvelope
    set?: menu_item_optionWhereUniqueInput | menu_item_optionWhereUniqueInput[]
    disconnect?: menu_item_optionWhereUniqueInput | menu_item_optionWhereUniqueInput[]
    delete?: menu_item_optionWhereUniqueInput | menu_item_optionWhereUniqueInput[]
    connect?: menu_item_optionWhereUniqueInput | menu_item_optionWhereUniqueInput[]
    update?: menu_item_optionUpdateWithWhereUniqueWithoutOptionInput | menu_item_optionUpdateWithWhereUniqueWithoutOptionInput[]
    updateMany?: menu_item_optionUpdateManyWithWhereWithoutOptionInput | menu_item_optionUpdateManyWithWhereWithoutOptionInput[]
    deleteMany?: menu_item_optionScalarWhereInput | menu_item_optionScalarWhereInput[]
  }

  export type merchantUpdateOneRequiredWithoutOptionNestedInput = {
    create?: XOR<merchantCreateWithoutOptionInput, merchantUncheckedCreateWithoutOptionInput>
    connectOrCreate?: merchantCreateOrConnectWithoutOptionInput
    upsert?: merchantUpsertWithoutOptionInput
    connect?: merchantWhereUniqueInput
    update?: XOR<XOR<merchantUpdateToOneWithWhereWithoutOptionInput, merchantUpdateWithoutOptionInput>, merchantUncheckedUpdateWithoutOptionInput>
  }

  export type option_itemUpdateManyWithoutOptionNestedInput = {
    create?: XOR<option_itemCreateWithoutOptionInput, option_itemUncheckedCreateWithoutOptionInput> | option_itemCreateWithoutOptionInput[] | option_itemUncheckedCreateWithoutOptionInput[]
    connectOrCreate?: option_itemCreateOrConnectWithoutOptionInput | option_itemCreateOrConnectWithoutOptionInput[]
    upsert?: option_itemUpsertWithWhereUniqueWithoutOptionInput | option_itemUpsertWithWhereUniqueWithoutOptionInput[]
    createMany?: option_itemCreateManyOptionInputEnvelope
    set?: option_itemWhereUniqueInput | option_itemWhereUniqueInput[]
    disconnect?: option_itemWhereUniqueInput | option_itemWhereUniqueInput[]
    delete?: option_itemWhereUniqueInput | option_itemWhereUniqueInput[]
    connect?: option_itemWhereUniqueInput | option_itemWhereUniqueInput[]
    update?: option_itemUpdateWithWhereUniqueWithoutOptionInput | option_itemUpdateWithWhereUniqueWithoutOptionInput[]
    updateMany?: option_itemUpdateManyWithWhereWithoutOptionInput | option_itemUpdateManyWithWhereWithoutOptionInput[]
    deleteMany?: option_itemScalarWhereInput | option_itemScalarWhereInput[]
  }

  export type menu_item_optionUncheckedUpdateManyWithoutOptionNestedInput = {
    create?: XOR<menu_item_optionCreateWithoutOptionInput, menu_item_optionUncheckedCreateWithoutOptionInput> | menu_item_optionCreateWithoutOptionInput[] | menu_item_optionUncheckedCreateWithoutOptionInput[]
    connectOrCreate?: menu_item_optionCreateOrConnectWithoutOptionInput | menu_item_optionCreateOrConnectWithoutOptionInput[]
    upsert?: menu_item_optionUpsertWithWhereUniqueWithoutOptionInput | menu_item_optionUpsertWithWhereUniqueWithoutOptionInput[]
    createMany?: menu_item_optionCreateManyOptionInputEnvelope
    set?: menu_item_optionWhereUniqueInput | menu_item_optionWhereUniqueInput[]
    disconnect?: menu_item_optionWhereUniqueInput | menu_item_optionWhereUniqueInput[]
    delete?: menu_item_optionWhereUniqueInput | menu_item_optionWhereUniqueInput[]
    connect?: menu_item_optionWhereUniqueInput | menu_item_optionWhereUniqueInput[]
    update?: menu_item_optionUpdateWithWhereUniqueWithoutOptionInput | menu_item_optionUpdateWithWhereUniqueWithoutOptionInput[]
    updateMany?: menu_item_optionUpdateManyWithWhereWithoutOptionInput | menu_item_optionUpdateManyWithWhereWithoutOptionInput[]
    deleteMany?: menu_item_optionScalarWhereInput | menu_item_optionScalarWhereInput[]
  }

  export type option_itemUncheckedUpdateManyWithoutOptionNestedInput = {
    create?: XOR<option_itemCreateWithoutOptionInput, option_itemUncheckedCreateWithoutOptionInput> | option_itemCreateWithoutOptionInput[] | option_itemUncheckedCreateWithoutOptionInput[]
    connectOrCreate?: option_itemCreateOrConnectWithoutOptionInput | option_itemCreateOrConnectWithoutOptionInput[]
    upsert?: option_itemUpsertWithWhereUniqueWithoutOptionInput | option_itemUpsertWithWhereUniqueWithoutOptionInput[]
    createMany?: option_itemCreateManyOptionInputEnvelope
    set?: option_itemWhereUniqueInput | option_itemWhereUniqueInput[]
    disconnect?: option_itemWhereUniqueInput | option_itemWhereUniqueInput[]
    delete?: option_itemWhereUniqueInput | option_itemWhereUniqueInput[]
    connect?: option_itemWhereUniqueInput | option_itemWhereUniqueInput[]
    update?: option_itemUpdateWithWhereUniqueWithoutOptionInput | option_itemUpdateWithWhereUniqueWithoutOptionInput[]
    updateMany?: option_itemUpdateManyWithWhereWithoutOptionInput | option_itemUpdateManyWithWhereWithoutOptionInput[]
    deleteMany?: option_itemScalarWhereInput | option_itemScalarWhereInput[]
  }

  export type optionCreateNestedOneWithoutOption_itemInput = {
    create?: XOR<optionCreateWithoutOption_itemInput, optionUncheckedCreateWithoutOption_itemInput>
    connectOrCreate?: optionCreateOrConnectWithoutOption_itemInput
    connect?: optionWhereUniqueInput
  }

  export type order_item_optionCreateNestedManyWithoutOption_itemInput = {
    create?: XOR<order_item_optionCreateWithoutOption_itemInput, order_item_optionUncheckedCreateWithoutOption_itemInput> | order_item_optionCreateWithoutOption_itemInput[] | order_item_optionUncheckedCreateWithoutOption_itemInput[]
    connectOrCreate?: order_item_optionCreateOrConnectWithoutOption_itemInput | order_item_optionCreateOrConnectWithoutOption_itemInput[]
    createMany?: order_item_optionCreateManyOption_itemInputEnvelope
    connect?: order_item_optionWhereUniqueInput | order_item_optionWhereUniqueInput[]
  }

  export type order_item_optionUncheckedCreateNestedManyWithoutOption_itemInput = {
    create?: XOR<order_item_optionCreateWithoutOption_itemInput, order_item_optionUncheckedCreateWithoutOption_itemInput> | order_item_optionCreateWithoutOption_itemInput[] | order_item_optionUncheckedCreateWithoutOption_itemInput[]
    connectOrCreate?: order_item_optionCreateOrConnectWithoutOption_itemInput | order_item_optionCreateOrConnectWithoutOption_itemInput[]
    createMany?: order_item_optionCreateManyOption_itemInputEnvelope
    connect?: order_item_optionWhereUniqueInput | order_item_optionWhereUniqueInput[]
  }

  export type optionUpdateOneRequiredWithoutOption_itemNestedInput = {
    create?: XOR<optionCreateWithoutOption_itemInput, optionUncheckedCreateWithoutOption_itemInput>
    connectOrCreate?: optionCreateOrConnectWithoutOption_itemInput
    upsert?: optionUpsertWithoutOption_itemInput
    connect?: optionWhereUniqueInput
    update?: XOR<XOR<optionUpdateToOneWithWhereWithoutOption_itemInput, optionUpdateWithoutOption_itemInput>, optionUncheckedUpdateWithoutOption_itemInput>
  }

  export type order_item_optionUpdateManyWithoutOption_itemNestedInput = {
    create?: XOR<order_item_optionCreateWithoutOption_itemInput, order_item_optionUncheckedCreateWithoutOption_itemInput> | order_item_optionCreateWithoutOption_itemInput[] | order_item_optionUncheckedCreateWithoutOption_itemInput[]
    connectOrCreate?: order_item_optionCreateOrConnectWithoutOption_itemInput | order_item_optionCreateOrConnectWithoutOption_itemInput[]
    upsert?: order_item_optionUpsertWithWhereUniqueWithoutOption_itemInput | order_item_optionUpsertWithWhereUniqueWithoutOption_itemInput[]
    createMany?: order_item_optionCreateManyOption_itemInputEnvelope
    set?: order_item_optionWhereUniqueInput | order_item_optionWhereUniqueInput[]
    disconnect?: order_item_optionWhereUniqueInput | order_item_optionWhereUniqueInput[]
    delete?: order_item_optionWhereUniqueInput | order_item_optionWhereUniqueInput[]
    connect?: order_item_optionWhereUniqueInput | order_item_optionWhereUniqueInput[]
    update?: order_item_optionUpdateWithWhereUniqueWithoutOption_itemInput | order_item_optionUpdateWithWhereUniqueWithoutOption_itemInput[]
    updateMany?: order_item_optionUpdateManyWithWhereWithoutOption_itemInput | order_item_optionUpdateManyWithWhereWithoutOption_itemInput[]
    deleteMany?: order_item_optionScalarWhereInput | order_item_optionScalarWhereInput[]
  }

  export type order_item_optionUncheckedUpdateManyWithoutOption_itemNestedInput = {
    create?: XOR<order_item_optionCreateWithoutOption_itemInput, order_item_optionUncheckedCreateWithoutOption_itemInput> | order_item_optionCreateWithoutOption_itemInput[] | order_item_optionUncheckedCreateWithoutOption_itemInput[]
    connectOrCreate?: order_item_optionCreateOrConnectWithoutOption_itemInput | order_item_optionCreateOrConnectWithoutOption_itemInput[]
    upsert?: order_item_optionUpsertWithWhereUniqueWithoutOption_itemInput | order_item_optionUpsertWithWhereUniqueWithoutOption_itemInput[]
    createMany?: order_item_optionCreateManyOption_itemInputEnvelope
    set?: order_item_optionWhereUniqueInput | order_item_optionWhereUniqueInput[]
    disconnect?: order_item_optionWhereUniqueInput | order_item_optionWhereUniqueInput[]
    delete?: order_item_optionWhereUniqueInput | order_item_optionWhereUniqueInput[]
    connect?: order_item_optionWhereUniqueInput | order_item_optionWhereUniqueInput[]
    update?: order_item_optionUpdateWithWhereUniqueWithoutOption_itemInput | order_item_optionUpdateWithWhereUniqueWithoutOption_itemInput[]
    updateMany?: order_item_optionUpdateManyWithWhereWithoutOption_itemInput | order_item_optionUpdateManyWithWhereWithoutOption_itemInput[]
    deleteMany?: order_item_optionScalarWhereInput | order_item_optionScalarWhereInput[]
  }

  export type menu_itemCreateNestedOneWithoutMenu_item_optionInput = {
    create?: XOR<menu_itemCreateWithoutMenu_item_optionInput, menu_itemUncheckedCreateWithoutMenu_item_optionInput>
    connectOrCreate?: menu_itemCreateOrConnectWithoutMenu_item_optionInput
    connect?: menu_itemWhereUniqueInput
  }

  export type optionCreateNestedOneWithoutMenu_item_optionInput = {
    create?: XOR<optionCreateWithoutMenu_item_optionInput, optionUncheckedCreateWithoutMenu_item_optionInput>
    connectOrCreate?: optionCreateOrConnectWithoutMenu_item_optionInput
    connect?: optionWhereUniqueInput
  }

  export type menu_itemUpdateOneRequiredWithoutMenu_item_optionNestedInput = {
    create?: XOR<menu_itemCreateWithoutMenu_item_optionInput, menu_itemUncheckedCreateWithoutMenu_item_optionInput>
    connectOrCreate?: menu_itemCreateOrConnectWithoutMenu_item_optionInput
    upsert?: menu_itemUpsertWithoutMenu_item_optionInput
    connect?: menu_itemWhereUniqueInput
    update?: XOR<XOR<menu_itemUpdateToOneWithWhereWithoutMenu_item_optionInput, menu_itemUpdateWithoutMenu_item_optionInput>, menu_itemUncheckedUpdateWithoutMenu_item_optionInput>
  }

  export type optionUpdateOneRequiredWithoutMenu_item_optionNestedInput = {
    create?: XOR<optionCreateWithoutMenu_item_optionInput, optionUncheckedCreateWithoutMenu_item_optionInput>
    connectOrCreate?: optionCreateOrConnectWithoutMenu_item_optionInput
    upsert?: optionUpsertWithoutMenu_item_optionInput
    connect?: optionWhereUniqueInput
    update?: XOR<XOR<optionUpdateToOneWithWhereWithoutMenu_item_optionInput, optionUpdateWithoutMenu_item_optionInput>, optionUncheckedUpdateWithoutMenu_item_optionInput>
  }

  export type merchantCreateNestedOneWithoutOrdersInput = {
    create?: XOR<merchantCreateWithoutOrdersInput, merchantUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: merchantCreateOrConnectWithoutOrdersInput
    connect?: merchantWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutOrdersInput = {
    create?: XOR<usersCreateWithoutOrdersInput, usersUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: usersCreateOrConnectWithoutOrdersInput
    connect?: usersWhereUniqueInput
  }

  export type order_itemCreateNestedManyWithoutOrderInput = {
    create?: XOR<order_itemCreateWithoutOrderInput, order_itemUncheckedCreateWithoutOrderInput> | order_itemCreateWithoutOrderInput[] | order_itemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: order_itemCreateOrConnectWithoutOrderInput | order_itemCreateOrConnectWithoutOrderInput[]
    createMany?: order_itemCreateManyOrderInputEnvelope
    connect?: order_itemWhereUniqueInput | order_itemWhereUniqueInput[]
  }

  export type payment_transactionCreateNestedManyWithoutOrderInput = {
    create?: XOR<payment_transactionCreateWithoutOrderInput, payment_transactionUncheckedCreateWithoutOrderInput> | payment_transactionCreateWithoutOrderInput[] | payment_transactionUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: payment_transactionCreateOrConnectWithoutOrderInput | payment_transactionCreateOrConnectWithoutOrderInput[]
    createMany?: payment_transactionCreateManyOrderInputEnvelope
    connect?: payment_transactionWhereUniqueInput | payment_transactionWhereUniqueInput[]
  }

  export type order_itemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<order_itemCreateWithoutOrderInput, order_itemUncheckedCreateWithoutOrderInput> | order_itemCreateWithoutOrderInput[] | order_itemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: order_itemCreateOrConnectWithoutOrderInput | order_itemCreateOrConnectWithoutOrderInput[]
    createMany?: order_itemCreateManyOrderInputEnvelope
    connect?: order_itemWhereUniqueInput | order_itemWhereUniqueInput[]
  }

  export type payment_transactionUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<payment_transactionCreateWithoutOrderInput, payment_transactionUncheckedCreateWithoutOrderInput> | payment_transactionCreateWithoutOrderInput[] | payment_transactionUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: payment_transactionCreateOrConnectWithoutOrderInput | payment_transactionCreateOrConnectWithoutOrderInput[]
    createMany?: payment_transactionCreateManyOrderInputEnvelope
    connect?: payment_transactionWhereUniqueInput | payment_transactionWhereUniqueInput[]
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type merchantUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<merchantCreateWithoutOrdersInput, merchantUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: merchantCreateOrConnectWithoutOrdersInput
    upsert?: merchantUpsertWithoutOrdersInput
    connect?: merchantWhereUniqueInput
    update?: XOR<XOR<merchantUpdateToOneWithWhereWithoutOrdersInput, merchantUpdateWithoutOrdersInput>, merchantUncheckedUpdateWithoutOrdersInput>
  }

  export type usersUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<usersCreateWithoutOrdersInput, usersUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: usersCreateOrConnectWithoutOrdersInput
    upsert?: usersUpsertWithoutOrdersInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutOrdersInput, usersUpdateWithoutOrdersInput>, usersUncheckedUpdateWithoutOrdersInput>
  }

  export type order_itemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<order_itemCreateWithoutOrderInput, order_itemUncheckedCreateWithoutOrderInput> | order_itemCreateWithoutOrderInput[] | order_itemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: order_itemCreateOrConnectWithoutOrderInput | order_itemCreateOrConnectWithoutOrderInput[]
    upsert?: order_itemUpsertWithWhereUniqueWithoutOrderInput | order_itemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: order_itemCreateManyOrderInputEnvelope
    set?: order_itemWhereUniqueInput | order_itemWhereUniqueInput[]
    disconnect?: order_itemWhereUniqueInput | order_itemWhereUniqueInput[]
    delete?: order_itemWhereUniqueInput | order_itemWhereUniqueInput[]
    connect?: order_itemWhereUniqueInput | order_itemWhereUniqueInput[]
    update?: order_itemUpdateWithWhereUniqueWithoutOrderInput | order_itemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: order_itemUpdateManyWithWhereWithoutOrderInput | order_itemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: order_itemScalarWhereInput | order_itemScalarWhereInput[]
  }

  export type payment_transactionUpdateManyWithoutOrderNestedInput = {
    create?: XOR<payment_transactionCreateWithoutOrderInput, payment_transactionUncheckedCreateWithoutOrderInput> | payment_transactionCreateWithoutOrderInput[] | payment_transactionUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: payment_transactionCreateOrConnectWithoutOrderInput | payment_transactionCreateOrConnectWithoutOrderInput[]
    upsert?: payment_transactionUpsertWithWhereUniqueWithoutOrderInput | payment_transactionUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: payment_transactionCreateManyOrderInputEnvelope
    set?: payment_transactionWhereUniqueInput | payment_transactionWhereUniqueInput[]
    disconnect?: payment_transactionWhereUniqueInput | payment_transactionWhereUniqueInput[]
    delete?: payment_transactionWhereUniqueInput | payment_transactionWhereUniqueInput[]
    connect?: payment_transactionWhereUniqueInput | payment_transactionWhereUniqueInput[]
    update?: payment_transactionUpdateWithWhereUniqueWithoutOrderInput | payment_transactionUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: payment_transactionUpdateManyWithWhereWithoutOrderInput | payment_transactionUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: payment_transactionScalarWhereInput | payment_transactionScalarWhereInput[]
  }

  export type order_itemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<order_itemCreateWithoutOrderInput, order_itemUncheckedCreateWithoutOrderInput> | order_itemCreateWithoutOrderInput[] | order_itemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: order_itemCreateOrConnectWithoutOrderInput | order_itemCreateOrConnectWithoutOrderInput[]
    upsert?: order_itemUpsertWithWhereUniqueWithoutOrderInput | order_itemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: order_itemCreateManyOrderInputEnvelope
    set?: order_itemWhereUniqueInput | order_itemWhereUniqueInput[]
    disconnect?: order_itemWhereUniqueInput | order_itemWhereUniqueInput[]
    delete?: order_itemWhereUniqueInput | order_itemWhereUniqueInput[]
    connect?: order_itemWhereUniqueInput | order_itemWhereUniqueInput[]
    update?: order_itemUpdateWithWhereUniqueWithoutOrderInput | order_itemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: order_itemUpdateManyWithWhereWithoutOrderInput | order_itemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: order_itemScalarWhereInput | order_itemScalarWhereInput[]
  }

  export type payment_transactionUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<payment_transactionCreateWithoutOrderInput, payment_transactionUncheckedCreateWithoutOrderInput> | payment_transactionCreateWithoutOrderInput[] | payment_transactionUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: payment_transactionCreateOrConnectWithoutOrderInput | payment_transactionCreateOrConnectWithoutOrderInput[]
    upsert?: payment_transactionUpsertWithWhereUniqueWithoutOrderInput | payment_transactionUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: payment_transactionCreateManyOrderInputEnvelope
    set?: payment_transactionWhereUniqueInput | payment_transactionWhereUniqueInput[]
    disconnect?: payment_transactionWhereUniqueInput | payment_transactionWhereUniqueInput[]
    delete?: payment_transactionWhereUniqueInput | payment_transactionWhereUniqueInput[]
    connect?: payment_transactionWhereUniqueInput | payment_transactionWhereUniqueInput[]
    update?: payment_transactionUpdateWithWhereUniqueWithoutOrderInput | payment_transactionUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: payment_transactionUpdateManyWithWhereWithoutOrderInput | payment_transactionUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: payment_transactionScalarWhereInput | payment_transactionScalarWhereInput[]
  }

  export type menu_itemCreateNestedOneWithoutOrder_itemsInput = {
    create?: XOR<menu_itemCreateWithoutOrder_itemsInput, menu_itemUncheckedCreateWithoutOrder_itemsInput>
    connectOrCreate?: menu_itemCreateOrConnectWithoutOrder_itemsInput
    connect?: menu_itemWhereUniqueInput
  }

  export type orderCreateNestedOneWithoutItemsInput = {
    create?: XOR<orderCreateWithoutItemsInput, orderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: orderCreateOrConnectWithoutItemsInput
    connect?: orderWhereUniqueInput
  }

  export type order_item_optionCreateNestedManyWithoutOrder_itemInput = {
    create?: XOR<order_item_optionCreateWithoutOrder_itemInput, order_item_optionUncheckedCreateWithoutOrder_itemInput> | order_item_optionCreateWithoutOrder_itemInput[] | order_item_optionUncheckedCreateWithoutOrder_itemInput[]
    connectOrCreate?: order_item_optionCreateOrConnectWithoutOrder_itemInput | order_item_optionCreateOrConnectWithoutOrder_itemInput[]
    createMany?: order_item_optionCreateManyOrder_itemInputEnvelope
    connect?: order_item_optionWhereUniqueInput | order_item_optionWhereUniqueInput[]
  }

  export type order_item_optionUncheckedCreateNestedManyWithoutOrder_itemInput = {
    create?: XOR<order_item_optionCreateWithoutOrder_itemInput, order_item_optionUncheckedCreateWithoutOrder_itemInput> | order_item_optionCreateWithoutOrder_itemInput[] | order_item_optionUncheckedCreateWithoutOrder_itemInput[]
    connectOrCreate?: order_item_optionCreateOrConnectWithoutOrder_itemInput | order_item_optionCreateOrConnectWithoutOrder_itemInput[]
    createMany?: order_item_optionCreateManyOrder_itemInputEnvelope
    connect?: order_item_optionWhereUniqueInput | order_item_optionWhereUniqueInput[]
  }

  export type menu_itemUpdateOneRequiredWithoutOrder_itemsNestedInput = {
    create?: XOR<menu_itemCreateWithoutOrder_itemsInput, menu_itemUncheckedCreateWithoutOrder_itemsInput>
    connectOrCreate?: menu_itemCreateOrConnectWithoutOrder_itemsInput
    upsert?: menu_itemUpsertWithoutOrder_itemsInput
    connect?: menu_itemWhereUniqueInput
    update?: XOR<XOR<menu_itemUpdateToOneWithWhereWithoutOrder_itemsInput, menu_itemUpdateWithoutOrder_itemsInput>, menu_itemUncheckedUpdateWithoutOrder_itemsInput>
  }

  export type orderUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<orderCreateWithoutItemsInput, orderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: orderCreateOrConnectWithoutItemsInput
    upsert?: orderUpsertWithoutItemsInput
    connect?: orderWhereUniqueInput
    update?: XOR<XOR<orderUpdateToOneWithWhereWithoutItemsInput, orderUpdateWithoutItemsInput>, orderUncheckedUpdateWithoutItemsInput>
  }

  export type order_item_optionUpdateManyWithoutOrder_itemNestedInput = {
    create?: XOR<order_item_optionCreateWithoutOrder_itemInput, order_item_optionUncheckedCreateWithoutOrder_itemInput> | order_item_optionCreateWithoutOrder_itemInput[] | order_item_optionUncheckedCreateWithoutOrder_itemInput[]
    connectOrCreate?: order_item_optionCreateOrConnectWithoutOrder_itemInput | order_item_optionCreateOrConnectWithoutOrder_itemInput[]
    upsert?: order_item_optionUpsertWithWhereUniqueWithoutOrder_itemInput | order_item_optionUpsertWithWhereUniqueWithoutOrder_itemInput[]
    createMany?: order_item_optionCreateManyOrder_itemInputEnvelope
    set?: order_item_optionWhereUniqueInput | order_item_optionWhereUniqueInput[]
    disconnect?: order_item_optionWhereUniqueInput | order_item_optionWhereUniqueInput[]
    delete?: order_item_optionWhereUniqueInput | order_item_optionWhereUniqueInput[]
    connect?: order_item_optionWhereUniqueInput | order_item_optionWhereUniqueInput[]
    update?: order_item_optionUpdateWithWhereUniqueWithoutOrder_itemInput | order_item_optionUpdateWithWhereUniqueWithoutOrder_itemInput[]
    updateMany?: order_item_optionUpdateManyWithWhereWithoutOrder_itemInput | order_item_optionUpdateManyWithWhereWithoutOrder_itemInput[]
    deleteMany?: order_item_optionScalarWhereInput | order_item_optionScalarWhereInput[]
  }

  export type order_item_optionUncheckedUpdateManyWithoutOrder_itemNestedInput = {
    create?: XOR<order_item_optionCreateWithoutOrder_itemInput, order_item_optionUncheckedCreateWithoutOrder_itemInput> | order_item_optionCreateWithoutOrder_itemInput[] | order_item_optionUncheckedCreateWithoutOrder_itemInput[]
    connectOrCreate?: order_item_optionCreateOrConnectWithoutOrder_itemInput | order_item_optionCreateOrConnectWithoutOrder_itemInput[]
    upsert?: order_item_optionUpsertWithWhereUniqueWithoutOrder_itemInput | order_item_optionUpsertWithWhereUniqueWithoutOrder_itemInput[]
    createMany?: order_item_optionCreateManyOrder_itemInputEnvelope
    set?: order_item_optionWhereUniqueInput | order_item_optionWhereUniqueInput[]
    disconnect?: order_item_optionWhereUniqueInput | order_item_optionWhereUniqueInput[]
    delete?: order_item_optionWhereUniqueInput | order_item_optionWhereUniqueInput[]
    connect?: order_item_optionWhereUniqueInput | order_item_optionWhereUniqueInput[]
    update?: order_item_optionUpdateWithWhereUniqueWithoutOrder_itemInput | order_item_optionUpdateWithWhereUniqueWithoutOrder_itemInput[]
    updateMany?: order_item_optionUpdateManyWithWhereWithoutOrder_itemInput | order_item_optionUpdateManyWithWhereWithoutOrder_itemInput[]
    deleteMany?: order_item_optionScalarWhereInput | order_item_optionScalarWhereInput[]
  }

  export type option_itemCreateNestedOneWithoutOrder_item_optionsInput = {
    create?: XOR<option_itemCreateWithoutOrder_item_optionsInput, option_itemUncheckedCreateWithoutOrder_item_optionsInput>
    connectOrCreate?: option_itemCreateOrConnectWithoutOrder_item_optionsInput
    connect?: option_itemWhereUniqueInput
  }

  export type order_itemCreateNestedOneWithoutOptionsInput = {
    create?: XOR<order_itemCreateWithoutOptionsInput, order_itemUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: order_itemCreateOrConnectWithoutOptionsInput
    connect?: order_itemWhereUniqueInput
  }

  export type option_itemUpdateOneRequiredWithoutOrder_item_optionsNestedInput = {
    create?: XOR<option_itemCreateWithoutOrder_item_optionsInput, option_itemUncheckedCreateWithoutOrder_item_optionsInput>
    connectOrCreate?: option_itemCreateOrConnectWithoutOrder_item_optionsInput
    upsert?: option_itemUpsertWithoutOrder_item_optionsInput
    connect?: option_itemWhereUniqueInput
    update?: XOR<XOR<option_itemUpdateToOneWithWhereWithoutOrder_item_optionsInput, option_itemUpdateWithoutOrder_item_optionsInput>, option_itemUncheckedUpdateWithoutOrder_item_optionsInput>
  }

  export type order_itemUpdateOneRequiredWithoutOptionsNestedInput = {
    create?: XOR<order_itemCreateWithoutOptionsInput, order_itemUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: order_itemCreateOrConnectWithoutOptionsInput
    upsert?: order_itemUpsertWithoutOptionsInput
    connect?: order_itemWhereUniqueInput
    update?: XOR<XOR<order_itemUpdateToOneWithWhereWithoutOptionsInput, order_itemUpdateWithoutOptionsInput>, order_itemUncheckedUpdateWithoutOptionsInput>
  }

  export type merchantCreateNestedOneWithoutPayment_transactionsInput = {
    create?: XOR<merchantCreateWithoutPayment_transactionsInput, merchantUncheckedCreateWithoutPayment_transactionsInput>
    connectOrCreate?: merchantCreateOrConnectWithoutPayment_transactionsInput
    connect?: merchantWhereUniqueInput
  }

  export type orderCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<orderCreateWithoutPaymentsInput, orderUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: orderCreateOrConnectWithoutPaymentsInput
    connect?: orderWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutPayment_transactionsInput = {
    create?: XOR<usersCreateWithoutPayment_transactionsInput, usersUncheckedCreateWithoutPayment_transactionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutPayment_transactionsInput
    connect?: usersWhereUniqueInput
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type merchantUpdateOneRequiredWithoutPayment_transactionsNestedInput = {
    create?: XOR<merchantCreateWithoutPayment_transactionsInput, merchantUncheckedCreateWithoutPayment_transactionsInput>
    connectOrCreate?: merchantCreateOrConnectWithoutPayment_transactionsInput
    upsert?: merchantUpsertWithoutPayment_transactionsInput
    connect?: merchantWhereUniqueInput
    update?: XOR<XOR<merchantUpdateToOneWithWhereWithoutPayment_transactionsInput, merchantUpdateWithoutPayment_transactionsInput>, merchantUncheckedUpdateWithoutPayment_transactionsInput>
  }

  export type orderUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<orderCreateWithoutPaymentsInput, orderUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: orderCreateOrConnectWithoutPaymentsInput
    upsert?: orderUpsertWithoutPaymentsInput
    disconnect?: orderWhereInput | boolean
    delete?: orderWhereInput | boolean
    connect?: orderWhereUniqueInput
    update?: XOR<XOR<orderUpdateToOneWithWhereWithoutPaymentsInput, orderUpdateWithoutPaymentsInput>, orderUncheckedUpdateWithoutPaymentsInput>
  }

  export type usersUpdateOneRequiredWithoutPayment_transactionsNestedInput = {
    create?: XOR<usersCreateWithoutPayment_transactionsInput, usersUncheckedCreateWithoutPayment_transactionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutPayment_transactionsInput
    upsert?: usersUpsertWithoutPayment_transactionsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutPayment_transactionsInput, usersUpdateWithoutPayment_transactionsInput>, usersUncheckedUpdateWithoutPayment_transactionsInput>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type merchantCreateWithoutUserInput = {
    id?: string
    merchant_name: string
    location?: NullableJsonNullValueInput | InputJsonValue
    phone?: string | null
    email?: string | null
    profile_image?: NullableJsonNullValueInput | InputJsonValue
    cover_image?: NullableJsonNullValueInput | InputJsonValue
    time_open?: NullableJsonNullValueInput | InputJsonValue
    cuisine?: string | null
    categories?: categoryCreateNestedManyWithoutMerchantInput
    menu_item?: menu_itemCreateNestedManyWithoutMerchantInput
    option?: optionCreateNestedManyWithoutMerchantInput
    orders?: orderCreateNestedManyWithoutMerchantInput
    payment_transactions?: payment_transactionCreateNestedManyWithoutMerchantInput
  }

  export type merchantUncheckedCreateWithoutUserInput = {
    id?: string
    merchant_name: string
    location?: NullableJsonNullValueInput | InputJsonValue
    phone?: string | null
    email?: string | null
    profile_image?: NullableJsonNullValueInput | InputJsonValue
    cover_image?: NullableJsonNullValueInput | InputJsonValue
    time_open?: NullableJsonNullValueInput | InputJsonValue
    cuisine?: string | null
    categories?: categoryUncheckedCreateNestedManyWithoutMerchantInput
    menu_item?: menu_itemUncheckedCreateNestedManyWithoutMerchantInput
    option?: optionUncheckedCreateNestedManyWithoutMerchantInput
    orders?: orderUncheckedCreateNestedManyWithoutMerchantInput
    payment_transactions?: payment_transactionUncheckedCreateNestedManyWithoutMerchantInput
  }

  export type merchantCreateOrConnectWithoutUserInput = {
    where: merchantWhereUniqueInput
    create: XOR<merchantCreateWithoutUserInput, merchantUncheckedCreateWithoutUserInput>
  }

  export type merchantCreateManyUserInputEnvelope = {
    data: merchantCreateManyUserInput | merchantCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type orderCreateWithoutUserInput = {
    id?: string
    full_name: string
    phone?: string | null
    delivery_address?: string | null
    delivery_fee?: bigint | number | null
    note?: string | null
    total_amount: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    status?: string | null
    status_payment?: string | null
    payment_method?: string | null
    merchant: merchantCreateNestedOneWithoutOrdersInput
    items?: order_itemCreateNestedManyWithoutOrderInput
    payments?: payment_transactionCreateNestedManyWithoutOrderInput
  }

  export type orderUncheckedCreateWithoutUserInput = {
    id?: string
    merchant_id: string
    full_name: string
    phone?: string | null
    delivery_address?: string | null
    delivery_fee?: bigint | number | null
    note?: string | null
    total_amount: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    status?: string | null
    status_payment?: string | null
    payment_method?: string | null
    items?: order_itemUncheckedCreateNestedManyWithoutOrderInput
    payments?: payment_transactionUncheckedCreateNestedManyWithoutOrderInput
  }

  export type orderCreateOrConnectWithoutUserInput = {
    where: orderWhereUniqueInput
    create: XOR<orderCreateWithoutUserInput, orderUncheckedCreateWithoutUserInput>
  }

  export type orderCreateManyUserInputEnvelope = {
    data: orderCreateManyUserInput | orderCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type payment_transactionCreateWithoutUserInput = {
    id?: string
    amount: bigint | number
    currency?: string
    txn_ref: string
    transaction_no?: string | null
    payment_method: string
    status?: $Enums.PaymentStatus
    response_code?: string | null
    bank_code?: string | null
    pay_date?: string | null
    tmn_code?: string | null
    raw_payload?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    merchant: merchantCreateNestedOneWithoutPayment_transactionsInput
    order?: orderCreateNestedOneWithoutPaymentsInput
  }

  export type payment_transactionUncheckedCreateWithoutUserInput = {
    id?: string
    merchant_id: string
    order_id?: string | null
    amount: bigint | number
    currency?: string
    txn_ref: string
    transaction_no?: string | null
    payment_method: string
    status?: $Enums.PaymentStatus
    response_code?: string | null
    bank_code?: string | null
    pay_date?: string | null
    tmn_code?: string | null
    raw_payload?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type payment_transactionCreateOrConnectWithoutUserInput = {
    where: payment_transactionWhereUniqueInput
    create: XOR<payment_transactionCreateWithoutUserInput, payment_transactionUncheckedCreateWithoutUserInput>
  }

  export type payment_transactionCreateManyUserInputEnvelope = {
    data: payment_transactionCreateManyUserInput | payment_transactionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type merchantUpsertWithWhereUniqueWithoutUserInput = {
    where: merchantWhereUniqueInput
    update: XOR<merchantUpdateWithoutUserInput, merchantUncheckedUpdateWithoutUserInput>
    create: XOR<merchantCreateWithoutUserInput, merchantUncheckedCreateWithoutUserInput>
  }

  export type merchantUpdateWithWhereUniqueWithoutUserInput = {
    where: merchantWhereUniqueInput
    data: XOR<merchantUpdateWithoutUserInput, merchantUncheckedUpdateWithoutUserInput>
  }

  export type merchantUpdateManyWithWhereWithoutUserInput = {
    where: merchantScalarWhereInput
    data: XOR<merchantUpdateManyMutationInput, merchantUncheckedUpdateManyWithoutUserInput>
  }

  export type merchantScalarWhereInput = {
    AND?: merchantScalarWhereInput | merchantScalarWhereInput[]
    OR?: merchantScalarWhereInput[]
    NOT?: merchantScalarWhereInput | merchantScalarWhereInput[]
    id?: UuidFilter<"merchant"> | string
    user_id?: UuidFilter<"merchant"> | string
    merchant_name?: StringFilter<"merchant"> | string
    location?: JsonNullableFilter<"merchant">
    phone?: StringNullableFilter<"merchant"> | string | null
    email?: StringNullableFilter<"merchant"> | string | null
    profile_image?: JsonNullableFilter<"merchant">
    cover_image?: JsonNullableFilter<"merchant">
    time_open?: JsonNullableFilter<"merchant">
    cuisine?: StringNullableFilter<"merchant"> | string | null
  }

  export type orderUpsertWithWhereUniqueWithoutUserInput = {
    where: orderWhereUniqueInput
    update: XOR<orderUpdateWithoutUserInput, orderUncheckedUpdateWithoutUserInput>
    create: XOR<orderCreateWithoutUserInput, orderUncheckedCreateWithoutUserInput>
  }

  export type orderUpdateWithWhereUniqueWithoutUserInput = {
    where: orderWhereUniqueInput
    data: XOR<orderUpdateWithoutUserInput, orderUncheckedUpdateWithoutUserInput>
  }

  export type orderUpdateManyWithWhereWithoutUserInput = {
    where: orderScalarWhereInput
    data: XOR<orderUpdateManyMutationInput, orderUncheckedUpdateManyWithoutUserInput>
  }

  export type orderScalarWhereInput = {
    AND?: orderScalarWhereInput | orderScalarWhereInput[]
    OR?: orderScalarWhereInput[]
    NOT?: orderScalarWhereInput | orderScalarWhereInput[]
    id?: UuidFilter<"order"> | string
    merchant_id?: UuidFilter<"order"> | string
    user_id?: UuidFilter<"order"> | string
    full_name?: StringFilter<"order"> | string
    phone?: StringNullableFilter<"order"> | string | null
    delivery_address?: StringNullableFilter<"order"> | string | null
    delivery_fee?: BigIntNullableFilter<"order"> | bigint | number | null
    note?: StringNullableFilter<"order"> | string | null
    total_amount?: BigIntFilter<"order"> | bigint | number
    created_at?: DateTimeNullableFilter<"order"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"order"> | Date | string | null
    status?: StringNullableFilter<"order"> | string | null
    status_payment?: StringNullableFilter<"order"> | string | null
    payment_method?: StringNullableFilter<"order"> | string | null
  }

  export type payment_transactionUpsertWithWhereUniqueWithoutUserInput = {
    where: payment_transactionWhereUniqueInput
    update: XOR<payment_transactionUpdateWithoutUserInput, payment_transactionUncheckedUpdateWithoutUserInput>
    create: XOR<payment_transactionCreateWithoutUserInput, payment_transactionUncheckedCreateWithoutUserInput>
  }

  export type payment_transactionUpdateWithWhereUniqueWithoutUserInput = {
    where: payment_transactionWhereUniqueInput
    data: XOR<payment_transactionUpdateWithoutUserInput, payment_transactionUncheckedUpdateWithoutUserInput>
  }

  export type payment_transactionUpdateManyWithWhereWithoutUserInput = {
    where: payment_transactionScalarWhereInput
    data: XOR<payment_transactionUpdateManyMutationInput, payment_transactionUncheckedUpdateManyWithoutUserInput>
  }

  export type payment_transactionScalarWhereInput = {
    AND?: payment_transactionScalarWhereInput | payment_transactionScalarWhereInput[]
    OR?: payment_transactionScalarWhereInput[]
    NOT?: payment_transactionScalarWhereInput | payment_transactionScalarWhereInput[]
    id?: UuidFilter<"payment_transaction"> | string
    user_id?: UuidFilter<"payment_transaction"> | string
    merchant_id?: UuidFilter<"payment_transaction"> | string
    order_id?: UuidNullableFilter<"payment_transaction"> | string | null
    amount?: BigIntFilter<"payment_transaction"> | bigint | number
    currency?: StringFilter<"payment_transaction"> | string
    txn_ref?: StringFilter<"payment_transaction"> | string
    transaction_no?: StringNullableFilter<"payment_transaction"> | string | null
    payment_method?: StringFilter<"payment_transaction"> | string
    status?: EnumPaymentStatusFilter<"payment_transaction"> | $Enums.PaymentStatus
    response_code?: StringNullableFilter<"payment_transaction"> | string | null
    bank_code?: StringNullableFilter<"payment_transaction"> | string | null
    pay_date?: StringNullableFilter<"payment_transaction"> | string | null
    tmn_code?: StringNullableFilter<"payment_transaction"> | string | null
    raw_payload?: JsonNullableFilter<"payment_transaction">
    created_at?: DateTimeFilter<"payment_transaction"> | Date | string
    updated_at?: DateTimeFilter<"payment_transaction"> | Date | string
  }

  export type categoryCreateWithoutMerchantInput = {
    id?: string
    category_name: string
    menu_item?: menu_itemCreateNestedManyWithoutCategoryInput
  }

  export type categoryUncheckedCreateWithoutMerchantInput = {
    id?: string
    category_name: string
    menu_item?: menu_itemUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type categoryCreateOrConnectWithoutMerchantInput = {
    where: categoryWhereUniqueInput
    create: XOR<categoryCreateWithoutMerchantInput, categoryUncheckedCreateWithoutMerchantInput>
  }

  export type categoryCreateManyMerchantInputEnvelope = {
    data: categoryCreateManyMerchantInput | categoryCreateManyMerchantInput[]
    skipDuplicates?: boolean
  }

  export type menu_itemCreateWithoutMerchantInput = {
    id?: string
    name_item: string
    likes?: bigint | number
    price: bigint | number
    description?: string | null
    sold_count?: bigint | number
    image_item?: NullableJsonNullValueInput | InputJsonValue
    status?: boolean
    category?: categoryCreateNestedOneWithoutMenu_itemInput
    menu_item_option?: menu_item_optionCreateNestedManyWithoutMenu_itemInput
    order_items?: order_itemCreateNestedManyWithoutMenu_itemInput
  }

  export type menu_itemUncheckedCreateWithoutMerchantInput = {
    id?: string
    category_id?: string | null
    name_item: string
    likes?: bigint | number
    price: bigint | number
    description?: string | null
    sold_count?: bigint | number
    image_item?: NullableJsonNullValueInput | InputJsonValue
    status?: boolean
    menu_item_option?: menu_item_optionUncheckedCreateNestedManyWithoutMenu_itemInput
    order_items?: order_itemUncheckedCreateNestedManyWithoutMenu_itemInput
  }

  export type menu_itemCreateOrConnectWithoutMerchantInput = {
    where: menu_itemWhereUniqueInput
    create: XOR<menu_itemCreateWithoutMerchantInput, menu_itemUncheckedCreateWithoutMerchantInput>
  }

  export type menu_itemCreateManyMerchantInputEnvelope = {
    data: menu_itemCreateManyMerchantInput | menu_itemCreateManyMerchantInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutMerchantsInput = {
    id?: string
    image?: NullableJsonNullValueInput | InputJsonValue
    full_name: string
    role?: string | null
    birth?: Date | string | null
    password: string
    phone: string
    email: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    orders?: orderCreateNestedManyWithoutUserInput
    payment_transactions?: payment_transactionCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutMerchantsInput = {
    id?: string
    image?: NullableJsonNullValueInput | InputJsonValue
    full_name: string
    role?: string | null
    birth?: Date | string | null
    password: string
    phone: string
    email: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    orders?: orderUncheckedCreateNestedManyWithoutUserInput
    payment_transactions?: payment_transactionUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutMerchantsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutMerchantsInput, usersUncheckedCreateWithoutMerchantsInput>
  }

  export type optionCreateWithoutMerchantInput = {
    id?: string
    option_name: string
    multi_select?: boolean
    require_select?: boolean
    number_select?: bigint | number
    menu_item_option?: menu_item_optionCreateNestedManyWithoutOptionInput
    option_item?: option_itemCreateNestedManyWithoutOptionInput
  }

  export type optionUncheckedCreateWithoutMerchantInput = {
    id?: string
    option_name: string
    multi_select?: boolean
    require_select?: boolean
    number_select?: bigint | number
    menu_item_option?: menu_item_optionUncheckedCreateNestedManyWithoutOptionInput
    option_item?: option_itemUncheckedCreateNestedManyWithoutOptionInput
  }

  export type optionCreateOrConnectWithoutMerchantInput = {
    where: optionWhereUniqueInput
    create: XOR<optionCreateWithoutMerchantInput, optionUncheckedCreateWithoutMerchantInput>
  }

  export type optionCreateManyMerchantInputEnvelope = {
    data: optionCreateManyMerchantInput | optionCreateManyMerchantInput[]
    skipDuplicates?: boolean
  }

  export type orderCreateWithoutMerchantInput = {
    id?: string
    full_name: string
    phone?: string | null
    delivery_address?: string | null
    delivery_fee?: bigint | number | null
    note?: string | null
    total_amount: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    status?: string | null
    status_payment?: string | null
    payment_method?: string | null
    user: usersCreateNestedOneWithoutOrdersInput
    items?: order_itemCreateNestedManyWithoutOrderInput
    payments?: payment_transactionCreateNestedManyWithoutOrderInput
  }

  export type orderUncheckedCreateWithoutMerchantInput = {
    id?: string
    user_id: string
    full_name: string
    phone?: string | null
    delivery_address?: string | null
    delivery_fee?: bigint | number | null
    note?: string | null
    total_amount: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    status?: string | null
    status_payment?: string | null
    payment_method?: string | null
    items?: order_itemUncheckedCreateNestedManyWithoutOrderInput
    payments?: payment_transactionUncheckedCreateNestedManyWithoutOrderInput
  }

  export type orderCreateOrConnectWithoutMerchantInput = {
    where: orderWhereUniqueInput
    create: XOR<orderCreateWithoutMerchantInput, orderUncheckedCreateWithoutMerchantInput>
  }

  export type orderCreateManyMerchantInputEnvelope = {
    data: orderCreateManyMerchantInput | orderCreateManyMerchantInput[]
    skipDuplicates?: boolean
  }

  export type payment_transactionCreateWithoutMerchantInput = {
    id?: string
    amount: bigint | number
    currency?: string
    txn_ref: string
    transaction_no?: string | null
    payment_method: string
    status?: $Enums.PaymentStatus
    response_code?: string | null
    bank_code?: string | null
    pay_date?: string | null
    tmn_code?: string | null
    raw_payload?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    order?: orderCreateNestedOneWithoutPaymentsInput
    user: usersCreateNestedOneWithoutPayment_transactionsInput
  }

  export type payment_transactionUncheckedCreateWithoutMerchantInput = {
    id?: string
    user_id: string
    order_id?: string | null
    amount: bigint | number
    currency?: string
    txn_ref: string
    transaction_no?: string | null
    payment_method: string
    status?: $Enums.PaymentStatus
    response_code?: string | null
    bank_code?: string | null
    pay_date?: string | null
    tmn_code?: string | null
    raw_payload?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type payment_transactionCreateOrConnectWithoutMerchantInput = {
    where: payment_transactionWhereUniqueInput
    create: XOR<payment_transactionCreateWithoutMerchantInput, payment_transactionUncheckedCreateWithoutMerchantInput>
  }

  export type payment_transactionCreateManyMerchantInputEnvelope = {
    data: payment_transactionCreateManyMerchantInput | payment_transactionCreateManyMerchantInput[]
    skipDuplicates?: boolean
  }

  export type categoryUpsertWithWhereUniqueWithoutMerchantInput = {
    where: categoryWhereUniqueInput
    update: XOR<categoryUpdateWithoutMerchantInput, categoryUncheckedUpdateWithoutMerchantInput>
    create: XOR<categoryCreateWithoutMerchantInput, categoryUncheckedCreateWithoutMerchantInput>
  }

  export type categoryUpdateWithWhereUniqueWithoutMerchantInput = {
    where: categoryWhereUniqueInput
    data: XOR<categoryUpdateWithoutMerchantInput, categoryUncheckedUpdateWithoutMerchantInput>
  }

  export type categoryUpdateManyWithWhereWithoutMerchantInput = {
    where: categoryScalarWhereInput
    data: XOR<categoryUpdateManyMutationInput, categoryUncheckedUpdateManyWithoutMerchantInput>
  }

  export type categoryScalarWhereInput = {
    AND?: categoryScalarWhereInput | categoryScalarWhereInput[]
    OR?: categoryScalarWhereInput[]
    NOT?: categoryScalarWhereInput | categoryScalarWhereInput[]
    id?: UuidFilter<"category"> | string
    merchant_id?: UuidFilter<"category"> | string
    category_name?: StringFilter<"category"> | string
  }

  export type menu_itemUpsertWithWhereUniqueWithoutMerchantInput = {
    where: menu_itemWhereUniqueInput
    update: XOR<menu_itemUpdateWithoutMerchantInput, menu_itemUncheckedUpdateWithoutMerchantInput>
    create: XOR<menu_itemCreateWithoutMerchantInput, menu_itemUncheckedCreateWithoutMerchantInput>
  }

  export type menu_itemUpdateWithWhereUniqueWithoutMerchantInput = {
    where: menu_itemWhereUniqueInput
    data: XOR<menu_itemUpdateWithoutMerchantInput, menu_itemUncheckedUpdateWithoutMerchantInput>
  }

  export type menu_itemUpdateManyWithWhereWithoutMerchantInput = {
    where: menu_itemScalarWhereInput
    data: XOR<menu_itemUpdateManyMutationInput, menu_itemUncheckedUpdateManyWithoutMerchantInput>
  }

  export type menu_itemScalarWhereInput = {
    AND?: menu_itemScalarWhereInput | menu_itemScalarWhereInput[]
    OR?: menu_itemScalarWhereInput[]
    NOT?: menu_itemScalarWhereInput | menu_itemScalarWhereInput[]
    id?: UuidFilter<"menu_item"> | string
    merchant_id?: UuidFilter<"menu_item"> | string
    category_id?: UuidNullableFilter<"menu_item"> | string | null
    name_item?: StringFilter<"menu_item"> | string
    likes?: BigIntFilter<"menu_item"> | bigint | number
    price?: BigIntFilter<"menu_item"> | bigint | number
    description?: StringNullableFilter<"menu_item"> | string | null
    sold_count?: BigIntFilter<"menu_item"> | bigint | number
    image_item?: JsonNullableFilter<"menu_item">
    status?: BoolFilter<"menu_item"> | boolean
  }

  export type usersUpsertWithoutMerchantsInput = {
    update: XOR<usersUpdateWithoutMerchantsInput, usersUncheckedUpdateWithoutMerchantsInput>
    create: XOR<usersCreateWithoutMerchantsInput, usersUncheckedCreateWithoutMerchantsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutMerchantsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutMerchantsInput, usersUncheckedUpdateWithoutMerchantsInput>
  }

  export type usersUpdateWithoutMerchantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: NullableJsonNullValueInput | InputJsonValue
    full_name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orders?: orderUpdateManyWithoutUserNestedInput
    payment_transactions?: payment_transactionUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutMerchantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: NullableJsonNullValueInput | InputJsonValue
    full_name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orders?: orderUncheckedUpdateManyWithoutUserNestedInput
    payment_transactions?: payment_transactionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type optionUpsertWithWhereUniqueWithoutMerchantInput = {
    where: optionWhereUniqueInput
    update: XOR<optionUpdateWithoutMerchantInput, optionUncheckedUpdateWithoutMerchantInput>
    create: XOR<optionCreateWithoutMerchantInput, optionUncheckedCreateWithoutMerchantInput>
  }

  export type optionUpdateWithWhereUniqueWithoutMerchantInput = {
    where: optionWhereUniqueInput
    data: XOR<optionUpdateWithoutMerchantInput, optionUncheckedUpdateWithoutMerchantInput>
  }

  export type optionUpdateManyWithWhereWithoutMerchantInput = {
    where: optionScalarWhereInput
    data: XOR<optionUpdateManyMutationInput, optionUncheckedUpdateManyWithoutMerchantInput>
  }

  export type optionScalarWhereInput = {
    AND?: optionScalarWhereInput | optionScalarWhereInput[]
    OR?: optionScalarWhereInput[]
    NOT?: optionScalarWhereInput | optionScalarWhereInput[]
    id?: UuidFilter<"option"> | string
    merchant_id?: UuidFilter<"option"> | string
    option_name?: StringFilter<"option"> | string
    multi_select?: BoolFilter<"option"> | boolean
    require_select?: BoolFilter<"option"> | boolean
    number_select?: BigIntFilter<"option"> | bigint | number
  }

  export type orderUpsertWithWhereUniqueWithoutMerchantInput = {
    where: orderWhereUniqueInput
    update: XOR<orderUpdateWithoutMerchantInput, orderUncheckedUpdateWithoutMerchantInput>
    create: XOR<orderCreateWithoutMerchantInput, orderUncheckedCreateWithoutMerchantInput>
  }

  export type orderUpdateWithWhereUniqueWithoutMerchantInput = {
    where: orderWhereUniqueInput
    data: XOR<orderUpdateWithoutMerchantInput, orderUncheckedUpdateWithoutMerchantInput>
  }

  export type orderUpdateManyWithWhereWithoutMerchantInput = {
    where: orderScalarWhereInput
    data: XOR<orderUpdateManyMutationInput, orderUncheckedUpdateManyWithoutMerchantInput>
  }

  export type payment_transactionUpsertWithWhereUniqueWithoutMerchantInput = {
    where: payment_transactionWhereUniqueInput
    update: XOR<payment_transactionUpdateWithoutMerchantInput, payment_transactionUncheckedUpdateWithoutMerchantInput>
    create: XOR<payment_transactionCreateWithoutMerchantInput, payment_transactionUncheckedCreateWithoutMerchantInput>
  }

  export type payment_transactionUpdateWithWhereUniqueWithoutMerchantInput = {
    where: payment_transactionWhereUniqueInput
    data: XOR<payment_transactionUpdateWithoutMerchantInput, payment_transactionUncheckedUpdateWithoutMerchantInput>
  }

  export type payment_transactionUpdateManyWithWhereWithoutMerchantInput = {
    where: payment_transactionScalarWhereInput
    data: XOR<payment_transactionUpdateManyMutationInput, payment_transactionUncheckedUpdateManyWithoutMerchantInput>
  }

  export type merchantCreateWithoutCategoriesInput = {
    id?: string
    merchant_name: string
    location?: NullableJsonNullValueInput | InputJsonValue
    phone?: string | null
    email?: string | null
    profile_image?: NullableJsonNullValueInput | InputJsonValue
    cover_image?: NullableJsonNullValueInput | InputJsonValue
    time_open?: NullableJsonNullValueInput | InputJsonValue
    cuisine?: string | null
    menu_item?: menu_itemCreateNestedManyWithoutMerchantInput
    user: usersCreateNestedOneWithoutMerchantsInput
    option?: optionCreateNestedManyWithoutMerchantInput
    orders?: orderCreateNestedManyWithoutMerchantInput
    payment_transactions?: payment_transactionCreateNestedManyWithoutMerchantInput
  }

  export type merchantUncheckedCreateWithoutCategoriesInput = {
    id?: string
    user_id: string
    merchant_name: string
    location?: NullableJsonNullValueInput | InputJsonValue
    phone?: string | null
    email?: string | null
    profile_image?: NullableJsonNullValueInput | InputJsonValue
    cover_image?: NullableJsonNullValueInput | InputJsonValue
    time_open?: NullableJsonNullValueInput | InputJsonValue
    cuisine?: string | null
    menu_item?: menu_itemUncheckedCreateNestedManyWithoutMerchantInput
    option?: optionUncheckedCreateNestedManyWithoutMerchantInput
    orders?: orderUncheckedCreateNestedManyWithoutMerchantInput
    payment_transactions?: payment_transactionUncheckedCreateNestedManyWithoutMerchantInput
  }

  export type merchantCreateOrConnectWithoutCategoriesInput = {
    where: merchantWhereUniqueInput
    create: XOR<merchantCreateWithoutCategoriesInput, merchantUncheckedCreateWithoutCategoriesInput>
  }

  export type menu_itemCreateWithoutCategoryInput = {
    id?: string
    name_item: string
    likes?: bigint | number
    price: bigint | number
    description?: string | null
    sold_count?: bigint | number
    image_item?: NullableJsonNullValueInput | InputJsonValue
    status?: boolean
    merchant: merchantCreateNestedOneWithoutMenu_itemInput
    menu_item_option?: menu_item_optionCreateNestedManyWithoutMenu_itemInput
    order_items?: order_itemCreateNestedManyWithoutMenu_itemInput
  }

  export type menu_itemUncheckedCreateWithoutCategoryInput = {
    id?: string
    merchant_id: string
    name_item: string
    likes?: bigint | number
    price: bigint | number
    description?: string | null
    sold_count?: bigint | number
    image_item?: NullableJsonNullValueInput | InputJsonValue
    status?: boolean
    menu_item_option?: menu_item_optionUncheckedCreateNestedManyWithoutMenu_itemInput
    order_items?: order_itemUncheckedCreateNestedManyWithoutMenu_itemInput
  }

  export type menu_itemCreateOrConnectWithoutCategoryInput = {
    where: menu_itemWhereUniqueInput
    create: XOR<menu_itemCreateWithoutCategoryInput, menu_itemUncheckedCreateWithoutCategoryInput>
  }

  export type menu_itemCreateManyCategoryInputEnvelope = {
    data: menu_itemCreateManyCategoryInput | menu_itemCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type merchantUpsertWithoutCategoriesInput = {
    update: XOR<merchantUpdateWithoutCategoriesInput, merchantUncheckedUpdateWithoutCategoriesInput>
    create: XOR<merchantCreateWithoutCategoriesInput, merchantUncheckedCreateWithoutCategoriesInput>
    where?: merchantWhereInput
  }

  export type merchantUpdateToOneWithWhereWithoutCategoriesInput = {
    where?: merchantWhereInput
    data: XOR<merchantUpdateWithoutCategoriesInput, merchantUncheckedUpdateWithoutCategoriesInput>
  }

  export type merchantUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchant_name?: StringFieldUpdateOperationsInput | string
    location?: NullableJsonNullValueInput | InputJsonValue
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableJsonNullValueInput | InputJsonValue
    cover_image?: NullableJsonNullValueInput | InputJsonValue
    time_open?: NullableJsonNullValueInput | InputJsonValue
    cuisine?: NullableStringFieldUpdateOperationsInput | string | null
    menu_item?: menu_itemUpdateManyWithoutMerchantNestedInput
    user?: usersUpdateOneRequiredWithoutMerchantsNestedInput
    option?: optionUpdateManyWithoutMerchantNestedInput
    orders?: orderUpdateManyWithoutMerchantNestedInput
    payment_transactions?: payment_transactionUpdateManyWithoutMerchantNestedInput
  }

  export type merchantUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    merchant_name?: StringFieldUpdateOperationsInput | string
    location?: NullableJsonNullValueInput | InputJsonValue
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableJsonNullValueInput | InputJsonValue
    cover_image?: NullableJsonNullValueInput | InputJsonValue
    time_open?: NullableJsonNullValueInput | InputJsonValue
    cuisine?: NullableStringFieldUpdateOperationsInput | string | null
    menu_item?: menu_itemUncheckedUpdateManyWithoutMerchantNestedInput
    option?: optionUncheckedUpdateManyWithoutMerchantNestedInput
    orders?: orderUncheckedUpdateManyWithoutMerchantNestedInput
    payment_transactions?: payment_transactionUncheckedUpdateManyWithoutMerchantNestedInput
  }

  export type menu_itemUpsertWithWhereUniqueWithoutCategoryInput = {
    where: menu_itemWhereUniqueInput
    update: XOR<menu_itemUpdateWithoutCategoryInput, menu_itemUncheckedUpdateWithoutCategoryInput>
    create: XOR<menu_itemCreateWithoutCategoryInput, menu_itemUncheckedCreateWithoutCategoryInput>
  }

  export type menu_itemUpdateWithWhereUniqueWithoutCategoryInput = {
    where: menu_itemWhereUniqueInput
    data: XOR<menu_itemUpdateWithoutCategoryInput, menu_itemUncheckedUpdateWithoutCategoryInput>
  }

  export type menu_itemUpdateManyWithWhereWithoutCategoryInput = {
    where: menu_itemScalarWhereInput
    data: XOR<menu_itemUpdateManyMutationInput, menu_itemUncheckedUpdateManyWithoutCategoryInput>
  }

  export type categoryCreateWithoutMenu_itemInput = {
    id?: string
    category_name: string
    merchant: merchantCreateNestedOneWithoutCategoriesInput
  }

  export type categoryUncheckedCreateWithoutMenu_itemInput = {
    id?: string
    merchant_id: string
    category_name: string
  }

  export type categoryCreateOrConnectWithoutMenu_itemInput = {
    where: categoryWhereUniqueInput
    create: XOR<categoryCreateWithoutMenu_itemInput, categoryUncheckedCreateWithoutMenu_itemInput>
  }

  export type merchantCreateWithoutMenu_itemInput = {
    id?: string
    merchant_name: string
    location?: NullableJsonNullValueInput | InputJsonValue
    phone?: string | null
    email?: string | null
    profile_image?: NullableJsonNullValueInput | InputJsonValue
    cover_image?: NullableJsonNullValueInput | InputJsonValue
    time_open?: NullableJsonNullValueInput | InputJsonValue
    cuisine?: string | null
    categories?: categoryCreateNestedManyWithoutMerchantInput
    user: usersCreateNestedOneWithoutMerchantsInput
    option?: optionCreateNestedManyWithoutMerchantInput
    orders?: orderCreateNestedManyWithoutMerchantInput
    payment_transactions?: payment_transactionCreateNestedManyWithoutMerchantInput
  }

  export type merchantUncheckedCreateWithoutMenu_itemInput = {
    id?: string
    user_id: string
    merchant_name: string
    location?: NullableJsonNullValueInput | InputJsonValue
    phone?: string | null
    email?: string | null
    profile_image?: NullableJsonNullValueInput | InputJsonValue
    cover_image?: NullableJsonNullValueInput | InputJsonValue
    time_open?: NullableJsonNullValueInput | InputJsonValue
    cuisine?: string | null
    categories?: categoryUncheckedCreateNestedManyWithoutMerchantInput
    option?: optionUncheckedCreateNestedManyWithoutMerchantInput
    orders?: orderUncheckedCreateNestedManyWithoutMerchantInput
    payment_transactions?: payment_transactionUncheckedCreateNestedManyWithoutMerchantInput
  }

  export type merchantCreateOrConnectWithoutMenu_itemInput = {
    where: merchantWhereUniqueInput
    create: XOR<merchantCreateWithoutMenu_itemInput, merchantUncheckedCreateWithoutMenu_itemInput>
  }

  export type menu_item_optionCreateWithoutMenu_itemInput = {
    option: optionCreateNestedOneWithoutMenu_item_optionInput
  }

  export type menu_item_optionUncheckedCreateWithoutMenu_itemInput = {
    option_id: string
  }

  export type menu_item_optionCreateOrConnectWithoutMenu_itemInput = {
    where: menu_item_optionWhereUniqueInput
    create: XOR<menu_item_optionCreateWithoutMenu_itemInput, menu_item_optionUncheckedCreateWithoutMenu_itemInput>
  }

  export type menu_item_optionCreateManyMenu_itemInputEnvelope = {
    data: menu_item_optionCreateManyMenu_itemInput | menu_item_optionCreateManyMenu_itemInput[]
    skipDuplicates?: boolean
  }

  export type order_itemCreateWithoutMenu_itemInput = {
    id?: string
    note?: string | null
    quantity: bigint | number
    price: bigint | number
    order: orderCreateNestedOneWithoutItemsInput
    options?: order_item_optionCreateNestedManyWithoutOrder_itemInput
  }

  export type order_itemUncheckedCreateWithoutMenu_itemInput = {
    id?: string
    order_id: string
    note?: string | null
    quantity: bigint | number
    price: bigint | number
    options?: order_item_optionUncheckedCreateNestedManyWithoutOrder_itemInput
  }

  export type order_itemCreateOrConnectWithoutMenu_itemInput = {
    where: order_itemWhereUniqueInput
    create: XOR<order_itemCreateWithoutMenu_itemInput, order_itemUncheckedCreateWithoutMenu_itemInput>
  }

  export type order_itemCreateManyMenu_itemInputEnvelope = {
    data: order_itemCreateManyMenu_itemInput | order_itemCreateManyMenu_itemInput[]
    skipDuplicates?: boolean
  }

  export type categoryUpsertWithoutMenu_itemInput = {
    update: XOR<categoryUpdateWithoutMenu_itemInput, categoryUncheckedUpdateWithoutMenu_itemInput>
    create: XOR<categoryCreateWithoutMenu_itemInput, categoryUncheckedCreateWithoutMenu_itemInput>
    where?: categoryWhereInput
  }

  export type categoryUpdateToOneWithWhereWithoutMenu_itemInput = {
    where?: categoryWhereInput
    data: XOR<categoryUpdateWithoutMenu_itemInput, categoryUncheckedUpdateWithoutMenu_itemInput>
  }

  export type categoryUpdateWithoutMenu_itemInput = {
    id?: StringFieldUpdateOperationsInput | string
    category_name?: StringFieldUpdateOperationsInput | string
    merchant?: merchantUpdateOneRequiredWithoutCategoriesNestedInput
  }

  export type categoryUncheckedUpdateWithoutMenu_itemInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchant_id?: StringFieldUpdateOperationsInput | string
    category_name?: StringFieldUpdateOperationsInput | string
  }

  export type merchantUpsertWithoutMenu_itemInput = {
    update: XOR<merchantUpdateWithoutMenu_itemInput, merchantUncheckedUpdateWithoutMenu_itemInput>
    create: XOR<merchantCreateWithoutMenu_itemInput, merchantUncheckedCreateWithoutMenu_itemInput>
    where?: merchantWhereInput
  }

  export type merchantUpdateToOneWithWhereWithoutMenu_itemInput = {
    where?: merchantWhereInput
    data: XOR<merchantUpdateWithoutMenu_itemInput, merchantUncheckedUpdateWithoutMenu_itemInput>
  }

  export type merchantUpdateWithoutMenu_itemInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchant_name?: StringFieldUpdateOperationsInput | string
    location?: NullableJsonNullValueInput | InputJsonValue
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableJsonNullValueInput | InputJsonValue
    cover_image?: NullableJsonNullValueInput | InputJsonValue
    time_open?: NullableJsonNullValueInput | InputJsonValue
    cuisine?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: categoryUpdateManyWithoutMerchantNestedInput
    user?: usersUpdateOneRequiredWithoutMerchantsNestedInput
    option?: optionUpdateManyWithoutMerchantNestedInput
    orders?: orderUpdateManyWithoutMerchantNestedInput
    payment_transactions?: payment_transactionUpdateManyWithoutMerchantNestedInput
  }

  export type merchantUncheckedUpdateWithoutMenu_itemInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    merchant_name?: StringFieldUpdateOperationsInput | string
    location?: NullableJsonNullValueInput | InputJsonValue
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableJsonNullValueInput | InputJsonValue
    cover_image?: NullableJsonNullValueInput | InputJsonValue
    time_open?: NullableJsonNullValueInput | InputJsonValue
    cuisine?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: categoryUncheckedUpdateManyWithoutMerchantNestedInput
    option?: optionUncheckedUpdateManyWithoutMerchantNestedInput
    orders?: orderUncheckedUpdateManyWithoutMerchantNestedInput
    payment_transactions?: payment_transactionUncheckedUpdateManyWithoutMerchantNestedInput
  }

  export type menu_item_optionUpsertWithWhereUniqueWithoutMenu_itemInput = {
    where: menu_item_optionWhereUniqueInput
    update: XOR<menu_item_optionUpdateWithoutMenu_itemInput, menu_item_optionUncheckedUpdateWithoutMenu_itemInput>
    create: XOR<menu_item_optionCreateWithoutMenu_itemInput, menu_item_optionUncheckedCreateWithoutMenu_itemInput>
  }

  export type menu_item_optionUpdateWithWhereUniqueWithoutMenu_itemInput = {
    where: menu_item_optionWhereUniqueInput
    data: XOR<menu_item_optionUpdateWithoutMenu_itemInput, menu_item_optionUncheckedUpdateWithoutMenu_itemInput>
  }

  export type menu_item_optionUpdateManyWithWhereWithoutMenu_itemInput = {
    where: menu_item_optionScalarWhereInput
    data: XOR<menu_item_optionUpdateManyMutationInput, menu_item_optionUncheckedUpdateManyWithoutMenu_itemInput>
  }

  export type menu_item_optionScalarWhereInput = {
    AND?: menu_item_optionScalarWhereInput | menu_item_optionScalarWhereInput[]
    OR?: menu_item_optionScalarWhereInput[]
    NOT?: menu_item_optionScalarWhereInput | menu_item_optionScalarWhereInput[]
    option_id?: UuidFilter<"menu_item_option"> | string
    menu_item_id?: UuidFilter<"menu_item_option"> | string
  }

  export type order_itemUpsertWithWhereUniqueWithoutMenu_itemInput = {
    where: order_itemWhereUniqueInput
    update: XOR<order_itemUpdateWithoutMenu_itemInput, order_itemUncheckedUpdateWithoutMenu_itemInput>
    create: XOR<order_itemCreateWithoutMenu_itemInput, order_itemUncheckedCreateWithoutMenu_itemInput>
  }

  export type order_itemUpdateWithWhereUniqueWithoutMenu_itemInput = {
    where: order_itemWhereUniqueInput
    data: XOR<order_itemUpdateWithoutMenu_itemInput, order_itemUncheckedUpdateWithoutMenu_itemInput>
  }

  export type order_itemUpdateManyWithWhereWithoutMenu_itemInput = {
    where: order_itemScalarWhereInput
    data: XOR<order_itemUpdateManyMutationInput, order_itemUncheckedUpdateManyWithoutMenu_itemInput>
  }

  export type order_itemScalarWhereInput = {
    AND?: order_itemScalarWhereInput | order_itemScalarWhereInput[]
    OR?: order_itemScalarWhereInput[]
    NOT?: order_itemScalarWhereInput | order_itemScalarWhereInput[]
    id?: UuidFilter<"order_item"> | string
    order_id?: UuidFilter<"order_item"> | string
    menu_item_id?: UuidFilter<"order_item"> | string
    note?: StringNullableFilter<"order_item"> | string | null
    quantity?: BigIntFilter<"order_item"> | bigint | number
    price?: BigIntFilter<"order_item"> | bigint | number
  }

  export type menu_item_optionCreateWithoutOptionInput = {
    menu_item: menu_itemCreateNestedOneWithoutMenu_item_optionInput
  }

  export type menu_item_optionUncheckedCreateWithoutOptionInput = {
    menu_item_id: string
  }

  export type menu_item_optionCreateOrConnectWithoutOptionInput = {
    where: menu_item_optionWhereUniqueInput
    create: XOR<menu_item_optionCreateWithoutOptionInput, menu_item_optionUncheckedCreateWithoutOptionInput>
  }

  export type menu_item_optionCreateManyOptionInputEnvelope = {
    data: menu_item_optionCreateManyOptionInput | menu_item_optionCreateManyOptionInput[]
    skipDuplicates?: boolean
  }

  export type merchantCreateWithoutOptionInput = {
    id?: string
    merchant_name: string
    location?: NullableJsonNullValueInput | InputJsonValue
    phone?: string | null
    email?: string | null
    profile_image?: NullableJsonNullValueInput | InputJsonValue
    cover_image?: NullableJsonNullValueInput | InputJsonValue
    time_open?: NullableJsonNullValueInput | InputJsonValue
    cuisine?: string | null
    categories?: categoryCreateNestedManyWithoutMerchantInput
    menu_item?: menu_itemCreateNestedManyWithoutMerchantInput
    user: usersCreateNestedOneWithoutMerchantsInput
    orders?: orderCreateNestedManyWithoutMerchantInput
    payment_transactions?: payment_transactionCreateNestedManyWithoutMerchantInput
  }

  export type merchantUncheckedCreateWithoutOptionInput = {
    id?: string
    user_id: string
    merchant_name: string
    location?: NullableJsonNullValueInput | InputJsonValue
    phone?: string | null
    email?: string | null
    profile_image?: NullableJsonNullValueInput | InputJsonValue
    cover_image?: NullableJsonNullValueInput | InputJsonValue
    time_open?: NullableJsonNullValueInput | InputJsonValue
    cuisine?: string | null
    categories?: categoryUncheckedCreateNestedManyWithoutMerchantInput
    menu_item?: menu_itemUncheckedCreateNestedManyWithoutMerchantInput
    orders?: orderUncheckedCreateNestedManyWithoutMerchantInput
    payment_transactions?: payment_transactionUncheckedCreateNestedManyWithoutMerchantInput
  }

  export type merchantCreateOrConnectWithoutOptionInput = {
    where: merchantWhereUniqueInput
    create: XOR<merchantCreateWithoutOptionInput, merchantUncheckedCreateWithoutOptionInput>
  }

  export type option_itemCreateWithoutOptionInput = {
    id?: string
    option_item_name: string
    status?: boolean
    status_select?: boolean
    order_item_options?: order_item_optionCreateNestedManyWithoutOption_itemInput
  }

  export type option_itemUncheckedCreateWithoutOptionInput = {
    id?: string
    option_item_name: string
    status?: boolean
    status_select?: boolean
    order_item_options?: order_item_optionUncheckedCreateNestedManyWithoutOption_itemInput
  }

  export type option_itemCreateOrConnectWithoutOptionInput = {
    where: option_itemWhereUniqueInput
    create: XOR<option_itemCreateWithoutOptionInput, option_itemUncheckedCreateWithoutOptionInput>
  }

  export type option_itemCreateManyOptionInputEnvelope = {
    data: option_itemCreateManyOptionInput | option_itemCreateManyOptionInput[]
    skipDuplicates?: boolean
  }

  export type menu_item_optionUpsertWithWhereUniqueWithoutOptionInput = {
    where: menu_item_optionWhereUniqueInput
    update: XOR<menu_item_optionUpdateWithoutOptionInput, menu_item_optionUncheckedUpdateWithoutOptionInput>
    create: XOR<menu_item_optionCreateWithoutOptionInput, menu_item_optionUncheckedCreateWithoutOptionInput>
  }

  export type menu_item_optionUpdateWithWhereUniqueWithoutOptionInput = {
    where: menu_item_optionWhereUniqueInput
    data: XOR<menu_item_optionUpdateWithoutOptionInput, menu_item_optionUncheckedUpdateWithoutOptionInput>
  }

  export type menu_item_optionUpdateManyWithWhereWithoutOptionInput = {
    where: menu_item_optionScalarWhereInput
    data: XOR<menu_item_optionUpdateManyMutationInput, menu_item_optionUncheckedUpdateManyWithoutOptionInput>
  }

  export type merchantUpsertWithoutOptionInput = {
    update: XOR<merchantUpdateWithoutOptionInput, merchantUncheckedUpdateWithoutOptionInput>
    create: XOR<merchantCreateWithoutOptionInput, merchantUncheckedCreateWithoutOptionInput>
    where?: merchantWhereInput
  }

  export type merchantUpdateToOneWithWhereWithoutOptionInput = {
    where?: merchantWhereInput
    data: XOR<merchantUpdateWithoutOptionInput, merchantUncheckedUpdateWithoutOptionInput>
  }

  export type merchantUpdateWithoutOptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchant_name?: StringFieldUpdateOperationsInput | string
    location?: NullableJsonNullValueInput | InputJsonValue
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableJsonNullValueInput | InputJsonValue
    cover_image?: NullableJsonNullValueInput | InputJsonValue
    time_open?: NullableJsonNullValueInput | InputJsonValue
    cuisine?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: categoryUpdateManyWithoutMerchantNestedInput
    menu_item?: menu_itemUpdateManyWithoutMerchantNestedInput
    user?: usersUpdateOneRequiredWithoutMerchantsNestedInput
    orders?: orderUpdateManyWithoutMerchantNestedInput
    payment_transactions?: payment_transactionUpdateManyWithoutMerchantNestedInput
  }

  export type merchantUncheckedUpdateWithoutOptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    merchant_name?: StringFieldUpdateOperationsInput | string
    location?: NullableJsonNullValueInput | InputJsonValue
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableJsonNullValueInput | InputJsonValue
    cover_image?: NullableJsonNullValueInput | InputJsonValue
    time_open?: NullableJsonNullValueInput | InputJsonValue
    cuisine?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: categoryUncheckedUpdateManyWithoutMerchantNestedInput
    menu_item?: menu_itemUncheckedUpdateManyWithoutMerchantNestedInput
    orders?: orderUncheckedUpdateManyWithoutMerchantNestedInput
    payment_transactions?: payment_transactionUncheckedUpdateManyWithoutMerchantNestedInput
  }

  export type option_itemUpsertWithWhereUniqueWithoutOptionInput = {
    where: option_itemWhereUniqueInput
    update: XOR<option_itemUpdateWithoutOptionInput, option_itemUncheckedUpdateWithoutOptionInput>
    create: XOR<option_itemCreateWithoutOptionInput, option_itemUncheckedCreateWithoutOptionInput>
  }

  export type option_itemUpdateWithWhereUniqueWithoutOptionInput = {
    where: option_itemWhereUniqueInput
    data: XOR<option_itemUpdateWithoutOptionInput, option_itemUncheckedUpdateWithoutOptionInput>
  }

  export type option_itemUpdateManyWithWhereWithoutOptionInput = {
    where: option_itemScalarWhereInput
    data: XOR<option_itemUpdateManyMutationInput, option_itemUncheckedUpdateManyWithoutOptionInput>
  }

  export type option_itemScalarWhereInput = {
    AND?: option_itemScalarWhereInput | option_itemScalarWhereInput[]
    OR?: option_itemScalarWhereInput[]
    NOT?: option_itemScalarWhereInput | option_itemScalarWhereInput[]
    id?: UuidFilter<"option_item"> | string
    option_id?: UuidFilter<"option_item"> | string
    option_item_name?: StringFilter<"option_item"> | string
    status?: BoolFilter<"option_item"> | boolean
    status_select?: BoolFilter<"option_item"> | boolean
  }

  export type optionCreateWithoutOption_itemInput = {
    id?: string
    option_name: string
    multi_select?: boolean
    require_select?: boolean
    number_select?: bigint | number
    menu_item_option?: menu_item_optionCreateNestedManyWithoutOptionInput
    merchant: merchantCreateNestedOneWithoutOptionInput
  }

  export type optionUncheckedCreateWithoutOption_itemInput = {
    id?: string
    merchant_id: string
    option_name: string
    multi_select?: boolean
    require_select?: boolean
    number_select?: bigint | number
    menu_item_option?: menu_item_optionUncheckedCreateNestedManyWithoutOptionInput
  }

  export type optionCreateOrConnectWithoutOption_itemInput = {
    where: optionWhereUniqueInput
    create: XOR<optionCreateWithoutOption_itemInput, optionUncheckedCreateWithoutOption_itemInput>
  }

  export type order_item_optionCreateWithoutOption_itemInput = {
    order_item: order_itemCreateNestedOneWithoutOptionsInput
  }

  export type order_item_optionUncheckedCreateWithoutOption_itemInput = {
    order_item_id: string
  }

  export type order_item_optionCreateOrConnectWithoutOption_itemInput = {
    where: order_item_optionWhereUniqueInput
    create: XOR<order_item_optionCreateWithoutOption_itemInput, order_item_optionUncheckedCreateWithoutOption_itemInput>
  }

  export type order_item_optionCreateManyOption_itemInputEnvelope = {
    data: order_item_optionCreateManyOption_itemInput | order_item_optionCreateManyOption_itemInput[]
    skipDuplicates?: boolean
  }

  export type optionUpsertWithoutOption_itemInput = {
    update: XOR<optionUpdateWithoutOption_itemInput, optionUncheckedUpdateWithoutOption_itemInput>
    create: XOR<optionCreateWithoutOption_itemInput, optionUncheckedCreateWithoutOption_itemInput>
    where?: optionWhereInput
  }

  export type optionUpdateToOneWithWhereWithoutOption_itemInput = {
    where?: optionWhereInput
    data: XOR<optionUpdateWithoutOption_itemInput, optionUncheckedUpdateWithoutOption_itemInput>
  }

  export type optionUpdateWithoutOption_itemInput = {
    id?: StringFieldUpdateOperationsInput | string
    option_name?: StringFieldUpdateOperationsInput | string
    multi_select?: BoolFieldUpdateOperationsInput | boolean
    require_select?: BoolFieldUpdateOperationsInput | boolean
    number_select?: BigIntFieldUpdateOperationsInput | bigint | number
    menu_item_option?: menu_item_optionUpdateManyWithoutOptionNestedInput
    merchant?: merchantUpdateOneRequiredWithoutOptionNestedInput
  }

  export type optionUncheckedUpdateWithoutOption_itemInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchant_id?: StringFieldUpdateOperationsInput | string
    option_name?: StringFieldUpdateOperationsInput | string
    multi_select?: BoolFieldUpdateOperationsInput | boolean
    require_select?: BoolFieldUpdateOperationsInput | boolean
    number_select?: BigIntFieldUpdateOperationsInput | bigint | number
    menu_item_option?: menu_item_optionUncheckedUpdateManyWithoutOptionNestedInput
  }

  export type order_item_optionUpsertWithWhereUniqueWithoutOption_itemInput = {
    where: order_item_optionWhereUniqueInput
    update: XOR<order_item_optionUpdateWithoutOption_itemInput, order_item_optionUncheckedUpdateWithoutOption_itemInput>
    create: XOR<order_item_optionCreateWithoutOption_itemInput, order_item_optionUncheckedCreateWithoutOption_itemInput>
  }

  export type order_item_optionUpdateWithWhereUniqueWithoutOption_itemInput = {
    where: order_item_optionWhereUniqueInput
    data: XOR<order_item_optionUpdateWithoutOption_itemInput, order_item_optionUncheckedUpdateWithoutOption_itemInput>
  }

  export type order_item_optionUpdateManyWithWhereWithoutOption_itemInput = {
    where: order_item_optionScalarWhereInput
    data: XOR<order_item_optionUpdateManyMutationInput, order_item_optionUncheckedUpdateManyWithoutOption_itemInput>
  }

  export type order_item_optionScalarWhereInput = {
    AND?: order_item_optionScalarWhereInput | order_item_optionScalarWhereInput[]
    OR?: order_item_optionScalarWhereInput[]
    NOT?: order_item_optionScalarWhereInput | order_item_optionScalarWhereInput[]
    order_item_id?: UuidFilter<"order_item_option"> | string
    option_item_id?: UuidFilter<"order_item_option"> | string
  }

  export type menu_itemCreateWithoutMenu_item_optionInput = {
    id?: string
    name_item: string
    likes?: bigint | number
    price: bigint | number
    description?: string | null
    sold_count?: bigint | number
    image_item?: NullableJsonNullValueInput | InputJsonValue
    status?: boolean
    category?: categoryCreateNestedOneWithoutMenu_itemInput
    merchant: merchantCreateNestedOneWithoutMenu_itemInput
    order_items?: order_itemCreateNestedManyWithoutMenu_itemInput
  }

  export type menu_itemUncheckedCreateWithoutMenu_item_optionInput = {
    id?: string
    merchant_id: string
    category_id?: string | null
    name_item: string
    likes?: bigint | number
    price: bigint | number
    description?: string | null
    sold_count?: bigint | number
    image_item?: NullableJsonNullValueInput | InputJsonValue
    status?: boolean
    order_items?: order_itemUncheckedCreateNestedManyWithoutMenu_itemInput
  }

  export type menu_itemCreateOrConnectWithoutMenu_item_optionInput = {
    where: menu_itemWhereUniqueInput
    create: XOR<menu_itemCreateWithoutMenu_item_optionInput, menu_itemUncheckedCreateWithoutMenu_item_optionInput>
  }

  export type optionCreateWithoutMenu_item_optionInput = {
    id?: string
    option_name: string
    multi_select?: boolean
    require_select?: boolean
    number_select?: bigint | number
    merchant: merchantCreateNestedOneWithoutOptionInput
    option_item?: option_itemCreateNestedManyWithoutOptionInput
  }

  export type optionUncheckedCreateWithoutMenu_item_optionInput = {
    id?: string
    merchant_id: string
    option_name: string
    multi_select?: boolean
    require_select?: boolean
    number_select?: bigint | number
    option_item?: option_itemUncheckedCreateNestedManyWithoutOptionInput
  }

  export type optionCreateOrConnectWithoutMenu_item_optionInput = {
    where: optionWhereUniqueInput
    create: XOR<optionCreateWithoutMenu_item_optionInput, optionUncheckedCreateWithoutMenu_item_optionInput>
  }

  export type menu_itemUpsertWithoutMenu_item_optionInput = {
    update: XOR<menu_itemUpdateWithoutMenu_item_optionInput, menu_itemUncheckedUpdateWithoutMenu_item_optionInput>
    create: XOR<menu_itemCreateWithoutMenu_item_optionInput, menu_itemUncheckedCreateWithoutMenu_item_optionInput>
    where?: menu_itemWhereInput
  }

  export type menu_itemUpdateToOneWithWhereWithoutMenu_item_optionInput = {
    where?: menu_itemWhereInput
    data: XOR<menu_itemUpdateWithoutMenu_item_optionInput, menu_itemUncheckedUpdateWithoutMenu_item_optionInput>
  }

  export type menu_itemUpdateWithoutMenu_item_optionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_item?: StringFieldUpdateOperationsInput | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    price?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sold_count?: BigIntFieldUpdateOperationsInput | bigint | number
    image_item?: NullableJsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
    category?: categoryUpdateOneWithoutMenu_itemNestedInput
    merchant?: merchantUpdateOneRequiredWithoutMenu_itemNestedInput
    order_items?: order_itemUpdateManyWithoutMenu_itemNestedInput
  }

  export type menu_itemUncheckedUpdateWithoutMenu_item_optionInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchant_id?: StringFieldUpdateOperationsInput | string
    category_id?: NullableStringFieldUpdateOperationsInput | string | null
    name_item?: StringFieldUpdateOperationsInput | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    price?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sold_count?: BigIntFieldUpdateOperationsInput | bigint | number
    image_item?: NullableJsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
    order_items?: order_itemUncheckedUpdateManyWithoutMenu_itemNestedInput
  }

  export type optionUpsertWithoutMenu_item_optionInput = {
    update: XOR<optionUpdateWithoutMenu_item_optionInput, optionUncheckedUpdateWithoutMenu_item_optionInput>
    create: XOR<optionCreateWithoutMenu_item_optionInput, optionUncheckedCreateWithoutMenu_item_optionInput>
    where?: optionWhereInput
  }

  export type optionUpdateToOneWithWhereWithoutMenu_item_optionInput = {
    where?: optionWhereInput
    data: XOR<optionUpdateWithoutMenu_item_optionInput, optionUncheckedUpdateWithoutMenu_item_optionInput>
  }

  export type optionUpdateWithoutMenu_item_optionInput = {
    id?: StringFieldUpdateOperationsInput | string
    option_name?: StringFieldUpdateOperationsInput | string
    multi_select?: BoolFieldUpdateOperationsInput | boolean
    require_select?: BoolFieldUpdateOperationsInput | boolean
    number_select?: BigIntFieldUpdateOperationsInput | bigint | number
    merchant?: merchantUpdateOneRequiredWithoutOptionNestedInput
    option_item?: option_itemUpdateManyWithoutOptionNestedInput
  }

  export type optionUncheckedUpdateWithoutMenu_item_optionInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchant_id?: StringFieldUpdateOperationsInput | string
    option_name?: StringFieldUpdateOperationsInput | string
    multi_select?: BoolFieldUpdateOperationsInput | boolean
    require_select?: BoolFieldUpdateOperationsInput | boolean
    number_select?: BigIntFieldUpdateOperationsInput | bigint | number
    option_item?: option_itemUncheckedUpdateManyWithoutOptionNestedInput
  }

  export type merchantCreateWithoutOrdersInput = {
    id?: string
    merchant_name: string
    location?: NullableJsonNullValueInput | InputJsonValue
    phone?: string | null
    email?: string | null
    profile_image?: NullableJsonNullValueInput | InputJsonValue
    cover_image?: NullableJsonNullValueInput | InputJsonValue
    time_open?: NullableJsonNullValueInput | InputJsonValue
    cuisine?: string | null
    categories?: categoryCreateNestedManyWithoutMerchantInput
    menu_item?: menu_itemCreateNestedManyWithoutMerchantInput
    user: usersCreateNestedOneWithoutMerchantsInput
    option?: optionCreateNestedManyWithoutMerchantInput
    payment_transactions?: payment_transactionCreateNestedManyWithoutMerchantInput
  }

  export type merchantUncheckedCreateWithoutOrdersInput = {
    id?: string
    user_id: string
    merchant_name: string
    location?: NullableJsonNullValueInput | InputJsonValue
    phone?: string | null
    email?: string | null
    profile_image?: NullableJsonNullValueInput | InputJsonValue
    cover_image?: NullableJsonNullValueInput | InputJsonValue
    time_open?: NullableJsonNullValueInput | InputJsonValue
    cuisine?: string | null
    categories?: categoryUncheckedCreateNestedManyWithoutMerchantInput
    menu_item?: menu_itemUncheckedCreateNestedManyWithoutMerchantInput
    option?: optionUncheckedCreateNestedManyWithoutMerchantInput
    payment_transactions?: payment_transactionUncheckedCreateNestedManyWithoutMerchantInput
  }

  export type merchantCreateOrConnectWithoutOrdersInput = {
    where: merchantWhereUniqueInput
    create: XOR<merchantCreateWithoutOrdersInput, merchantUncheckedCreateWithoutOrdersInput>
  }

  export type usersCreateWithoutOrdersInput = {
    id?: string
    image?: NullableJsonNullValueInput | InputJsonValue
    full_name: string
    role?: string | null
    birth?: Date | string | null
    password: string
    phone: string
    email: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    merchants?: merchantCreateNestedManyWithoutUserInput
    payment_transactions?: payment_transactionCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutOrdersInput = {
    id?: string
    image?: NullableJsonNullValueInput | InputJsonValue
    full_name: string
    role?: string | null
    birth?: Date | string | null
    password: string
    phone: string
    email: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    merchants?: merchantUncheckedCreateNestedManyWithoutUserInput
    payment_transactions?: payment_transactionUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutOrdersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutOrdersInput, usersUncheckedCreateWithoutOrdersInput>
  }

  export type order_itemCreateWithoutOrderInput = {
    id?: string
    note?: string | null
    quantity: bigint | number
    price: bigint | number
    menu_item: menu_itemCreateNestedOneWithoutOrder_itemsInput
    options?: order_item_optionCreateNestedManyWithoutOrder_itemInput
  }

  export type order_itemUncheckedCreateWithoutOrderInput = {
    id?: string
    menu_item_id: string
    note?: string | null
    quantity: bigint | number
    price: bigint | number
    options?: order_item_optionUncheckedCreateNestedManyWithoutOrder_itemInput
  }

  export type order_itemCreateOrConnectWithoutOrderInput = {
    where: order_itemWhereUniqueInput
    create: XOR<order_itemCreateWithoutOrderInput, order_itemUncheckedCreateWithoutOrderInput>
  }

  export type order_itemCreateManyOrderInputEnvelope = {
    data: order_itemCreateManyOrderInput | order_itemCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type payment_transactionCreateWithoutOrderInput = {
    id?: string
    amount: bigint | number
    currency?: string
    txn_ref: string
    transaction_no?: string | null
    payment_method: string
    status?: $Enums.PaymentStatus
    response_code?: string | null
    bank_code?: string | null
    pay_date?: string | null
    tmn_code?: string | null
    raw_payload?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    merchant: merchantCreateNestedOneWithoutPayment_transactionsInput
    user: usersCreateNestedOneWithoutPayment_transactionsInput
  }

  export type payment_transactionUncheckedCreateWithoutOrderInput = {
    id?: string
    user_id: string
    merchant_id: string
    amount: bigint | number
    currency?: string
    txn_ref: string
    transaction_no?: string | null
    payment_method: string
    status?: $Enums.PaymentStatus
    response_code?: string | null
    bank_code?: string | null
    pay_date?: string | null
    tmn_code?: string | null
    raw_payload?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type payment_transactionCreateOrConnectWithoutOrderInput = {
    where: payment_transactionWhereUniqueInput
    create: XOR<payment_transactionCreateWithoutOrderInput, payment_transactionUncheckedCreateWithoutOrderInput>
  }

  export type payment_transactionCreateManyOrderInputEnvelope = {
    data: payment_transactionCreateManyOrderInput | payment_transactionCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type merchantUpsertWithoutOrdersInput = {
    update: XOR<merchantUpdateWithoutOrdersInput, merchantUncheckedUpdateWithoutOrdersInput>
    create: XOR<merchantCreateWithoutOrdersInput, merchantUncheckedCreateWithoutOrdersInput>
    where?: merchantWhereInput
  }

  export type merchantUpdateToOneWithWhereWithoutOrdersInput = {
    where?: merchantWhereInput
    data: XOR<merchantUpdateWithoutOrdersInput, merchantUncheckedUpdateWithoutOrdersInput>
  }

  export type merchantUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchant_name?: StringFieldUpdateOperationsInput | string
    location?: NullableJsonNullValueInput | InputJsonValue
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableJsonNullValueInput | InputJsonValue
    cover_image?: NullableJsonNullValueInput | InputJsonValue
    time_open?: NullableJsonNullValueInput | InputJsonValue
    cuisine?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: categoryUpdateManyWithoutMerchantNestedInput
    menu_item?: menu_itemUpdateManyWithoutMerchantNestedInput
    user?: usersUpdateOneRequiredWithoutMerchantsNestedInput
    option?: optionUpdateManyWithoutMerchantNestedInput
    payment_transactions?: payment_transactionUpdateManyWithoutMerchantNestedInput
  }

  export type merchantUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    merchant_name?: StringFieldUpdateOperationsInput | string
    location?: NullableJsonNullValueInput | InputJsonValue
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableJsonNullValueInput | InputJsonValue
    cover_image?: NullableJsonNullValueInput | InputJsonValue
    time_open?: NullableJsonNullValueInput | InputJsonValue
    cuisine?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: categoryUncheckedUpdateManyWithoutMerchantNestedInput
    menu_item?: menu_itemUncheckedUpdateManyWithoutMerchantNestedInput
    option?: optionUncheckedUpdateManyWithoutMerchantNestedInput
    payment_transactions?: payment_transactionUncheckedUpdateManyWithoutMerchantNestedInput
  }

  export type usersUpsertWithoutOrdersInput = {
    update: XOR<usersUpdateWithoutOrdersInput, usersUncheckedUpdateWithoutOrdersInput>
    create: XOR<usersCreateWithoutOrdersInput, usersUncheckedCreateWithoutOrdersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutOrdersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutOrdersInput, usersUncheckedUpdateWithoutOrdersInput>
  }

  export type usersUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: NullableJsonNullValueInput | InputJsonValue
    full_name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    merchants?: merchantUpdateManyWithoutUserNestedInput
    payment_transactions?: payment_transactionUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: NullableJsonNullValueInput | InputJsonValue
    full_name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    merchants?: merchantUncheckedUpdateManyWithoutUserNestedInput
    payment_transactions?: payment_transactionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type order_itemUpsertWithWhereUniqueWithoutOrderInput = {
    where: order_itemWhereUniqueInput
    update: XOR<order_itemUpdateWithoutOrderInput, order_itemUncheckedUpdateWithoutOrderInput>
    create: XOR<order_itemCreateWithoutOrderInput, order_itemUncheckedCreateWithoutOrderInput>
  }

  export type order_itemUpdateWithWhereUniqueWithoutOrderInput = {
    where: order_itemWhereUniqueInput
    data: XOR<order_itemUpdateWithoutOrderInput, order_itemUncheckedUpdateWithoutOrderInput>
  }

  export type order_itemUpdateManyWithWhereWithoutOrderInput = {
    where: order_itemScalarWhereInput
    data: XOR<order_itemUpdateManyMutationInput, order_itemUncheckedUpdateManyWithoutOrderInput>
  }

  export type payment_transactionUpsertWithWhereUniqueWithoutOrderInput = {
    where: payment_transactionWhereUniqueInput
    update: XOR<payment_transactionUpdateWithoutOrderInput, payment_transactionUncheckedUpdateWithoutOrderInput>
    create: XOR<payment_transactionCreateWithoutOrderInput, payment_transactionUncheckedCreateWithoutOrderInput>
  }

  export type payment_transactionUpdateWithWhereUniqueWithoutOrderInput = {
    where: payment_transactionWhereUniqueInput
    data: XOR<payment_transactionUpdateWithoutOrderInput, payment_transactionUncheckedUpdateWithoutOrderInput>
  }

  export type payment_transactionUpdateManyWithWhereWithoutOrderInput = {
    where: payment_transactionScalarWhereInput
    data: XOR<payment_transactionUpdateManyMutationInput, payment_transactionUncheckedUpdateManyWithoutOrderInput>
  }

  export type menu_itemCreateWithoutOrder_itemsInput = {
    id?: string
    name_item: string
    likes?: bigint | number
    price: bigint | number
    description?: string | null
    sold_count?: bigint | number
    image_item?: NullableJsonNullValueInput | InputJsonValue
    status?: boolean
    category?: categoryCreateNestedOneWithoutMenu_itemInput
    merchant: merchantCreateNestedOneWithoutMenu_itemInput
    menu_item_option?: menu_item_optionCreateNestedManyWithoutMenu_itemInput
  }

  export type menu_itemUncheckedCreateWithoutOrder_itemsInput = {
    id?: string
    merchant_id: string
    category_id?: string | null
    name_item: string
    likes?: bigint | number
    price: bigint | number
    description?: string | null
    sold_count?: bigint | number
    image_item?: NullableJsonNullValueInput | InputJsonValue
    status?: boolean
    menu_item_option?: menu_item_optionUncheckedCreateNestedManyWithoutMenu_itemInput
  }

  export type menu_itemCreateOrConnectWithoutOrder_itemsInput = {
    where: menu_itemWhereUniqueInput
    create: XOR<menu_itemCreateWithoutOrder_itemsInput, menu_itemUncheckedCreateWithoutOrder_itemsInput>
  }

  export type orderCreateWithoutItemsInput = {
    id?: string
    full_name: string
    phone?: string | null
    delivery_address?: string | null
    delivery_fee?: bigint | number | null
    note?: string | null
    total_amount: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    status?: string | null
    status_payment?: string | null
    payment_method?: string | null
    merchant: merchantCreateNestedOneWithoutOrdersInput
    user: usersCreateNestedOneWithoutOrdersInput
    payments?: payment_transactionCreateNestedManyWithoutOrderInput
  }

  export type orderUncheckedCreateWithoutItemsInput = {
    id?: string
    merchant_id: string
    user_id: string
    full_name: string
    phone?: string | null
    delivery_address?: string | null
    delivery_fee?: bigint | number | null
    note?: string | null
    total_amount: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    status?: string | null
    status_payment?: string | null
    payment_method?: string | null
    payments?: payment_transactionUncheckedCreateNestedManyWithoutOrderInput
  }

  export type orderCreateOrConnectWithoutItemsInput = {
    where: orderWhereUniqueInput
    create: XOR<orderCreateWithoutItemsInput, orderUncheckedCreateWithoutItemsInput>
  }

  export type order_item_optionCreateWithoutOrder_itemInput = {
    option_item: option_itemCreateNestedOneWithoutOrder_item_optionsInput
  }

  export type order_item_optionUncheckedCreateWithoutOrder_itemInput = {
    option_item_id: string
  }

  export type order_item_optionCreateOrConnectWithoutOrder_itemInput = {
    where: order_item_optionWhereUniqueInput
    create: XOR<order_item_optionCreateWithoutOrder_itemInput, order_item_optionUncheckedCreateWithoutOrder_itemInput>
  }

  export type order_item_optionCreateManyOrder_itemInputEnvelope = {
    data: order_item_optionCreateManyOrder_itemInput | order_item_optionCreateManyOrder_itemInput[]
    skipDuplicates?: boolean
  }

  export type menu_itemUpsertWithoutOrder_itemsInput = {
    update: XOR<menu_itemUpdateWithoutOrder_itemsInput, menu_itemUncheckedUpdateWithoutOrder_itemsInput>
    create: XOR<menu_itemCreateWithoutOrder_itemsInput, menu_itemUncheckedCreateWithoutOrder_itemsInput>
    where?: menu_itemWhereInput
  }

  export type menu_itemUpdateToOneWithWhereWithoutOrder_itemsInput = {
    where?: menu_itemWhereInput
    data: XOR<menu_itemUpdateWithoutOrder_itemsInput, menu_itemUncheckedUpdateWithoutOrder_itemsInput>
  }

  export type menu_itemUpdateWithoutOrder_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_item?: StringFieldUpdateOperationsInput | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    price?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sold_count?: BigIntFieldUpdateOperationsInput | bigint | number
    image_item?: NullableJsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
    category?: categoryUpdateOneWithoutMenu_itemNestedInput
    merchant?: merchantUpdateOneRequiredWithoutMenu_itemNestedInput
    menu_item_option?: menu_item_optionUpdateManyWithoutMenu_itemNestedInput
  }

  export type menu_itemUncheckedUpdateWithoutOrder_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchant_id?: StringFieldUpdateOperationsInput | string
    category_id?: NullableStringFieldUpdateOperationsInput | string | null
    name_item?: StringFieldUpdateOperationsInput | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    price?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sold_count?: BigIntFieldUpdateOperationsInput | bigint | number
    image_item?: NullableJsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
    menu_item_option?: menu_item_optionUncheckedUpdateManyWithoutMenu_itemNestedInput
  }

  export type orderUpsertWithoutItemsInput = {
    update: XOR<orderUpdateWithoutItemsInput, orderUncheckedUpdateWithoutItemsInput>
    create: XOR<orderCreateWithoutItemsInput, orderUncheckedCreateWithoutItemsInput>
    where?: orderWhereInput
  }

  export type orderUpdateToOneWithWhereWithoutItemsInput = {
    where?: orderWhereInput
    data: XOR<orderUpdateWithoutItemsInput, orderUncheckedUpdateWithoutItemsInput>
  }

  export type orderUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_address?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_fee?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    status_payment?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: merchantUpdateOneRequiredWithoutOrdersNestedInput
    user?: usersUpdateOneRequiredWithoutOrdersNestedInput
    payments?: payment_transactionUpdateManyWithoutOrderNestedInput
  }

  export type orderUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchant_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_address?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_fee?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    status_payment?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    payments?: payment_transactionUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type order_item_optionUpsertWithWhereUniqueWithoutOrder_itemInput = {
    where: order_item_optionWhereUniqueInput
    update: XOR<order_item_optionUpdateWithoutOrder_itemInput, order_item_optionUncheckedUpdateWithoutOrder_itemInput>
    create: XOR<order_item_optionCreateWithoutOrder_itemInput, order_item_optionUncheckedCreateWithoutOrder_itemInput>
  }

  export type order_item_optionUpdateWithWhereUniqueWithoutOrder_itemInput = {
    where: order_item_optionWhereUniqueInput
    data: XOR<order_item_optionUpdateWithoutOrder_itemInput, order_item_optionUncheckedUpdateWithoutOrder_itemInput>
  }

  export type order_item_optionUpdateManyWithWhereWithoutOrder_itemInput = {
    where: order_item_optionScalarWhereInput
    data: XOR<order_item_optionUpdateManyMutationInput, order_item_optionUncheckedUpdateManyWithoutOrder_itemInput>
  }

  export type option_itemCreateWithoutOrder_item_optionsInput = {
    id?: string
    option_item_name: string
    status?: boolean
    status_select?: boolean
    option: optionCreateNestedOneWithoutOption_itemInput
  }

  export type option_itemUncheckedCreateWithoutOrder_item_optionsInput = {
    id?: string
    option_id: string
    option_item_name: string
    status?: boolean
    status_select?: boolean
  }

  export type option_itemCreateOrConnectWithoutOrder_item_optionsInput = {
    where: option_itemWhereUniqueInput
    create: XOR<option_itemCreateWithoutOrder_item_optionsInput, option_itemUncheckedCreateWithoutOrder_item_optionsInput>
  }

  export type order_itemCreateWithoutOptionsInput = {
    id?: string
    note?: string | null
    quantity: bigint | number
    price: bigint | number
    menu_item: menu_itemCreateNestedOneWithoutOrder_itemsInput
    order: orderCreateNestedOneWithoutItemsInput
  }

  export type order_itemUncheckedCreateWithoutOptionsInput = {
    id?: string
    order_id: string
    menu_item_id: string
    note?: string | null
    quantity: bigint | number
    price: bigint | number
  }

  export type order_itemCreateOrConnectWithoutOptionsInput = {
    where: order_itemWhereUniqueInput
    create: XOR<order_itemCreateWithoutOptionsInput, order_itemUncheckedCreateWithoutOptionsInput>
  }

  export type option_itemUpsertWithoutOrder_item_optionsInput = {
    update: XOR<option_itemUpdateWithoutOrder_item_optionsInput, option_itemUncheckedUpdateWithoutOrder_item_optionsInput>
    create: XOR<option_itemCreateWithoutOrder_item_optionsInput, option_itemUncheckedCreateWithoutOrder_item_optionsInput>
    where?: option_itemWhereInput
  }

  export type option_itemUpdateToOneWithWhereWithoutOrder_item_optionsInput = {
    where?: option_itemWhereInput
    data: XOR<option_itemUpdateWithoutOrder_item_optionsInput, option_itemUncheckedUpdateWithoutOrder_item_optionsInput>
  }

  export type option_itemUpdateWithoutOrder_item_optionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    option_item_name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    status_select?: BoolFieldUpdateOperationsInput | boolean
    option?: optionUpdateOneRequiredWithoutOption_itemNestedInput
  }

  export type option_itemUncheckedUpdateWithoutOrder_item_optionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    option_id?: StringFieldUpdateOperationsInput | string
    option_item_name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    status_select?: BoolFieldUpdateOperationsInput | boolean
  }

  export type order_itemUpsertWithoutOptionsInput = {
    update: XOR<order_itemUpdateWithoutOptionsInput, order_itemUncheckedUpdateWithoutOptionsInput>
    create: XOR<order_itemCreateWithoutOptionsInput, order_itemUncheckedCreateWithoutOptionsInput>
    where?: order_itemWhereInput
  }

  export type order_itemUpdateToOneWithWhereWithoutOptionsInput = {
    where?: order_itemWhereInput
    data: XOR<order_itemUpdateWithoutOptionsInput, order_itemUncheckedUpdateWithoutOptionsInput>
  }

  export type order_itemUpdateWithoutOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: BigIntFieldUpdateOperationsInput | bigint | number
    price?: BigIntFieldUpdateOperationsInput | bigint | number
    menu_item?: menu_itemUpdateOneRequiredWithoutOrder_itemsNestedInput
    order?: orderUpdateOneRequiredWithoutItemsNestedInput
  }

  export type order_itemUncheckedUpdateWithoutOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    order_id?: StringFieldUpdateOperationsInput | string
    menu_item_id?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: BigIntFieldUpdateOperationsInput | bigint | number
    price?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type merchantCreateWithoutPayment_transactionsInput = {
    id?: string
    merchant_name: string
    location?: NullableJsonNullValueInput | InputJsonValue
    phone?: string | null
    email?: string | null
    profile_image?: NullableJsonNullValueInput | InputJsonValue
    cover_image?: NullableJsonNullValueInput | InputJsonValue
    time_open?: NullableJsonNullValueInput | InputJsonValue
    cuisine?: string | null
    categories?: categoryCreateNestedManyWithoutMerchantInput
    menu_item?: menu_itemCreateNestedManyWithoutMerchantInput
    user: usersCreateNestedOneWithoutMerchantsInput
    option?: optionCreateNestedManyWithoutMerchantInput
    orders?: orderCreateNestedManyWithoutMerchantInput
  }

  export type merchantUncheckedCreateWithoutPayment_transactionsInput = {
    id?: string
    user_id: string
    merchant_name: string
    location?: NullableJsonNullValueInput | InputJsonValue
    phone?: string | null
    email?: string | null
    profile_image?: NullableJsonNullValueInput | InputJsonValue
    cover_image?: NullableJsonNullValueInput | InputJsonValue
    time_open?: NullableJsonNullValueInput | InputJsonValue
    cuisine?: string | null
    categories?: categoryUncheckedCreateNestedManyWithoutMerchantInput
    menu_item?: menu_itemUncheckedCreateNestedManyWithoutMerchantInput
    option?: optionUncheckedCreateNestedManyWithoutMerchantInput
    orders?: orderUncheckedCreateNestedManyWithoutMerchantInput
  }

  export type merchantCreateOrConnectWithoutPayment_transactionsInput = {
    where: merchantWhereUniqueInput
    create: XOR<merchantCreateWithoutPayment_transactionsInput, merchantUncheckedCreateWithoutPayment_transactionsInput>
  }

  export type orderCreateWithoutPaymentsInput = {
    id?: string
    full_name: string
    phone?: string | null
    delivery_address?: string | null
    delivery_fee?: bigint | number | null
    note?: string | null
    total_amount: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    status?: string | null
    status_payment?: string | null
    payment_method?: string | null
    merchant: merchantCreateNestedOneWithoutOrdersInput
    user: usersCreateNestedOneWithoutOrdersInput
    items?: order_itemCreateNestedManyWithoutOrderInput
  }

  export type orderUncheckedCreateWithoutPaymentsInput = {
    id?: string
    merchant_id: string
    user_id: string
    full_name: string
    phone?: string | null
    delivery_address?: string | null
    delivery_fee?: bigint | number | null
    note?: string | null
    total_amount: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    status?: string | null
    status_payment?: string | null
    payment_method?: string | null
    items?: order_itemUncheckedCreateNestedManyWithoutOrderInput
  }

  export type orderCreateOrConnectWithoutPaymentsInput = {
    where: orderWhereUniqueInput
    create: XOR<orderCreateWithoutPaymentsInput, orderUncheckedCreateWithoutPaymentsInput>
  }

  export type usersCreateWithoutPayment_transactionsInput = {
    id?: string
    image?: NullableJsonNullValueInput | InputJsonValue
    full_name: string
    role?: string | null
    birth?: Date | string | null
    password: string
    phone: string
    email: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    merchants?: merchantCreateNestedManyWithoutUserInput
    orders?: orderCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutPayment_transactionsInput = {
    id?: string
    image?: NullableJsonNullValueInput | InputJsonValue
    full_name: string
    role?: string | null
    birth?: Date | string | null
    password: string
    phone: string
    email: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    merchants?: merchantUncheckedCreateNestedManyWithoutUserInput
    orders?: orderUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutPayment_transactionsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutPayment_transactionsInput, usersUncheckedCreateWithoutPayment_transactionsInput>
  }

  export type merchantUpsertWithoutPayment_transactionsInput = {
    update: XOR<merchantUpdateWithoutPayment_transactionsInput, merchantUncheckedUpdateWithoutPayment_transactionsInput>
    create: XOR<merchantCreateWithoutPayment_transactionsInput, merchantUncheckedCreateWithoutPayment_transactionsInput>
    where?: merchantWhereInput
  }

  export type merchantUpdateToOneWithWhereWithoutPayment_transactionsInput = {
    where?: merchantWhereInput
    data: XOR<merchantUpdateWithoutPayment_transactionsInput, merchantUncheckedUpdateWithoutPayment_transactionsInput>
  }

  export type merchantUpdateWithoutPayment_transactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchant_name?: StringFieldUpdateOperationsInput | string
    location?: NullableJsonNullValueInput | InputJsonValue
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableJsonNullValueInput | InputJsonValue
    cover_image?: NullableJsonNullValueInput | InputJsonValue
    time_open?: NullableJsonNullValueInput | InputJsonValue
    cuisine?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: categoryUpdateManyWithoutMerchantNestedInput
    menu_item?: menu_itemUpdateManyWithoutMerchantNestedInput
    user?: usersUpdateOneRequiredWithoutMerchantsNestedInput
    option?: optionUpdateManyWithoutMerchantNestedInput
    orders?: orderUpdateManyWithoutMerchantNestedInput
  }

  export type merchantUncheckedUpdateWithoutPayment_transactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    merchant_name?: StringFieldUpdateOperationsInput | string
    location?: NullableJsonNullValueInput | InputJsonValue
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableJsonNullValueInput | InputJsonValue
    cover_image?: NullableJsonNullValueInput | InputJsonValue
    time_open?: NullableJsonNullValueInput | InputJsonValue
    cuisine?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: categoryUncheckedUpdateManyWithoutMerchantNestedInput
    menu_item?: menu_itemUncheckedUpdateManyWithoutMerchantNestedInput
    option?: optionUncheckedUpdateManyWithoutMerchantNestedInput
    orders?: orderUncheckedUpdateManyWithoutMerchantNestedInput
  }

  export type orderUpsertWithoutPaymentsInput = {
    update: XOR<orderUpdateWithoutPaymentsInput, orderUncheckedUpdateWithoutPaymentsInput>
    create: XOR<orderCreateWithoutPaymentsInput, orderUncheckedCreateWithoutPaymentsInput>
    where?: orderWhereInput
  }

  export type orderUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: orderWhereInput
    data: XOR<orderUpdateWithoutPaymentsInput, orderUncheckedUpdateWithoutPaymentsInput>
  }

  export type orderUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_address?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_fee?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    status_payment?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: merchantUpdateOneRequiredWithoutOrdersNestedInput
    user?: usersUpdateOneRequiredWithoutOrdersNestedInput
    items?: order_itemUpdateManyWithoutOrderNestedInput
  }

  export type orderUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchant_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_address?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_fee?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    status_payment?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    items?: order_itemUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type usersUpsertWithoutPayment_transactionsInput = {
    update: XOR<usersUpdateWithoutPayment_transactionsInput, usersUncheckedUpdateWithoutPayment_transactionsInput>
    create: XOR<usersCreateWithoutPayment_transactionsInput, usersUncheckedCreateWithoutPayment_transactionsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutPayment_transactionsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutPayment_transactionsInput, usersUncheckedUpdateWithoutPayment_transactionsInput>
  }

  export type usersUpdateWithoutPayment_transactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: NullableJsonNullValueInput | InputJsonValue
    full_name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    merchants?: merchantUpdateManyWithoutUserNestedInput
    orders?: orderUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutPayment_transactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: NullableJsonNullValueInput | InputJsonValue
    full_name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    merchants?: merchantUncheckedUpdateManyWithoutUserNestedInput
    orders?: orderUncheckedUpdateManyWithoutUserNestedInput
  }

  export type merchantCreateManyUserInput = {
    id?: string
    merchant_name: string
    location?: NullableJsonNullValueInput | InputJsonValue
    phone?: string | null
    email?: string | null
    profile_image?: NullableJsonNullValueInput | InputJsonValue
    cover_image?: NullableJsonNullValueInput | InputJsonValue
    time_open?: NullableJsonNullValueInput | InputJsonValue
    cuisine?: string | null
  }

  export type orderCreateManyUserInput = {
    id?: string
    merchant_id: string
    full_name: string
    phone?: string | null
    delivery_address?: string | null
    delivery_fee?: bigint | number | null
    note?: string | null
    total_amount: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    status?: string | null
    status_payment?: string | null
    payment_method?: string | null
  }

  export type payment_transactionCreateManyUserInput = {
    id?: string
    merchant_id: string
    order_id?: string | null
    amount: bigint | number
    currency?: string
    txn_ref: string
    transaction_no?: string | null
    payment_method: string
    status?: $Enums.PaymentStatus
    response_code?: string | null
    bank_code?: string | null
    pay_date?: string | null
    tmn_code?: string | null
    raw_payload?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type merchantUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchant_name?: StringFieldUpdateOperationsInput | string
    location?: NullableJsonNullValueInput | InputJsonValue
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableJsonNullValueInput | InputJsonValue
    cover_image?: NullableJsonNullValueInput | InputJsonValue
    time_open?: NullableJsonNullValueInput | InputJsonValue
    cuisine?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: categoryUpdateManyWithoutMerchantNestedInput
    menu_item?: menu_itemUpdateManyWithoutMerchantNestedInput
    option?: optionUpdateManyWithoutMerchantNestedInput
    orders?: orderUpdateManyWithoutMerchantNestedInput
    payment_transactions?: payment_transactionUpdateManyWithoutMerchantNestedInput
  }

  export type merchantUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchant_name?: StringFieldUpdateOperationsInput | string
    location?: NullableJsonNullValueInput | InputJsonValue
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableJsonNullValueInput | InputJsonValue
    cover_image?: NullableJsonNullValueInput | InputJsonValue
    time_open?: NullableJsonNullValueInput | InputJsonValue
    cuisine?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: categoryUncheckedUpdateManyWithoutMerchantNestedInput
    menu_item?: menu_itemUncheckedUpdateManyWithoutMerchantNestedInput
    option?: optionUncheckedUpdateManyWithoutMerchantNestedInput
    orders?: orderUncheckedUpdateManyWithoutMerchantNestedInput
    payment_transactions?: payment_transactionUncheckedUpdateManyWithoutMerchantNestedInput
  }

  export type merchantUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchant_name?: StringFieldUpdateOperationsInput | string
    location?: NullableJsonNullValueInput | InputJsonValue
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableJsonNullValueInput | InputJsonValue
    cover_image?: NullableJsonNullValueInput | InputJsonValue
    time_open?: NullableJsonNullValueInput | InputJsonValue
    cuisine?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type orderUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_address?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_fee?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    status_payment?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: merchantUpdateOneRequiredWithoutOrdersNestedInput
    items?: order_itemUpdateManyWithoutOrderNestedInput
    payments?: payment_transactionUpdateManyWithoutOrderNestedInput
  }

  export type orderUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchant_id?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_address?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_fee?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    status_payment?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    items?: order_itemUncheckedUpdateManyWithoutOrderNestedInput
    payments?: payment_transactionUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type orderUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchant_id?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_address?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_fee?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    status_payment?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type payment_transactionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    txn_ref?: StringFieldUpdateOperationsInput | string
    transaction_no?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    response_code?: NullableStringFieldUpdateOperationsInput | string | null
    bank_code?: NullableStringFieldUpdateOperationsInput | string | null
    pay_date?: NullableStringFieldUpdateOperationsInput | string | null
    tmn_code?: NullableStringFieldUpdateOperationsInput | string | null
    raw_payload?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    merchant?: merchantUpdateOneRequiredWithoutPayment_transactionsNestedInput
    order?: orderUpdateOneWithoutPaymentsNestedInput
  }

  export type payment_transactionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchant_id?: StringFieldUpdateOperationsInput | string
    order_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    txn_ref?: StringFieldUpdateOperationsInput | string
    transaction_no?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    response_code?: NullableStringFieldUpdateOperationsInput | string | null
    bank_code?: NullableStringFieldUpdateOperationsInput | string | null
    pay_date?: NullableStringFieldUpdateOperationsInput | string | null
    tmn_code?: NullableStringFieldUpdateOperationsInput | string | null
    raw_payload?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type payment_transactionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchant_id?: StringFieldUpdateOperationsInput | string
    order_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    txn_ref?: StringFieldUpdateOperationsInput | string
    transaction_no?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    response_code?: NullableStringFieldUpdateOperationsInput | string | null
    bank_code?: NullableStringFieldUpdateOperationsInput | string | null
    pay_date?: NullableStringFieldUpdateOperationsInput | string | null
    tmn_code?: NullableStringFieldUpdateOperationsInput | string | null
    raw_payload?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type categoryCreateManyMerchantInput = {
    id?: string
    category_name: string
  }

  export type menu_itemCreateManyMerchantInput = {
    id?: string
    category_id?: string | null
    name_item: string
    likes?: bigint | number
    price: bigint | number
    description?: string | null
    sold_count?: bigint | number
    image_item?: NullableJsonNullValueInput | InputJsonValue
    status?: boolean
  }

  export type optionCreateManyMerchantInput = {
    id?: string
    option_name: string
    multi_select?: boolean
    require_select?: boolean
    number_select?: bigint | number
  }

  export type orderCreateManyMerchantInput = {
    id?: string
    user_id: string
    full_name: string
    phone?: string | null
    delivery_address?: string | null
    delivery_fee?: bigint | number | null
    note?: string | null
    total_amount: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    status?: string | null
    status_payment?: string | null
    payment_method?: string | null
  }

  export type payment_transactionCreateManyMerchantInput = {
    id?: string
    user_id: string
    order_id?: string | null
    amount: bigint | number
    currency?: string
    txn_ref: string
    transaction_no?: string | null
    payment_method: string
    status?: $Enums.PaymentStatus
    response_code?: string | null
    bank_code?: string | null
    pay_date?: string | null
    tmn_code?: string | null
    raw_payload?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type categoryUpdateWithoutMerchantInput = {
    id?: StringFieldUpdateOperationsInput | string
    category_name?: StringFieldUpdateOperationsInput | string
    menu_item?: menu_itemUpdateManyWithoutCategoryNestedInput
  }

  export type categoryUncheckedUpdateWithoutMerchantInput = {
    id?: StringFieldUpdateOperationsInput | string
    category_name?: StringFieldUpdateOperationsInput | string
    menu_item?: menu_itemUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type categoryUncheckedUpdateManyWithoutMerchantInput = {
    id?: StringFieldUpdateOperationsInput | string
    category_name?: StringFieldUpdateOperationsInput | string
  }

  export type menu_itemUpdateWithoutMerchantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_item?: StringFieldUpdateOperationsInput | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    price?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sold_count?: BigIntFieldUpdateOperationsInput | bigint | number
    image_item?: NullableJsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
    category?: categoryUpdateOneWithoutMenu_itemNestedInput
    menu_item_option?: menu_item_optionUpdateManyWithoutMenu_itemNestedInput
    order_items?: order_itemUpdateManyWithoutMenu_itemNestedInput
  }

  export type menu_itemUncheckedUpdateWithoutMerchantInput = {
    id?: StringFieldUpdateOperationsInput | string
    category_id?: NullableStringFieldUpdateOperationsInput | string | null
    name_item?: StringFieldUpdateOperationsInput | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    price?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sold_count?: BigIntFieldUpdateOperationsInput | bigint | number
    image_item?: NullableJsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
    menu_item_option?: menu_item_optionUncheckedUpdateManyWithoutMenu_itemNestedInput
    order_items?: order_itemUncheckedUpdateManyWithoutMenu_itemNestedInput
  }

  export type menu_itemUncheckedUpdateManyWithoutMerchantInput = {
    id?: StringFieldUpdateOperationsInput | string
    category_id?: NullableStringFieldUpdateOperationsInput | string | null
    name_item?: StringFieldUpdateOperationsInput | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    price?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sold_count?: BigIntFieldUpdateOperationsInput | bigint | number
    image_item?: NullableJsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
  }

  export type optionUpdateWithoutMerchantInput = {
    id?: StringFieldUpdateOperationsInput | string
    option_name?: StringFieldUpdateOperationsInput | string
    multi_select?: BoolFieldUpdateOperationsInput | boolean
    require_select?: BoolFieldUpdateOperationsInput | boolean
    number_select?: BigIntFieldUpdateOperationsInput | bigint | number
    menu_item_option?: menu_item_optionUpdateManyWithoutOptionNestedInput
    option_item?: option_itemUpdateManyWithoutOptionNestedInput
  }

  export type optionUncheckedUpdateWithoutMerchantInput = {
    id?: StringFieldUpdateOperationsInput | string
    option_name?: StringFieldUpdateOperationsInput | string
    multi_select?: BoolFieldUpdateOperationsInput | boolean
    require_select?: BoolFieldUpdateOperationsInput | boolean
    number_select?: BigIntFieldUpdateOperationsInput | bigint | number
    menu_item_option?: menu_item_optionUncheckedUpdateManyWithoutOptionNestedInput
    option_item?: option_itemUncheckedUpdateManyWithoutOptionNestedInput
  }

  export type optionUncheckedUpdateManyWithoutMerchantInput = {
    id?: StringFieldUpdateOperationsInput | string
    option_name?: StringFieldUpdateOperationsInput | string
    multi_select?: BoolFieldUpdateOperationsInput | boolean
    require_select?: BoolFieldUpdateOperationsInput | boolean
    number_select?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type orderUpdateWithoutMerchantInput = {
    id?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_address?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_fee?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    status_payment?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    user?: usersUpdateOneRequiredWithoutOrdersNestedInput
    items?: order_itemUpdateManyWithoutOrderNestedInput
    payments?: payment_transactionUpdateManyWithoutOrderNestedInput
  }

  export type orderUncheckedUpdateWithoutMerchantInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_address?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_fee?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    status_payment?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    items?: order_itemUncheckedUpdateManyWithoutOrderNestedInput
    payments?: payment_transactionUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type orderUncheckedUpdateManyWithoutMerchantInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_address?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_fee?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    status_payment?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type payment_transactionUpdateWithoutMerchantInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    txn_ref?: StringFieldUpdateOperationsInput | string
    transaction_no?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    response_code?: NullableStringFieldUpdateOperationsInput | string | null
    bank_code?: NullableStringFieldUpdateOperationsInput | string | null
    pay_date?: NullableStringFieldUpdateOperationsInput | string | null
    tmn_code?: NullableStringFieldUpdateOperationsInput | string | null
    raw_payload?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: orderUpdateOneWithoutPaymentsNestedInput
    user?: usersUpdateOneRequiredWithoutPayment_transactionsNestedInput
  }

  export type payment_transactionUncheckedUpdateWithoutMerchantInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    order_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    txn_ref?: StringFieldUpdateOperationsInput | string
    transaction_no?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    response_code?: NullableStringFieldUpdateOperationsInput | string | null
    bank_code?: NullableStringFieldUpdateOperationsInput | string | null
    pay_date?: NullableStringFieldUpdateOperationsInput | string | null
    tmn_code?: NullableStringFieldUpdateOperationsInput | string | null
    raw_payload?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type payment_transactionUncheckedUpdateManyWithoutMerchantInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    order_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    txn_ref?: StringFieldUpdateOperationsInput | string
    transaction_no?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    response_code?: NullableStringFieldUpdateOperationsInput | string | null
    bank_code?: NullableStringFieldUpdateOperationsInput | string | null
    pay_date?: NullableStringFieldUpdateOperationsInput | string | null
    tmn_code?: NullableStringFieldUpdateOperationsInput | string | null
    raw_payload?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type menu_itemCreateManyCategoryInput = {
    id?: string
    merchant_id: string
    name_item: string
    likes?: bigint | number
    price: bigint | number
    description?: string | null
    sold_count?: bigint | number
    image_item?: NullableJsonNullValueInput | InputJsonValue
    status?: boolean
  }

  export type menu_itemUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_item?: StringFieldUpdateOperationsInput | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    price?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sold_count?: BigIntFieldUpdateOperationsInput | bigint | number
    image_item?: NullableJsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
    merchant?: merchantUpdateOneRequiredWithoutMenu_itemNestedInput
    menu_item_option?: menu_item_optionUpdateManyWithoutMenu_itemNestedInput
    order_items?: order_itemUpdateManyWithoutMenu_itemNestedInput
  }

  export type menu_itemUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchant_id?: StringFieldUpdateOperationsInput | string
    name_item?: StringFieldUpdateOperationsInput | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    price?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sold_count?: BigIntFieldUpdateOperationsInput | bigint | number
    image_item?: NullableJsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
    menu_item_option?: menu_item_optionUncheckedUpdateManyWithoutMenu_itemNestedInput
    order_items?: order_itemUncheckedUpdateManyWithoutMenu_itemNestedInput
  }

  export type menu_itemUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchant_id?: StringFieldUpdateOperationsInput | string
    name_item?: StringFieldUpdateOperationsInput | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    price?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sold_count?: BigIntFieldUpdateOperationsInput | bigint | number
    image_item?: NullableJsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
  }

  export type menu_item_optionCreateManyMenu_itemInput = {
    option_id: string
  }

  export type order_itemCreateManyMenu_itemInput = {
    id?: string
    order_id: string
    note?: string | null
    quantity: bigint | number
    price: bigint | number
  }

  export type menu_item_optionUpdateWithoutMenu_itemInput = {
    option?: optionUpdateOneRequiredWithoutMenu_item_optionNestedInput
  }

  export type menu_item_optionUncheckedUpdateWithoutMenu_itemInput = {
    option_id?: StringFieldUpdateOperationsInput | string
  }

  export type menu_item_optionUncheckedUpdateManyWithoutMenu_itemInput = {
    option_id?: StringFieldUpdateOperationsInput | string
  }

  export type order_itemUpdateWithoutMenu_itemInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: BigIntFieldUpdateOperationsInput | bigint | number
    price?: BigIntFieldUpdateOperationsInput | bigint | number
    order?: orderUpdateOneRequiredWithoutItemsNestedInput
    options?: order_item_optionUpdateManyWithoutOrder_itemNestedInput
  }

  export type order_itemUncheckedUpdateWithoutMenu_itemInput = {
    id?: StringFieldUpdateOperationsInput | string
    order_id?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: BigIntFieldUpdateOperationsInput | bigint | number
    price?: BigIntFieldUpdateOperationsInput | bigint | number
    options?: order_item_optionUncheckedUpdateManyWithoutOrder_itemNestedInput
  }

  export type order_itemUncheckedUpdateManyWithoutMenu_itemInput = {
    id?: StringFieldUpdateOperationsInput | string
    order_id?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: BigIntFieldUpdateOperationsInput | bigint | number
    price?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type menu_item_optionCreateManyOptionInput = {
    menu_item_id: string
  }

  export type option_itemCreateManyOptionInput = {
    id?: string
    option_item_name: string
    status?: boolean
    status_select?: boolean
  }

  export type menu_item_optionUpdateWithoutOptionInput = {
    menu_item?: menu_itemUpdateOneRequiredWithoutMenu_item_optionNestedInput
  }

  export type menu_item_optionUncheckedUpdateWithoutOptionInput = {
    menu_item_id?: StringFieldUpdateOperationsInput | string
  }

  export type menu_item_optionUncheckedUpdateManyWithoutOptionInput = {
    menu_item_id?: StringFieldUpdateOperationsInput | string
  }

  export type option_itemUpdateWithoutOptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    option_item_name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    status_select?: BoolFieldUpdateOperationsInput | boolean
    order_item_options?: order_item_optionUpdateManyWithoutOption_itemNestedInput
  }

  export type option_itemUncheckedUpdateWithoutOptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    option_item_name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    status_select?: BoolFieldUpdateOperationsInput | boolean
    order_item_options?: order_item_optionUncheckedUpdateManyWithoutOption_itemNestedInput
  }

  export type option_itemUncheckedUpdateManyWithoutOptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    option_item_name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    status_select?: BoolFieldUpdateOperationsInput | boolean
  }

  export type order_item_optionCreateManyOption_itemInput = {
    order_item_id: string
  }

  export type order_item_optionUpdateWithoutOption_itemInput = {
    order_item?: order_itemUpdateOneRequiredWithoutOptionsNestedInput
  }

  export type order_item_optionUncheckedUpdateWithoutOption_itemInput = {
    order_item_id?: StringFieldUpdateOperationsInput | string
  }

  export type order_item_optionUncheckedUpdateManyWithoutOption_itemInput = {
    order_item_id?: StringFieldUpdateOperationsInput | string
  }

  export type order_itemCreateManyOrderInput = {
    id?: string
    menu_item_id: string
    note?: string | null
    quantity: bigint | number
    price: bigint | number
  }

  export type payment_transactionCreateManyOrderInput = {
    id?: string
    user_id: string
    merchant_id: string
    amount: bigint | number
    currency?: string
    txn_ref: string
    transaction_no?: string | null
    payment_method: string
    status?: $Enums.PaymentStatus
    response_code?: string | null
    bank_code?: string | null
    pay_date?: string | null
    tmn_code?: string | null
    raw_payload?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type order_itemUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: BigIntFieldUpdateOperationsInput | bigint | number
    price?: BigIntFieldUpdateOperationsInput | bigint | number
    menu_item?: menu_itemUpdateOneRequiredWithoutOrder_itemsNestedInput
    options?: order_item_optionUpdateManyWithoutOrder_itemNestedInput
  }

  export type order_itemUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    menu_item_id?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: BigIntFieldUpdateOperationsInput | bigint | number
    price?: BigIntFieldUpdateOperationsInput | bigint | number
    options?: order_item_optionUncheckedUpdateManyWithoutOrder_itemNestedInput
  }

  export type order_itemUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    menu_item_id?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: BigIntFieldUpdateOperationsInput | bigint | number
    price?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type payment_transactionUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    txn_ref?: StringFieldUpdateOperationsInput | string
    transaction_no?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    response_code?: NullableStringFieldUpdateOperationsInput | string | null
    bank_code?: NullableStringFieldUpdateOperationsInput | string | null
    pay_date?: NullableStringFieldUpdateOperationsInput | string | null
    tmn_code?: NullableStringFieldUpdateOperationsInput | string | null
    raw_payload?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    merchant?: merchantUpdateOneRequiredWithoutPayment_transactionsNestedInput
    user?: usersUpdateOneRequiredWithoutPayment_transactionsNestedInput
  }

  export type payment_transactionUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    merchant_id?: StringFieldUpdateOperationsInput | string
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    txn_ref?: StringFieldUpdateOperationsInput | string
    transaction_no?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    response_code?: NullableStringFieldUpdateOperationsInput | string | null
    bank_code?: NullableStringFieldUpdateOperationsInput | string | null
    pay_date?: NullableStringFieldUpdateOperationsInput | string | null
    tmn_code?: NullableStringFieldUpdateOperationsInput | string | null
    raw_payload?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type payment_transactionUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    merchant_id?: StringFieldUpdateOperationsInput | string
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    txn_ref?: StringFieldUpdateOperationsInput | string
    transaction_no?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    response_code?: NullableStringFieldUpdateOperationsInput | string | null
    bank_code?: NullableStringFieldUpdateOperationsInput | string | null
    pay_date?: NullableStringFieldUpdateOperationsInput | string | null
    tmn_code?: NullableStringFieldUpdateOperationsInput | string | null
    raw_payload?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type order_item_optionCreateManyOrder_itemInput = {
    option_item_id: string
  }

  export type order_item_optionUpdateWithoutOrder_itemInput = {
    option_item?: option_itemUpdateOneRequiredWithoutOrder_item_optionsNestedInput
  }

  export type order_item_optionUncheckedUpdateWithoutOrder_itemInput = {
    option_item_id?: StringFieldUpdateOperationsInput | string
  }

  export type order_item_optionUncheckedUpdateManyWithoutOrder_itemInput = {
    option_item_id?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}